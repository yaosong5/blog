{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"themes/maupassant/source/css/default.css","path":"css/default.css","modified":1,"renderable":1},{"_id":"themes/maupassant/source/css/donate.css","path":"css/donate.css","modified":1,"renderable":1},{"_id":"themes/maupassant/source/donate/index.html","path":"donate/index.html","modified":1,"renderable":1},{"_id":"themes/maupassant/source/css/style.scss","path":"css/style.scss","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/AliPayQR.png","path":"img/AliPayQR.png","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/BTCQR.png","path":"img/BTCQR.png","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/alipay.svg","path":"img/alipay.svg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/WeChatQR.png","path":"img/WeChatQR.png","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/bitcoin.svg","path":"img/bitcoin.svg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/github.svg","path":"img/github.svg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/paypal.svg","path":"img/paypal.svg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/like.svg","path":"img/like.svg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/wechat.svg","path":"img/wechat.svg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/codeblock-resizer.js","path":"js/codeblock-resizer.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/donate.js","path":"js/donate.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/fancybox.js","path":"js/fancybox.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/search.js","path":"js/search.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/smartresize.js","path":"js/smartresize.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/share.js","path":"js/share.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/totop.js","path":"js/totop.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/gitment.browser.js","path":"js/gitment.browser.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"9e205238c7526e10c04946e95cd1cca048fe608c","modified":1533579411527},{"_id":"source/CNAME","hash":"644e70095e994a1949b603b7667f3b3a3efd7ea1","modified":1526797840397},{"_id":"source/baidu_verify_WHXmBFaAkY.html","hash":"36e24c745efca4967a17ac5c5a1138579ff4d299","modified":1526521981988},{"_id":"source/google00655d7c846aab3a.html","hash":"ef9d527a608cd37ec86911e11d73c4fd83f6e5b3","modified":1526523340515},{"_id":"themes/maupassant/.travis.yml","hash":"0339959f29deddc365e8fe8bd85da524410b9a23","modified":1536051740850},{"_id":"themes/maupassant/LICENSE","hash":"f0ac2f92770650c9835183f79010c0d307b34acd","modified":1536051740851},{"_id":"themes/maupassant/README.md","hash":"a3dcfa9b646980ee5811ec03b4c5786618b85ff9","modified":1536051740851},{"_id":"themes/maupassant/_config.yml","hash":"d67293dac1559afd76219b5a9c7e5a006e1f9346","modified":1536051740852},{"_id":"themes/maupassant/package.json","hash":"f092433469eb87362e831326425a6a5c3c9fea0d","modified":1536051740859},{"_id":"source/404/index.md","hash":"c8c926f4b57bda1eb7519e726b3c260e81229d66","modified":1525773651508},{"_id":"source/about/index.md","hash":"eb6e7d592f6298be88301cb3adbc5698ed80d266","modified":1533626870398},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1536049511601},{"_id":"source/_posts/Ambari搭建.md","hash":"2362fceffaf3802fc4fc1bd932d804b97f779af2","modified":1533926917181},{"_id":"source/_posts/Centos7上搭建Jenkins.md","hash":"2e6a2dc9ad8e897345543db2a72a0e1f4be2464b","modified":1533952814159},{"_id":"source/_posts/CoudearManager搭建.md","hash":"b851be218be9961c1551360b1c1f4af6441cb4dd","modified":1533927949436},{"_id":"source/_posts/DataStream简介.md","hash":"71d08db625eb69e87dedd1978876a12a93ea1225","modified":1536071512060},{"_id":"source/_posts/Docker-machine的搭建(与宿主机在同一ip段下).md","hash":"ee04c1d1455f9a2fd588ba1227dc4dc975759c99","modified":1535076075797},{"_id":"source/_posts/Docker命令汇集.md","hash":"ed9fe0c4f4d5bef2be2ba153ae2903661df433b1","modified":1535076782239},{"_id":"source/_posts/Docker安装Hadoop集群【引用】.md","hash":"7e786341bf54bc43fecd8ba28f90dc0a31055769","modified":1533583654504},{"_id":"source/_posts/Docker构建免密登录.md","hash":"62c05f65b98fc103995fa4f387d1a43a77b1114c","modified":1533929084124},{"_id":"source/_posts/HBase性能分析.md","hash":"7b55a7e9df1aa7591728739391d6cb844ac430ae","modified":1534344377237},{"_id":"source/_posts/HBase拷贝生产环境数据到本地运行调试.md","hash":"d72d1502dc891baf9d83b9204e677a94f39cf1f6","modified":1534343392538},{"_id":"source/_posts/HDFS元数据备份流程.md","hash":"b62776c58876a04b092a5c590f6fcce7924dc27f","modified":1534348602934},{"_id":"source/_posts/Hadoop-构成及HA-.md","hash":"269b5dc6fcbd381e2c74ef7e8b809a85c32b7927","modified":1534416769096},{"_id":"source/_posts/Hadoop零碎知识点.md","hash":"4a3df08253dc0d90b815cc6b67e91a172949735b","modified":1536114234650},{"_id":"source/_posts/Hbase-shell操作.md","hash":"6bd4230d05bbc7f92479ee0b5bea692bc81f85d7","modified":1533924025636},{"_id":"source/_posts/Hdfs结构性能分析及读写流程.md","hash":"87b819c9fae997e3ffe60cf9fea19e9a7a1b7ac6","modified":1534434524374},{"_id":"source/_posts/Hive sql相关.md","hash":"43cc1bb52554e7dd51b914d1f05beccc135c4fb3","modified":1535601608449},{"_id":"source/_posts/Hive分桶表相关.md","hash":"8b852b550bfb517ef513a2bc87982b107044b6cb","modified":1534150852971},{"_id":"source/_posts/Hive搭建及启动.md","hash":"2a306829594cffa7ec3a2025225095df61be58d6","modified":1534356883446},{"_id":"source/_posts/Hive累计报表.md","hash":"f5d63b907d0492f2ab2e141a2d495b883db7f81b","modified":1534236495072},{"_id":"source/_posts/Hive自定义函数流程.md","hash":"e4afa1e6a7d8a7aa9ff2b511426c94ae1c898f4b","modified":1534130384441},{"_id":"source/_posts/Json与Scala类型的一些互相转换处理.md","hash":"c7999375ea024cdd36cf28c9f17acae01b2dc2ff","modified":1533929946343},{"_id":"source/_posts/Kafka小知识点.md","hash":"34a38f5828390b9e655acde29066ee2b1813b5f6","modified":1534305297767},{"_id":"source/_posts/Kafka深入解析.md","hash":"5f14bfd7170121b8cb987d3998e2493056148279","modified":1534235428045},{"_id":"source/_posts/Kafka读取数据性能.md","hash":"33f15ae798794e759897f1208d8cede97292e9fc","modified":1534317804298},{"_id":"source/_posts/Kafka集群配置及配置文件.md","hash":"e69acbc60842e54a3e6a7f5732e1f31f38e0f2f5","modified":1534144894526},{"_id":"source/_posts/Linux命令积累.md","hash":"3ee1a34b2d90b9110a1563c629e249a68cf76df0","modified":1535076862229},{"_id":"source/_posts/Linux安装mysql.md","hash":"b7a51abab9baf2ddb575d24b9557ce5332bd45da","modified":1533923576914},{"_id":"source/_posts/MapReduce中Shuffle中的机制.md","hash":"baf12a61288315909787f15f2e8d21ccd80398ac","modified":1534846000273},{"_id":"source/_posts/MyBatis注解.md","hash":"8727b19807e6bfa1fe4cc85bafa56affdb5fd3fa","modified":1533923573516},{"_id":"source/_posts/Scala基本使用.md","hash":"541ce6b2827f9e924e1321a5a54fa1c8c3fefe4e","modified":1535102653619},{"_id":"source/_posts/Spark-On-yarn.md","hash":"0e45afaa4d08a6d5aaf58a143749d846e9830cf7","modified":1534472367066},{"_id":"source/_posts/Spark-on-Yarn源码解析(一)Yarn任务解析.md","hash":"a8c65915f09b7b4187949605fe3e5c5bbfab5597","modified":1536056036834},{"_id":"source/_posts/Spark-on-Yarn源码解析(三)client做的事情.md","hash":"60a34eeb5f38968db39d86ab6b8434bda457a80f","modified":1536056043710},{"_id":"source/_posts/Spark-on-Yarn源码解析(二)Spark-Submit解析.md","hash":"473a37d6b659a4bc65c257903d3a56867641e011","modified":1536055994301},{"_id":"source/_posts/Spark-on-Yarn源码解析(四)Spark业务代码的执行及其任务分配调度stage划分.md","hash":"9927d1b3db323ec3ef7f9929cdf8e2acb3c7e7b9","modified":1536056175370},{"_id":"source/_posts/SparkSQL介绍.md","hash":"79adce13224b71e06ec4c5b6d92212084e70247a","modified":1534729093848},{"_id":"source/_posts/SparkRDD介绍.md","hash":"7df3b0bc2909f3a81d3c2f1cb50be0dc23d248c1","modified":1535074450728},{"_id":"source/_posts/SparkStreaming介绍.md","hash":"2be6a31b51311d78605bb377b1fb46280050879a","modified":1534356580373},{"_id":"source/_posts/SparkStreaming消费Kafka数据.md","hash":"cb0c59bb44ac652e46492a99a26a46c650c762c3","modified":1534729158490},{"_id":"source/_posts/Spark启动流程及一些小总结.md","hash":"9ec83cd37e9f2d3c605339b9ce9decb9d41d880f","modified":1535043045753},{"_id":"source/_posts/Spark本地调试远程集群程序.md","hash":"7bb1024832a440e323b6529de22190ea4af4910e","modified":1533925783521},{"_id":"source/_posts/Spark算子.md","hash":"e6ad729d25ce2fa4bf403f89f3f1f973952b3345","modified":1534729482481},{"_id":"source/_posts/Spark读取HBase解析json创建临时表录入到Hive表.md","hash":"d1bdc3e041243c9ed92ce6c0f2408c2a65d322eb","modified":1534140998124},{"_id":"source/_posts/Spark读取Hbase.md","hash":"f8910b0b395f9ace9e5955c9e1a56604be1e0000","modified":1533923807563},{"_id":"source/_posts/elk容器的搭建.md","hash":"e7a000659e41efe3b5a0c8bccb21d738a1543f10","modified":1533923432279},{"_id":"source/_posts/es测试命令.md","hash":"a13d639a83eea01e4ed2d97565c52f667b1ef1df","modified":1533924133602},{"_id":"source/_posts/flink容器搭建.md","hash":"0019bb4339447066b460ac18473cbfe58611eda1","modified":1533610378322},{"_id":"source/_posts/git命令总结.md","hash":"e1a6abe33932133099f5c3c78fb797c63cb4dc00","modified":1533924076275},{"_id":"source/_posts/hadoop-spark集群搭建.md","hash":"60d4c71031649f3ae593b0c646190f27445249e1","modified":1533917267069},{"_id":"source/_posts/hbasezk容器的搭建.md","hash":"d0ebe2765ae2caa776e85a83e63b9109868aa61c","modified":1534343644875},{"_id":"source/_posts/hue搭建.md","hash":"c1687d78a6b4ee7c4b740245d9868d7a0adaa2fb","modified":1533923059068},{"_id":"source/_posts/json-tool使用.md","hash":"74838d075d6711a171723fd79e8d621e3dc2f302","modified":1533923216174},{"_id":"source/_posts/kafka启动脚本及命令.md","hash":"77c8610aff7578465a2ae7645e7bb2f18ed83a01","modified":1534246576094},{"_id":"source/_posts/mainlib.db","hash":"c941949a00625e5b7bc35a0fdc5741d8632c6a5f","modified":1535598845599},{"_id":"source/_posts/spring集成权限校验.md","hash":"231399cd65875286327274bd3968048cc02e86bc","modified":1526559682941},{"_id":"source/_posts/zookeeper配置.md","hash":"121b8b2bd13f0acf3f843a78ff23678a9f980062","modified":1533923895529},{"_id":"source/_posts/博客修改备份.md","hash":"66481baff4799003e116004f24a9a4232e4ef27c","modified":1526573926428},{"_id":"source/_posts/博客源文件提交到仓库.md","hash":"a57d89b78eea7cdbdc2f401bfb963ec140bedbe3","modified":1526924643947},{"_id":"source/_posts/各种快捷键.md","hash":"5856520f1cb01f9e789fae03c061f1cf5cbd1bb8","modified":1533926441685},{"_id":"source/_posts/大数据命令积累.md","hash":"411d8401f4ba2959027898ac226b4a4b78026a24","modified":1533579609751},{"_id":"source/_posts/转移Github博客到云服务器.md","hash":"7198dafdd90d456abbbd2fca141f773b61a5a2f2","modified":1533925934487},{"_id":"source/categories/index.md","hash":"13f3d932ad7c8e68ce9c5fe489de1e2398d031f9","modified":1533626884841},{"_id":"source/tags/index.md","hash":"b5cea9db4620416c871ea1b14b7eddf23b330779","modified":1533626849135},{"_id":"themes/maupassant/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1536051740844},{"_id":"themes/maupassant/.git/config","hash":"037345b11c41abb3dbbbd6e0242ced24979a7097","modified":1536051740846},{"_id":"themes/maupassant/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1536051701935},{"_id":"themes/maupassant/.git/index","hash":"81171540ef278234e0bf01410deec1c3bb914b76","modified":1536053572252},{"_id":"themes/maupassant/.git/packed-refs","hash":"af879af1afdc3423352746eef12e7698c689fa99","modified":1536051740843},{"_id":"themes/maupassant/languages/de-DE.yml","hash":"5d3556a885e355a8c2da65ef3e7b3ee36a628bfa","modified":1536051740852},{"_id":"themes/maupassant/languages/en.yml","hash":"c3fb5c155560a00889a75882c680afe1197ebf1a","modified":1536051740852},{"_id":"themes/maupassant/languages/es-ES.yml","hash":"58e1d04bcd1834fa9d2960e18e027abbbccbedc9","modified":1536051740852},{"_id":"themes/maupassant/languages/fr-FR.yml","hash":"b47906ec0abf867fb3e3360bc046b7afb68aee25","modified":1536051740852},{"_id":"themes/maupassant/languages/ko.yml","hash":"909a33e0befa6978e8e72157c6b415b48551ee31","modified":1536051740853},{"_id":"themes/maupassant/languages/ru.yml","hash":"2476a631f4d3c668de04af85a6c2c97ba2a57e96","modified":1536051740853},{"_id":"themes/maupassant/languages/zh-CN.yml","hash":"710b204e637c18b86ac7c681f7d1cf8dfeddf4bb","modified":1536051740853},{"_id":"themes/maupassant/languages/zh-TW.yml","hash":"bf3ab970f2ab3f29ddeb9f59bf98163be635e284","modified":1536051740853},{"_id":"themes/maupassant/layout/archive.pug","hash":"665582bb4092fcd81bfaf4d08fc1689abee1e6c4","modified":1536051740857},{"_id":"themes/maupassant/layout/base-without-sidebar.pug","hash":"16c4d1079450f801b5ac079d3cc101856d8f387c","modified":1536051740857},{"_id":"themes/maupassant/layout/base.pug","hash":"a4e32bcb580b76af9ad0582d9d3f0107e34509ed","modified":1536051740858},{"_id":"themes/maupassant/layout/index.pug","hash":"0435a4e5f5c6976e05b3079d335453c246f5ba6e","modified":1536051740858},{"_id":"themes/maupassant/layout/page.pug","hash":"8cfd307b13cad8be34a1e75c4566f96c1722e08e","modified":1536051740858},{"_id":"themes/maupassant/layout/post.pug","hash":"ead043c9083507b919f5c504b89a50f90d928e57","modified":1536051740858},{"_id":"themes/maupassant/layout/single-column.pug","hash":"0593f261dc208bb0b5c4232eb41eff597a291bd9","modified":1536051740858},{"_id":"themes/maupassant/layout/timeline.pug","hash":"84fbfc92ccdf291b491140d89557553141a5d3f9","modified":1536051740859},{"_id":"source/_posts/.MWebMetaData/0713430F6F73E8D6849789E2EE6FEE7E.data","hash":"96b0f6229fd61e8ddd82cc20c4572cbd0a187be9","modified":1536111585626},{"_id":"source/_posts/.MWebMetaData/1615C43C4C762BC00BE3D0337BB8112E.data","hash":"308ddcdeb6e06b21827e92196a486646c866c580","modified":1536111567158},{"_id":"source/_posts/.MWebMetaData/558CCDAEE9F3FA7F9199CDC1CC1159F0.data","hash":"d8f9caf8f7a7e4adc9f035bf1aa78639c4afe606","modified":1536111548184},{"_id":"source/_posts/.MWebMetaData/75F0A7DCF2D367D3E05BF96373D16CEE.data","hash":"3fab6a0d6d21ada2bda1f3b92d08a85b6131e1bd","modified":1536111472159},{"_id":"source/_posts/attachments/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1534346407289},{"_id":"source/_posts/images/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1526627006441},{"_id":"source/_posts/metadata/134A9FDBB9C2E6477B875B34D30A8D9B.data","hash":"3ab5ab0051828cbe29e21eafb50a87874c3bcfdf","modified":1535598682768},{"_id":"source/_posts/metadata/ED08FB4969FF179E2535A693EE43079D.data","hash":"228bf2245398b82113d2e2da3fd00cee65f85b1b","modified":1535596466462},{"_id":"source/_posts/metadata/publish-sh-15355953057944.data","hash":"ba870d31b166135b759023f10db72f41f5ba4357","modified":1535598831108},{"_id":"themes/maupassant/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1536051701937},{"_id":"themes/maupassant/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1536051701936},{"_id":"themes/maupassant/.git/hooks/fsmonitor-watchman.sample","hash":"f7c0aa40cb0d620ff0bca3efe3521ec79e5d7156","modified":1536051701938},{"_id":"themes/maupassant/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1536051701939},{"_id":"themes/maupassant/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1536051701939},{"_id":"themes/maupassant/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1536051701937},{"_id":"themes/maupassant/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1536051701940},{"_id":"themes/maupassant/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1536051701937},{"_id":"themes/maupassant/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1536051701938},{"_id":"themes/maupassant/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1536051701939},{"_id":"themes/maupassant/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1536051701940},{"_id":"themes/maupassant/.git/info/exclude","hash":"bb5a85730dcf100facee799c05cc4f6affec0745","modified":1536051701935},{"_id":"themes/maupassant/.git/logs/HEAD","hash":"f00c0ea0f0802dc21bae139a1007947b402adf28","modified":1536051740845},{"_id":"themes/maupassant/layout/_partial/after_footer.pug","hash":"bf5e24891d18c19b31ef7887cd22ae2a74f9ad4b","modified":1536051740853},{"_id":"themes/maupassant/layout/_partial/comments.pug","hash":"69fa52eac8dfcf8073db7e540a4b0e87f41654f6","modified":1536051740854},{"_id":"themes/maupassant/layout/_partial/footer.pug","hash":"650781b5bc8c632658ad6880ba663b1e3bfb5798","modified":1536051740854},{"_id":"themes/maupassant/layout/_partial/head.pug","hash":"e672914a8451b269c1033cd8c55e026beb3a9135","modified":1536051740854},{"_id":"themes/maupassant/layout/_partial/helpers.pug","hash":"acdf9e2d52ee86c831fa15ce1570930c5779bc78","modified":1536051740854},{"_id":"themes/maupassant/layout/_partial/mathjax.pug","hash":"e3a5e2d44ac261e3168a0b10e968f9a57bc5a237","modified":1536051740854},{"_id":"themes/maupassant/layout/_partial/mathjax2.pug","hash":"75cfa2cda3ff0681d03bbe89326818b824e5e524","modified":1536051740855},{"_id":"themes/maupassant/layout/_partial/paginator.pug","hash":"53f9cb77448e84a98da5eb688e2e12b173c555bb","modified":1536051740855},{"_id":"themes/maupassant/layout/_partial/post_nav.pug","hash":"a2d698c84bb6da08195fe870dbd7215f65388d3f","modified":1536051740855},{"_id":"themes/maupassant/layout/_partial/tag.pug","hash":"0f0e6770e9d5dd8040e330d71bbbfadd2df36a28","modified":1536051740855},{"_id":"themes/maupassant/layout/_partial/totop.pug","hash":"8225bbc3cdb9648bc2e6872e5c616a9a1e4def4f","modified":1536051740855},{"_id":"themes/maupassant/layout/_partial/wordcount.pug","hash":"004c8a3edc19d428179b83a0f97eae3c1a6d3cfa","modified":1536051740855},{"_id":"themes/maupassant/layout/_widget/category.pug","hash":"7c6aed762934ca51aa2669b886254da24b77bc14","modified":1536051740856},{"_id":"themes/maupassant/layout/_widget/links.pug","hash":"c45aa7ec00158579e58f1f8dfd890447bb5e5e54","modified":1536051740856},{"_id":"themes/maupassant/layout/_widget/recent_comments.pug","hash":"4102d446f13b02ff617f055c2a8f726bca12744a","modified":1536051740856},{"_id":"themes/maupassant/layout/_widget/recent_posts.pug","hash":"19431336d724d2118e46da43683bce9063176541","modified":1536051740857},{"_id":"themes/maupassant/layout/_widget/search.pug","hash":"6e8e4123cca38840c4607c1a056205972b82bb7b","modified":1536051740857},{"_id":"themes/maupassant/layout/_widget/tag.pug","hash":"132f049ce677d0e38f50073174c4ee4b825d4a06","modified":1536051740857},{"_id":"themes/maupassant/source/css/default.css","hash":"7fbb18b73b44ed11193739c55fce53a6f173cf68","modified":1536051740859},{"_id":"themes/maupassant/source/css/donate.css","hash":"f019876946aeb80e567ece250d54c1327c794583","modified":1536051740859},{"_id":"themes/maupassant/source/donate/index.html","hash":"bd5cbe475b7bce89a8c96375c56c8e3e188d6afc","modified":1536051740860},{"_id":"themes/maupassant/source/css/style.scss","hash":"b44da192f0875e144bf7990a99b42e31e986e099","modified":1536051740860},{"_id":"themes/maupassant/source/img/AliPayQR.png","hash":"7787b5d91cbf0e19a1260df24f7d949771c7d45b","modified":1536051740861},{"_id":"themes/maupassant/source/img/BTCQR.png","hash":"7d1c80f953bfb6f0a37d432b04c936ea165bfd97","modified":1536051740861},{"_id":"themes/maupassant/source/img/alipay.svg","hash":"46cc0552a9f6d700d618db3fcad25e1b8e697e36","modified":1536051740861},{"_id":"themes/maupassant/source/img/WeChatQR.png","hash":"8c41aca7883e5ff714c56556f5fff8e7e7c38093","modified":1536051740861},{"_id":"themes/maupassant/source/img/bitcoin.svg","hash":"635f7cca5e675d192be2717788175c7a2146013a","modified":1536051740862},{"_id":"themes/maupassant/source/img/github.svg","hash":"90ba9a3b0dc19e70e742a39b014194f801e00f97","modified":1536051740862},{"_id":"themes/maupassant/source/img/paypal.svg","hash":"92f3bc495f20a0190d3041be03345c46d6238c25","modified":1536051740862},{"_id":"themes/maupassant/source/img/like.svg","hash":"22a2754dc454d7b0321b70914fb2936b8d2ea8ab","modified":1536051740862},{"_id":"themes/maupassant/source/img/wechat.svg","hash":"330496ad42446a29f37a2b97fc388ebd77a8cb9f","modified":1536051740863},{"_id":"themes/maupassant/source/js/codeblock-resizer.js","hash":"5d0b786d60bf225d9eabcc9cece2719ff4d9b6cd","modified":1536051740863},{"_id":"themes/maupassant/source/js/donate.js","hash":"780beaaf44b1e6c057752bdbc085b1048937e5e7","modified":1536051740863},{"_id":"themes/maupassant/source/js/fancybox.js","hash":"13c4781570339f4fba76a3d7f202e442817dd605","modified":1536051740863},{"_id":"themes/maupassant/source/js/search.js","hash":"0c0630e2ef213701d393b041f10572e951a27985","modified":1536051740865},{"_id":"themes/maupassant/source/js/smartresize.js","hash":"3ef157fd877167e3290f42c67a624ea375a46c24","modified":1536051740865},{"_id":"themes/maupassant/source/js/share.js","hash":"a2f9de374523dc7f2ddb90ed5f24b668c20d9272","modified":1536051740865},{"_id":"themes/maupassant/source/js/totop.js","hash":"7dbf8fcf582a4fb6eb9b2c60d6de9f9c2091ec4c","modified":1536051740865},{"_id":"themes/maupassant/.git/objects/pack/pack-51e8c1926f960dc64f9865427c3a3d53bc7d0696.idx","hash":"0fd09319cf5b7b86f0659aef9f66b3fe6f5886e2","modified":1536051740834},{"_id":"themes/maupassant/.git/refs/heads/master","hash":"e5c0f939055304f017fc7686e2a02d268d7efe87","modified":1536051740845},{"_id":"themes/maupassant/source/js/gitment.browser.js","hash":"376446d9c5930576016f97dd63e5e6616c94d8d4","modified":1536051740864},{"_id":"themes/maupassant/.git/logs/refs/heads/master","hash":"f00c0ea0f0802dc21bae139a1007947b402adf28","modified":1536051740845},{"_id":"themes/maupassant/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1536051740844},{"_id":"source/_posts/attachments/json-tool.jar","hash":"0984a87b8dcf45f7f1a8de8df7c9cafef3a6173f","modified":1527644841669},{"_id":"themes/maupassant/.git/logs/refs/remotes/origin/HEAD","hash":"f00c0ea0f0802dc21bae139a1007947b402adf28","modified":1536051740844},{"_id":"themes/maupassant/.git/objects/pack/pack-51e8c1926f960dc64f9865427c3a3d53bc7d0696.pack","hash":"728f2ab1e468e7109e22e1c899ba8b93fa1e91cb","modified":1536051740833}],"Category":[{"name":"安装部署","_id":"cjloj0lku0006ykpbnknh43bb"},{"name":"大数据","_id":"cjloj0ll8000mykpbz1ncrhz7"},{"name":"Docker","_id":"cjloj0llb000uykpblque9q6n"},{"name":"环境配置","_id":"cjloj0llg0017ykpboykk81w1"},{"name":"总结","_id":"cjloj0llr001zykpbvxbp1nfg"},{"name":"组件","_id":"cjloj0llu0028ykpb8krs5csd"},{"name":"Linux","_id":"cjloj0lm0002oykpblp2ugp3u"},{"name":"框架","_id":"cjloj0lm3002wykpbtiyfyzfu"},{"name":"语言","_id":"cjloj0lm60034ykpb77er2dcs"},{"name":"Spark-On-Yarn","_id":"cjloj0lma003dykpb6afh0fjf"},{"name":"工程框架","_id":"cjloj0lmv004oykpbj3og8pzy"},{"name":"tool","_id":"cjloj0ln10053ykpbzcpooyj7"},{"name":"Spring","_id":"cjloj0ln6005dykpb0v025wio"},{"name":"Hexo","_id":"cjloj0lna005mykpbtuu8tfya"},{"name":"博客","_id":"cjloj0lnc005uykpbncvxh9gn"},{"name":"快捷键","_id":"cjloj0lne0061ykpb5ins0d50"},{"name":"碎片知识","_id":"cjloj0lnf0068ykpbcwuvx1fq"}],"Data":[],"Page":[{"_content":"google-site-verification: google00655d7c846aab3a.html","source":"google00655d7c846aab3a.html","raw":"google-site-verification: google00655d7c846aab3a.html","date":"2018-05-18T06:50:40.022Z","updated":"2018-05-17T02:15:40.515Z","path":"google00655d7c846aab3a.html","title":"","comments":1,"layout":"page","_id":"cjloj0lis0000ykpbe609l3al","content":"google-site-verification: google00655d7c846aab3a.html","site":{"data":{}},"excerpt":"","more":"google-site-verification: google00655d7c846aab3a.html"},{"_content":"WHXmBFaAkY","source":"baidu_verify_WHXmBFaAkY.html","raw":"WHXmBFaAkY","date":"2018-05-18T06:50:40.014Z","updated":"2018-05-17T01:53:01.988Z","path":"baidu_verify_WHXmBFaAkY.html","title":"","comments":1,"layout":"page","_id":"cjloj0lit0001ykpb1j52gd38"},{"title":"404 Not Found：该页无法显示","toc":false,"comments":0,"_content":"","source":"404/index.md","raw":"title: 404 Not Found：该页无法显示\ntoc: false\ncomments: false\npermalink: /404\n---\n","date":"2018-05-18T06:50:42.172Z","updated":"2018-05-08T10:00:51.508Z","path":"/404.html","layout":"page","_id":"cjloj0lkm0002ykpbgkpr3knc"},{"title":"关于","date":"2018-05-08T07:52:07.000Z","_content":"Nothing\n","source":"about/index.md","raw":"---\ntitle: 关于\ndate: 2018-05-08 15:52:07\n---\nNothing\n","updated":"2018-08-07T07:27:50.398Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjloj0lkr0004ykpbpr77lx2k"},{"title":"分类","layout":"categories","_content":"","source":"categories/index.md","raw":"title: \"分类\"\nlayout: \"categories\"\n---\n","date":"2018-08-13T06:25:13.838Z","updated":"2018-08-07T07:28:04.841Z","path":"categories/index.html","comments":1,"_id":"cjloj0m78009lykpbk6yjx2ec"},{"title":"标签","layout":"tags","_content":"","source":"tags/index.md","raw":"title: \"标签\"\nlayout: \"tags\"\n---\n","date":"2018-08-07T07:27:29.140Z","updated":"2018-08-07T07:27:29.135Z","path":"tags/index.html","comments":1,"_id":"cjloj0m78009mykpb6gm0r3kp"}],"Post":[{"title":"Ambari镜像搭建","date":"2018-07-09T17:08:44.939Z","toc":true,"_content":"\n\n[TOC]\n\n# 创建基础容器\n\n```bash\ndocker run -itd  --net=br  --name ambari-agent --hostname  ambari-agent yaosong5/centosbase:1.0 &> /dev/null\n```\n\n关闭 selinux , 需要重启\n`vim /etc/selinux/config` \n\n```\nSELINUX=disabled\n```\n\n<!--more -->\n\n# server端\n\n## 更换yum源\n\n```\nwget http://public-repo-1.hortonworks.com/ambari/centos6/2.x/updates/2.0.1/ambari.repo\ncp ambari.repo /etc/yum.repos.d\n```\n\n## 安装依赖及其server\n\n```\nyum install epel-release \nyum repolist\nyum install ambari-server  \n```\n\n## 启动初始化\n\n`ambari-server setup`\n会有一连串的提示\n\n会提示安装 jdk，网速好的可以确定，否则可以下载 jdk-6u31-linux-x64.bin，放到 /var/lib/ambari-server/resources/ 下面，可以指定已经安装的jdk\n接着会提示配置用的数据库，可以选择 Oracle 或 postgresql，选择 n 会按默认配置\n数据库类型：postgresql\n数据库：ambari\n用户名：ambari\n密码：bigdata\n如果提示 Oracle JDK license，yes\n等待安装完成\n\n\n\n# agent端\n\n安装 ambari-agent\n\n```\nyum install -y ambari-agent\nchkconfig --add ambari-agent\n```\n\n将 ambari.server 上的 3 个. repo 文件复制到 hadoop 集群的三台服务器上；并完成 yum 源更新的命令。\n\n 安装 ambari-agent：在集群的 3 台电脑上执行添加，并添加成开机自启动服务：　　\n\n yum install -y ambari-agent\n chkconfig --add ambari-agent\n sudo ambari-agent start\n\n# 分别启动server agent \n\n在server和agent上分别执行\n\n```\nambari-agent start\nambari-server start  \n```\n\n## 访问\n\nhttp://192.168.1.133:8080  \n\n用户名密码: admin,admin\n\n\n\n# 保存容器为镜像\n\n```bash\ndocker commit -m \"bigdata:ambari-server\"  --author=\"yaosong\"  ambr  yaosong5/ambari-server:1.0\n```\n\n# 根据镜像创建容器\n\n```bash\ndocker run -itd  --net=br  --name ambari1 --hostname ambari1 yaosong5/ambari-server:1.0 &> /dev/null\ndocker run -itd  --net=br  --name ambari2 --hostname ambari2 yaosong5/ambari-server:1.0 &> /dev/null\ndocker run -itd  --net=br  --name ambari3 --hostname ambari3 yaosong5/ambari-server:1.0 &> /dev/null\n```\n\n# 停止and删除容器\n\n```bash\ndocker stop ambari1\ndocker stop ambari2\ndocker stop ambari3\n\ndocker rm ambari1\ndocker rm ambari2\ndocker rm ambari3\n```","source":"_posts/Ambari搭建.md","raw":"---\ntitle:  Ambari镜像搭建\ndate: 2018年08月06日 22时15分52秒\ntags:  [Docker,Ambari]\ncategories: 安装部署\ntoc: true\n---\n\n\n[TOC]\n\n# 创建基础容器\n\n```bash\ndocker run -itd  --net=br  --name ambari-agent --hostname  ambari-agent yaosong5/centosbase:1.0 &> /dev/null\n```\n\n关闭 selinux , 需要重启\n`vim /etc/selinux/config` \n\n```\nSELINUX=disabled\n```\n\n<!--more -->\n\n# server端\n\n## 更换yum源\n\n```\nwget http://public-repo-1.hortonworks.com/ambari/centos6/2.x/updates/2.0.1/ambari.repo\ncp ambari.repo /etc/yum.repos.d\n```\n\n## 安装依赖及其server\n\n```\nyum install epel-release \nyum repolist\nyum install ambari-server  \n```\n\n## 启动初始化\n\n`ambari-server setup`\n会有一连串的提示\n\n会提示安装 jdk，网速好的可以确定，否则可以下载 jdk-6u31-linux-x64.bin，放到 /var/lib/ambari-server/resources/ 下面，可以指定已经安装的jdk\n接着会提示配置用的数据库，可以选择 Oracle 或 postgresql，选择 n 会按默认配置\n数据库类型：postgresql\n数据库：ambari\n用户名：ambari\n密码：bigdata\n如果提示 Oracle JDK license，yes\n等待安装完成\n\n\n\n# agent端\n\n安装 ambari-agent\n\n```\nyum install -y ambari-agent\nchkconfig --add ambari-agent\n```\n\n将 ambari.server 上的 3 个. repo 文件复制到 hadoop 集群的三台服务器上；并完成 yum 源更新的命令。\n\n 安装 ambari-agent：在集群的 3 台电脑上执行添加，并添加成开机自启动服务：　　\n\n yum install -y ambari-agent\n chkconfig --add ambari-agent\n sudo ambari-agent start\n\n# 分别启动server agent \n\n在server和agent上分别执行\n\n```\nambari-agent start\nambari-server start  \n```\n\n## 访问\n\nhttp://192.168.1.133:8080  \n\n用户名密码: admin,admin\n\n\n\n# 保存容器为镜像\n\n```bash\ndocker commit -m \"bigdata:ambari-server\"  --author=\"yaosong\"  ambr  yaosong5/ambari-server:1.0\n```\n\n# 根据镜像创建容器\n\n```bash\ndocker run -itd  --net=br  --name ambari1 --hostname ambari1 yaosong5/ambari-server:1.0 &> /dev/null\ndocker run -itd  --net=br  --name ambari2 --hostname ambari2 yaosong5/ambari-server:1.0 &> /dev/null\ndocker run -itd  --net=br  --name ambari3 --hostname ambari3 yaosong5/ambari-server:1.0 &> /dev/null\n```\n\n# 停止and删除容器\n\n```bash\ndocker stop ambari1\ndocker stop ambari2\ndocker stop ambari3\n\ndocker rm ambari1\ndocker rm ambari2\ndocker rm ambari3\n```","slug":"Ambari搭建","published":1,"updated":"2018-08-10T18:48:37.181Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloj0lkn0003ykpbliui7vle","content":"<p>[TOC]</p>\n<h1 id=\"创建基础容器\"><a href=\"#创建基础容器\" class=\"headerlink\" title=\"创建基础容器\"></a>创建基础容器</h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -itd  --net=br  --name ambari-agent --hostname  ambari-agent yaosong5/centosbase:1.0 &amp;&gt; /dev/null</span><br></pre></td></tr></table></figure>\n<p>关闭 selinux , 需要重启<br><code>vim /etc/selinux/config</code> </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELINUX=disabled</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h1 id=\"server端\"><a href=\"#server端\" class=\"headerlink\" title=\"server端\"></a>server端</h1><h2 id=\"更换yum源\"><a href=\"#更换yum源\" class=\"headerlink\" title=\"更换yum源\"></a>更换yum源</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget http://public-repo-1.hortonworks.com/ambari/centos6/2.x/updates/2.0.1/ambari.repo</span><br><span class=\"line\">cp ambari.repo /etc/yum.repos.d</span><br></pre></td></tr></table></figure>\n<h2 id=\"安装依赖及其server\"><a href=\"#安装依赖及其server\" class=\"headerlink\" title=\"安装依赖及其server\"></a>安装依赖及其server</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install epel-release </span><br><span class=\"line\">yum repolist</span><br><span class=\"line\">yum install ambari-server</span><br></pre></td></tr></table></figure>\n<h2 id=\"启动初始化\"><a href=\"#启动初始化\" class=\"headerlink\" title=\"启动初始化\"></a>启动初始化</h2><p><code>ambari-server setup</code><br>会有一连串的提示</p>\n<p>会提示安装 jdk，网速好的可以确定，否则可以下载 jdk-6u31-linux-x64.bin，放到 /var/lib/ambari-server/resources/ 下面，可以指定已经安装的jdk<br>接着会提示配置用的数据库，可以选择 Oracle 或 postgresql，选择 n 会按默认配置<br>数据库类型：postgresql<br>数据库：ambari<br>用户名：ambari<br>密码：bigdata<br>如果提示 Oracle JDK license，yes<br>等待安装完成</p>\n<h1 id=\"agent端\"><a href=\"#agent端\" class=\"headerlink\" title=\"agent端\"></a>agent端</h1><p>安装 ambari-agent</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install -y ambari-agent</span><br><span class=\"line\">chkconfig --add ambari-agent</span><br></pre></td></tr></table></figure>\n<p>将 ambari.server 上的 3 个. repo 文件复制到 hadoop 集群的三台服务器上；并完成 yum 源更新的命令。</p>\n<p> 安装 ambari-agent：在集群的 3 台电脑上执行添加，并添加成开机自启动服务：　　</p>\n<p> yum install -y ambari-agent<br> chkconfig –add ambari-agent<br> sudo ambari-agent start</p>\n<h1 id=\"分别启动server-agent\"><a href=\"#分别启动server-agent\" class=\"headerlink\" title=\"分别启动server agent\"></a>分别启动server agent</h1><p>在server和agent上分别执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ambari-agent start</span><br><span class=\"line\">ambari-server start</span><br></pre></td></tr></table></figure>\n<h2 id=\"访问\"><a href=\"#访问\" class=\"headerlink\" title=\"访问\"></a>访问</h2><p><a href=\"http://192.168.1.133:8080\" target=\"_blank\" rel=\"noopener\">http://192.168.1.133:8080</a>  </p>\n<p>用户名密码: admin,admin</p>\n<h1 id=\"保存容器为镜像\"><a href=\"#保存容器为镜像\" class=\"headerlink\" title=\"保存容器为镜像\"></a>保存容器为镜像</h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker commit -m <span class=\"string\">\"bigdata:ambari-server\"</span>  --author=<span class=\"string\">\"yaosong\"</span>  ambr  yaosong5/ambari-server:1.0</span><br></pre></td></tr></table></figure>\n<h1 id=\"根据镜像创建容器\"><a href=\"#根据镜像创建容器\" class=\"headerlink\" title=\"根据镜像创建容器\"></a>根据镜像创建容器</h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -itd  --net=br  --name ambari1 --hostname ambari1 yaosong5/ambari-server:1.0 &amp;&gt; /dev/null</span><br><span class=\"line\">docker run -itd  --net=br  --name ambari2 --hostname ambari2 yaosong5/ambari-server:1.0 &amp;&gt; /dev/null</span><br><span class=\"line\">docker run -itd  --net=br  --name ambari3 --hostname ambari3 yaosong5/ambari-server:1.0 &amp;&gt; /dev/null</span><br></pre></td></tr></table></figure>\n<h1 id=\"停止and删除容器\"><a href=\"#停止and删除容器\" class=\"headerlink\" title=\"停止and删除容器\"></a>停止and删除容器</h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker stop ambari1</span><br><span class=\"line\">docker stop ambari2</span><br><span class=\"line\">docker stop ambari3</span><br><span class=\"line\"></span><br><span class=\"line\">docker rm ambari1</span><br><span class=\"line\">docker rm ambari2</span><br><span class=\"line\">docker rm ambari3</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>[TOC]</p>\n<h1 id=\"创建基础容器\"><a href=\"#创建基础容器\" class=\"headerlink\" title=\"创建基础容器\"></a>创建基础容器</h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -itd  --net=br  --name ambari-agent --hostname  ambari-agent yaosong5/centosbase:1.0 &amp;&gt; /dev/null</span><br></pre></td></tr></table></figure>\n<p>关闭 selinux , 需要重启<br><code>vim /etc/selinux/config</code> </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELINUX=disabled</span><br></pre></td></tr></table></figure>","more":"<h1 id=\"server端\"><a href=\"#server端\" class=\"headerlink\" title=\"server端\"></a>server端</h1><h2 id=\"更换yum源\"><a href=\"#更换yum源\" class=\"headerlink\" title=\"更换yum源\"></a>更换yum源</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget http://public-repo-1.hortonworks.com/ambari/centos6/2.x/updates/2.0.1/ambari.repo</span><br><span class=\"line\">cp ambari.repo /etc/yum.repos.d</span><br></pre></td></tr></table></figure>\n<h2 id=\"安装依赖及其server\"><a href=\"#安装依赖及其server\" class=\"headerlink\" title=\"安装依赖及其server\"></a>安装依赖及其server</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install epel-release </span><br><span class=\"line\">yum repolist</span><br><span class=\"line\">yum install ambari-server</span><br></pre></td></tr></table></figure>\n<h2 id=\"启动初始化\"><a href=\"#启动初始化\" class=\"headerlink\" title=\"启动初始化\"></a>启动初始化</h2><p><code>ambari-server setup</code><br>会有一连串的提示</p>\n<p>会提示安装 jdk，网速好的可以确定，否则可以下载 jdk-6u31-linux-x64.bin，放到 /var/lib/ambari-server/resources/ 下面，可以指定已经安装的jdk<br>接着会提示配置用的数据库，可以选择 Oracle 或 postgresql，选择 n 会按默认配置<br>数据库类型：postgresql<br>数据库：ambari<br>用户名：ambari<br>密码：bigdata<br>如果提示 Oracle JDK license，yes<br>等待安装完成</p>\n<h1 id=\"agent端\"><a href=\"#agent端\" class=\"headerlink\" title=\"agent端\"></a>agent端</h1><p>安装 ambari-agent</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install -y ambari-agent</span><br><span class=\"line\">chkconfig --add ambari-agent</span><br></pre></td></tr></table></figure>\n<p>将 ambari.server 上的 3 个. repo 文件复制到 hadoop 集群的三台服务器上；并完成 yum 源更新的命令。</p>\n<p> 安装 ambari-agent：在集群的 3 台电脑上执行添加，并添加成开机自启动服务：　　</p>\n<p> yum install -y ambari-agent<br> chkconfig –add ambari-agent<br> sudo ambari-agent start</p>\n<h1 id=\"分别启动server-agent\"><a href=\"#分别启动server-agent\" class=\"headerlink\" title=\"分别启动server agent\"></a>分别启动server agent</h1><p>在server和agent上分别执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ambari-agent start</span><br><span class=\"line\">ambari-server start</span><br></pre></td></tr></table></figure>\n<h2 id=\"访问\"><a href=\"#访问\" class=\"headerlink\" title=\"访问\"></a>访问</h2><p><a href=\"http://192.168.1.133:8080\" target=\"_blank\" rel=\"noopener\">http://192.168.1.133:8080</a>  </p>\n<p>用户名密码: admin,admin</p>\n<h1 id=\"保存容器为镜像\"><a href=\"#保存容器为镜像\" class=\"headerlink\" title=\"保存容器为镜像\"></a>保存容器为镜像</h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker commit -m <span class=\"string\">\"bigdata:ambari-server\"</span>  --author=<span class=\"string\">\"yaosong\"</span>  ambr  yaosong5/ambari-server:1.0</span><br></pre></td></tr></table></figure>\n<h1 id=\"根据镜像创建容器\"><a href=\"#根据镜像创建容器\" class=\"headerlink\" title=\"根据镜像创建容器\"></a>根据镜像创建容器</h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -itd  --net=br  --name ambari1 --hostname ambari1 yaosong5/ambari-server:1.0 &amp;&gt; /dev/null</span><br><span class=\"line\">docker run -itd  --net=br  --name ambari2 --hostname ambari2 yaosong5/ambari-server:1.0 &amp;&gt; /dev/null</span><br><span class=\"line\">docker run -itd  --net=br  --name ambari3 --hostname ambari3 yaosong5/ambari-server:1.0 &amp;&gt; /dev/null</span><br></pre></td></tr></table></figure>\n<h1 id=\"停止and删除容器\"><a href=\"#停止and删除容器\" class=\"headerlink\" title=\"停止and删除容器\"></a>停止and删除容器</h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker stop ambari1</span><br><span class=\"line\">docker stop ambari2</span><br><span class=\"line\">docker stop ambari3</span><br><span class=\"line\"></span><br><span class=\"line\">docker rm ambari1</span><br><span class=\"line\">docker rm ambari2</span><br><span class=\"line\">docker rm ambari3</span><br></pre></td></tr></table></figure>"},{"title":"Centos7上搭建Jenkins","date":"2018-06-21T14:11:28.272Z","toc":true,"_content":"\n\n之前用yum模式安装，总是启动报错，解决了一番，未找到解决方案，后直接下载war包进行安装部署\n\n默认安装了Java\n<!-- more -->\n\n# 1. 安装 jenkins\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=480580003&auto=1&height=66\"></iframe>\n\n``` bash\ncd /opt\nmkdir /jenkins\ncd jenkins\nmkdir jenkins_home\nmkdir jenkins_node\nwget http://mirrors.jenkins-ci.org/war/latest/jenkins.war\n```\n\n\n# 2. 编写可执行文件\n\n  ` vim start_jenkins.sh`\n```bash\n     #!/bin/bash\n     JENKINS_ROOT=/opt/jenkins\n     export JENKINS_HOME=$JENKINS_ROOT/jenkins_home\n     java -jar $JENKINS_ROOT/jenkins.war --httpPort=8000\n```\n   修改文件的权限： ` chmod  a+x   start_jenkins.sh`\n\n   启动 jenkins:  `   nohup ./start_jenkins.sh > jenkins.log 2>& 1& `               \n# 3 访问 jenkins\n   输入 http:// 服务器地址: 8000\n\n注意：在启动日志中会出现初始密码，这个用来首次登陆Jenkins使用\n![](https://ws4.sinaimg.cn/large/006tNbRwgy1fu5j2mlpouj31d60lwtfs.jpg)\n\n\n![](https://ws3.sinaimg.cn/large/006tNbRwgy1fu5j4it7u3j31600nawfp.jpg)\n\n参考\n[在 Centos7 上搭建 jenkins](https://blog.csdn.net/python_tty/article/details/52884314)","source":"_posts/Centos7上搭建Jenkins.md","raw":"---\ntitle:  Centos7上搭建Jenkins\ndate: 2018年06月21日 22时15分52秒\ntags:  [Jenkins]\ncategories: 安装部署\ntoc: true\n---\n\n\n之前用yum模式安装，总是启动报错，解决了一番，未找到解决方案，后直接下载war包进行安装部署\n\n默认安装了Java\n<!-- more -->\n\n# 1. 安装 jenkins\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=480580003&auto=1&height=66\"></iframe>\n\n``` bash\ncd /opt\nmkdir /jenkins\ncd jenkins\nmkdir jenkins_home\nmkdir jenkins_node\nwget http://mirrors.jenkins-ci.org/war/latest/jenkins.war\n```\n\n\n# 2. 编写可执行文件\n\n  ` vim start_jenkins.sh`\n```bash\n     #!/bin/bash\n     JENKINS_ROOT=/opt/jenkins\n     export JENKINS_HOME=$JENKINS_ROOT/jenkins_home\n     java -jar $JENKINS_ROOT/jenkins.war --httpPort=8000\n```\n   修改文件的权限： ` chmod  a+x   start_jenkins.sh`\n\n   启动 jenkins:  `   nohup ./start_jenkins.sh > jenkins.log 2>& 1& `               \n# 3 访问 jenkins\n   输入 http:// 服务器地址: 8000\n\n注意：在启动日志中会出现初始密码，这个用来首次登陆Jenkins使用\n![](https://ws4.sinaimg.cn/large/006tNbRwgy1fu5j2mlpouj31d60lwtfs.jpg)\n\n\n![](https://ws3.sinaimg.cn/large/006tNbRwgy1fu5j4it7u3j31600nawfp.jpg)\n\n参考\n[在 Centos7 上搭建 jenkins](https://blog.csdn.net/python_tty/article/details/52884314)","slug":"Centos7上搭建Jenkins","published":1,"updated":"2018-08-11T02:00:14.159Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloj0lks0005ykpbazt8qz2y"},{"title":"CoudearManager搭建","date":"2018-07-10T14:10:04.881Z","toc":true,"_content":"\n[TOC]\n\n\n\n# 创建基础容器\n\n```bash\ndocker run -itd  --net=br  --name cm --hostname cm yaosong5/centosbase:1.0 &> /dev/null\n```\n\n\n\n# 将下载的包进行解压然后进行拷贝\n\n```bash\ndocker cp /Users/yaosong/Yao/cloudera-manager-el6-cm5.9.0_x86_64/cloudera cm:/opt/\ndocker cp /Users/yaosong/Yao/cloudera-manager-el6-cm5.9.0_x86_64/cm-5.9.0 cm:/opt/\ndocker cp /Users/yaosong/Yao/mysql-connector-java-5.1.40-bin.jar cm:/opt/cm-5.9.0/share/cmf/lib/\ndocker cp /Users/yaosong/Yao/mysql-connector-java.jar cm:/usr/share/java/\ndocker cp /Users/yaosong/Yao/jdk1.8 cm:/usr/local/\n```\n\n<!--more -->\n\n# 将 parcel 文件放至 /opt/cloudera/parcel-repo\n\n```bash\ndocker cp /Users/yaosong/Yao/CDH-5.9.0-1.cdh5.9.0.p0.23-el6.parcel  cm:/opt/cloudera/parcel-repo\ndocker cp /Users/yaosong/Yao/CDH-5.9.0-1.cdh5.9.0.p0.23-el6.parcel.sha cm:/opt/cloudera/parcel-repo\ndocker cp /Users/yaosong/Yao/manifest.json cm:/opt/cloudera/parcel-repo\n```\n\n\n`vim /etc/profile`\n\n```bash\nexport JAVA_HOME=/usr/local/jdk1.8\nexport PATH=$JAVA_HOME/bin:$PATH\nexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar\n```\n\n# 初始化 mysql 库\n\n```Bash\n /opt/cm-5.9.0/share/cmf/schema/scm_prepare_database.sh mysql cm -hlocalhost -uroot -proot --scm-host localhost scm scm scm\n```\n\n# 创建用户（所有节点执行）\n\n```\nuseradd --system --home=/opt/cm-5.9.0/run/cloudera-scm-server/ --no-create-home --shell=/bin/false --comment \"Cloudera SCM User\" cloudera-scm\n```\n\n# Agent 配置 \n\n`vim /opt/cm-5.9.0/etc/cloudera-scm-agent/config.ini`\n\n 将 server_host 改为主节点主机名\n\n```\nserver_host=cm1\n```\n\n\n安装mysql\n`chkconfig mysqld on`\n\n设置允许远程登录\n\n```Bash\nmysql -u root -p \nGRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'root' WITH GRANT OPTION; \n```\n\n\n\n# 创建CM用的数据库\n\n安装集群时按需创建，详见第七章第13步\n\n```Sql\n--hive数据库\ncreate database hive DEFAULT CHARSET utf8 COLLATE utf8_general_ci;\n--oozie数据库\ncreate database oozie DEFAULT CHARSET utf8 COLLATE utf8_general_ci;\n--hue数据库\ncreate database hue DEFAULT CHARSET utf8 COLLATE utf8_general_ci;\n\ncreate database amon DEFAULT CHARSET utf8 COLLATE utf8_general_ci;\n\ncreate database monitor DEFAULT CHARSET utf8 COLLATE utf8_general_ci;\n```\n\n\n\n# Cloudera推荐设置\n\n在试安装的过程，发现Cloudera给出了一些警告\n\n身为一个有洁癖的码农，自然是连黄色的感叹号都要消灭的。因此在安装CM/CDH之前就先全部设置好。\n\n## 1、设置swap空间\n\n`vim /etc/sysctl.conf`\n末尾加上\n`vm.swappiness=10`\n\n## 2、关闭大页面压缩\n\n试过只设置defrag，但貌似个别节点还是会有警告，干脆全部设置\n\n`vim /etc/rc.local`\n末尾加上(永久生效)\n`echo never > /sys/kernel/mm/transparent_hugepage/enabled`\n`echo never > /sys/kernel/mm/transparent_hugepage/defrag`\n\n\n\n\n\n# 启动cloudera manager 服务\n\n/opt/cm-5.9.0/etc/init.d/cloudera-scm-server start\n\n/opt/cm-5.9.0/etc/init.d/cloudera-scm-agent start\n\n端口 7180\n\n\n\n# 保存为镜像\n\n\tdocker commit -m \"cloudera manger image\"  cm   yaosong5/cm59:1.0\n## 创建容器\n\n\tdocker run -itd  --net=br  --name cm1 --hostname cm1 yaosong5/cm59:1.0 &> /dev/null\n\tdocker run -itd  --net=br  --name cm2 --hostname cm2 yaosong5/cm59:1.0 &> /dev/null\n\tdocker run -itd  --net=br  --name cm3 --hostname cm3 yaosong5/cm59:1.0 &> /dev/null\n\n\n\n```\ndocker stop cm1\ndocker stop cm2\ndocker stop cm3\n\ndocker rm cm1\ndocker rm cm2\ndocker rm cm3\n```\n\n\n\n\n\n# 调错\n\n> .SearchRepositoryManager: No read permission to the server storage directory [/var/lib/cloudera-scm-server]\n> 2018-07-11 10:20:39,788 ERROR SearchRepositoryManager-0:com.cloudera.server.web.cmf.search.components.SearchRepositoryManager: No write permission to the server storage directory [/var/lib/cloudera-scm-server]\n>\n\n## 链接hue连接不上\n\n节点的 cm-5.x.0/log/cloudera-scm-server/cloudera-scm-server.log，一般情况下应该会说到\n\nImportError:libxslt.so.1:cannot open shared object file:No such file ordirectory\n\n```\nyum -y install libxml2-python \n```\n\n## 提示hue测试连接连接不上，安装依赖：\n\n```bash\nyum install libxml2-python  mod_ssl install krb5-devel cyrus-sasl-gssapi cyrus-sasl-deve libxml2-devel libxslt-devel mysql mysql-devel openldap-devel python-devel python-simplejson sqlite-devel -y\n```\n\n","source":"_posts/CoudearManager搭建.md","raw":"---\ntitle:  CoudearManager搭建\ndate: 2018年08月11日 02时55分44秒\ntags:  [Docker,CDH]\ncategories: 安装部署\ntoc: true\n---\n\n[TOC]\n\n\n\n# 创建基础容器\n\n```bash\ndocker run -itd  --net=br  --name cm --hostname cm yaosong5/centosbase:1.0 &> /dev/null\n```\n\n\n\n# 将下载的包进行解压然后进行拷贝\n\n```bash\ndocker cp /Users/yaosong/Yao/cloudera-manager-el6-cm5.9.0_x86_64/cloudera cm:/opt/\ndocker cp /Users/yaosong/Yao/cloudera-manager-el6-cm5.9.0_x86_64/cm-5.9.0 cm:/opt/\ndocker cp /Users/yaosong/Yao/mysql-connector-java-5.1.40-bin.jar cm:/opt/cm-5.9.0/share/cmf/lib/\ndocker cp /Users/yaosong/Yao/mysql-connector-java.jar cm:/usr/share/java/\ndocker cp /Users/yaosong/Yao/jdk1.8 cm:/usr/local/\n```\n\n<!--more -->\n\n# 将 parcel 文件放至 /opt/cloudera/parcel-repo\n\n```bash\ndocker cp /Users/yaosong/Yao/CDH-5.9.0-1.cdh5.9.0.p0.23-el6.parcel  cm:/opt/cloudera/parcel-repo\ndocker cp /Users/yaosong/Yao/CDH-5.9.0-1.cdh5.9.0.p0.23-el6.parcel.sha cm:/opt/cloudera/parcel-repo\ndocker cp /Users/yaosong/Yao/manifest.json cm:/opt/cloudera/parcel-repo\n```\n\n\n`vim /etc/profile`\n\n```bash\nexport JAVA_HOME=/usr/local/jdk1.8\nexport PATH=$JAVA_HOME/bin:$PATH\nexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar\n```\n\n# 初始化 mysql 库\n\n```Bash\n /opt/cm-5.9.0/share/cmf/schema/scm_prepare_database.sh mysql cm -hlocalhost -uroot -proot --scm-host localhost scm scm scm\n```\n\n# 创建用户（所有节点执行）\n\n```\nuseradd --system --home=/opt/cm-5.9.0/run/cloudera-scm-server/ --no-create-home --shell=/bin/false --comment \"Cloudera SCM User\" cloudera-scm\n```\n\n# Agent 配置 \n\n`vim /opt/cm-5.9.0/etc/cloudera-scm-agent/config.ini`\n\n 将 server_host 改为主节点主机名\n\n```\nserver_host=cm1\n```\n\n\n安装mysql\n`chkconfig mysqld on`\n\n设置允许远程登录\n\n```Bash\nmysql -u root -p \nGRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'root' WITH GRANT OPTION; \n```\n\n\n\n# 创建CM用的数据库\n\n安装集群时按需创建，详见第七章第13步\n\n```Sql\n--hive数据库\ncreate database hive DEFAULT CHARSET utf8 COLLATE utf8_general_ci;\n--oozie数据库\ncreate database oozie DEFAULT CHARSET utf8 COLLATE utf8_general_ci;\n--hue数据库\ncreate database hue DEFAULT CHARSET utf8 COLLATE utf8_general_ci;\n\ncreate database amon DEFAULT CHARSET utf8 COLLATE utf8_general_ci;\n\ncreate database monitor DEFAULT CHARSET utf8 COLLATE utf8_general_ci;\n```\n\n\n\n# Cloudera推荐设置\n\n在试安装的过程，发现Cloudera给出了一些警告\n\n身为一个有洁癖的码农，自然是连黄色的感叹号都要消灭的。因此在安装CM/CDH之前就先全部设置好。\n\n## 1、设置swap空间\n\n`vim /etc/sysctl.conf`\n末尾加上\n`vm.swappiness=10`\n\n## 2、关闭大页面压缩\n\n试过只设置defrag，但貌似个别节点还是会有警告，干脆全部设置\n\n`vim /etc/rc.local`\n末尾加上(永久生效)\n`echo never > /sys/kernel/mm/transparent_hugepage/enabled`\n`echo never > /sys/kernel/mm/transparent_hugepage/defrag`\n\n\n\n\n\n# 启动cloudera manager 服务\n\n/opt/cm-5.9.0/etc/init.d/cloudera-scm-server start\n\n/opt/cm-5.9.0/etc/init.d/cloudera-scm-agent start\n\n端口 7180\n\n\n\n# 保存为镜像\n\n\tdocker commit -m \"cloudera manger image\"  cm   yaosong5/cm59:1.0\n## 创建容器\n\n\tdocker run -itd  --net=br  --name cm1 --hostname cm1 yaosong5/cm59:1.0 &> /dev/null\n\tdocker run -itd  --net=br  --name cm2 --hostname cm2 yaosong5/cm59:1.0 &> /dev/null\n\tdocker run -itd  --net=br  --name cm3 --hostname cm3 yaosong5/cm59:1.0 &> /dev/null\n\n\n\n```\ndocker stop cm1\ndocker stop cm2\ndocker stop cm3\n\ndocker rm cm1\ndocker rm cm2\ndocker rm cm3\n```\n\n\n\n\n\n# 调错\n\n> .SearchRepositoryManager: No read permission to the server storage directory [/var/lib/cloudera-scm-server]\n> 2018-07-11 10:20:39,788 ERROR SearchRepositoryManager-0:com.cloudera.server.web.cmf.search.components.SearchRepositoryManager: No write permission to the server storage directory [/var/lib/cloudera-scm-server]\n>\n\n## 链接hue连接不上\n\n节点的 cm-5.x.0/log/cloudera-scm-server/cloudera-scm-server.log，一般情况下应该会说到\n\nImportError:libxslt.so.1:cannot open shared object file:No such file ordirectory\n\n```\nyum -y install libxml2-python \n```\n\n## 提示hue测试连接连接不上，安装依赖：\n\n```bash\nyum install libxml2-python  mod_ssl install krb5-devel cyrus-sasl-gssapi cyrus-sasl-deve libxml2-devel libxslt-devel mysql mysql-devel openldap-devel python-devel python-simplejson sqlite-devel -y\n```\n\n","slug":"CoudearManager搭建","published":1,"updated":"2018-08-10T19:05:49.436Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloj0lkw0008ykpb5avrv6t3"},{"title":"DataStream DataSet简介","date":"2018-09-04T12:03:16.710Z","toc":true,"_content":"\n[TOC]\n# 什么是DStream\nDiscretized Stream是Spark Streaming的基础抽象，代表持续性的数据流和经过各种Spark原语操作后的结果数据流。在内部实现上，DStream是一系列连续的RDD来表示。每个RDD含有一段时间间隔内的数据，如下图：\n![](http://pebgsxjpj.bkt.clouddn.com/15360627803806.jpg)\n\n对数据的操作也是按照RDD为单位来进行的\n![](http://pebgsxjpj.bkt.clouddn.com/15360627860827.jpg)\n\n\n计算过程由Spark engine来完成\n![](http://pebgsxjpj.bkt.clouddn.com/15360627909583.jpg)\n\n\nDatasets 与DataFrames 与RDDs的关系\n![](http://pebgsxjpj.bkt.clouddn.com/15360698161149.jpg)\n\nSpark引入DataFrame，它可以提供high-level functions让Spark更好的处理结构数据的计算。这让Catalyst optimizer 和Tungsten（钨丝） execution engine自动加速大数据分析。\n发布DataFrame之后开发者收到了很多反馈，其中一个主要的是大家反映缺乏编译时类型安全。为了解决这个问题，Spark采用新的Dataset API (DataFrame API的类型扩展)。\nDataset API扩展DataFrame API支持静态类型和运行已经存在的Scala或Java语言的用户自定义函数。对比传统的RDD API，Dataset API提供更好的内存管理，特别是在长任务中有更好的性能提升\n\n# DStream相关操作\n\nDStream上的原语与RDD的类似，分为Transformations（转换）和OutputOperations（输出）两种，此外转换操作中还有一些比较特殊的原语，如：updateStateByKey()、transform()以及各种Window相关的原语。\n\n## Transformations on DStreams\n\n| **Transformation**               | **Meaning**                              |\n| -------------------------------- | ---------------------------------------- |\n| map(func)                        | Return a new DStream by passing each  element of the source DStream through a function func. |\n| flatMap(func)                    | Similar to map, but each input item can  be mapped to 0 or more output items. |\n| filter(func)                     | Return a new DStream by selecting only  the records of the source DStream on which func returns true. |\n| repartition(numPartitions)       | Changes the level of parallelism in this  DStream by creating more or fewer partitions. |\n| union(otherStream)               | Return a new DStream that contains the  union of the elements in the source DStream and otherDStream. |\n| count()                          | Return a new DStream of single-element  RDDs by counting the number of elements in each RDD of the source DStream. |\n| reduce(func)                     | Return a new DStream of single-element  RDDs by aggregating the elements in each RDD of the source DStream using a  function func (which takes two arguments and returns one). The function  should be associative so that it can be computed in parallel. |\n| countByValue()                   | When called on a DStream of elements of  type K, return a new DStream of (K, Long) pairs where the value of each key  is its frequency in each RDD of the source DStream. |\n| reduceByKey(func, [numTasks])    | When called on a DStream of (K, V) pairs,  return a new DStream of (K, V) pairs where the values for each key are  aggregated using the given reduce function. Note: By default, this uses Spark's  default number of parallel tasks (2 for local mode, and in cluster mode the  number is determined by the config property spark.default.parallelism) to do  the grouping. You can pass an optional numTasks argument to set a different  number of tasks. |\n| join(otherStream, [numTasks])    | When called on two DStreams of (K, V) and  (K, W) pairs, return a new DStream of (K, (V, W)) pairs with all pairs of  elements for each key. |\n| cogroup(otherStream, [numTasks]) | When called on a DStream of (K, V) and  (K, W) pairs, return a new DStream of (K, Seq[V], Seq[W]) tuples. |\n| transform(func)                  | Return a new DStream by applying a  RDD-to-RDD function to every RDD of the source DStream. This can be used to  do arbitrary RDD operations on the DStream. |\n| updateStateByKey(func)           | Return a new \"state\" DStream  where the state for each key is updated by applying the given function on the  previous state of the key and the new values for the key. This can be used to  maintain arbitrary state data for each key. |\n\n \n\n### 特殊的Transformations\n\n** **\n\n1. UpdateStateByKeyOperation\n\nUpdateStateByKey原语用于记录历史记录，上文中Word Count示例中就用到了该特性。若不用UpdateStateByKey来更新状态，那么每次数据进来后分析完成后，结果输出后将不在保存\n\n2. TransformOperation\n\nTransform原语允许DStream上执行任意的RDD-to-RDD函数。通过该函数可以方便的扩展Spark API。此外，MLlib（机器学习）以及Graphx也是通过本函数来进行结合的。\n\n\n\n3. WindowOperations\n\nWindow Operations有点类似于Storm中的State，可以设置窗口的大小和滑动窗口的间隔来动态的获取当前Steaming的允许状态\n![](http://pebgsxjpj.bkt.clouddn.com/15360679610176.jpg)\n\n\n## Output Operations on DStreams\n\nOutput Operations可以将DStream的数据输出到外部的数据库或文件系统，当某个Output Operations原语被调用时（与RDD的Action相同），streaming程序才会开始真正的计算过程。\n\n| Output Operation                    | Meaning                                  |\n| ----------------------------------- | ---------------------------------------- |\n| print()                             | Prints the first ten elements of every  batch of data in a DStream on the driver node running the streaming  application. This is useful for development and debugging. |\n| saveAsTextFiles(prefix, [suffix])   | Save this DStream's contents as text  files. The file name at each batch interval is generated based on prefix and  suffix: \"prefix-TIME_IN_MS[.suffix]\". |\n| saveAsObjectFiles(prefix, [suffix]) | Save this DStream's contents as  SequenceFiles of serialized Java objects. The file name at each batch  interval is generated based on prefix and suffix:  \"prefix-TIME_IN_MS[.suffix]\". |\n| saveAsHadoopFiles(prefix, [suffix]) | Save this DStream's contents as Hadoop  files. The file name at each batch interval is generated based on prefix and  suffix: \"prefix-TIME_IN_MS[.suffix]\". |\n| foreachRDD(func)                    | The most generic output operator that  applies a function, func, to each RDD generated from the stream. This  function should push the data in each RDD to an external system, such as  saving the RDD to files, or writing it over the network to a database. Note  that the function func is executed in the driver process running the  streaming application, and will usually have RDD actions in it that will  force the computation of the streaming RDDs. \n\n##  用Spark Streaming实现实时WordCount\n\n架构图：\n\n![](http://pebgsxjpj.bkt.clouddn.com/15360681467801.jpg)\n\n\n1.安装并启动生成者\n\n首先在一台Linux（ip：192.168.10.101）上用YUM安装nc工具\n\nyum install -y nc\n\n \n\n启动一个服务端并监听9999端口\n\nnc -lk 9999\n\n \n\n2.编写Spark Streaming程序\n\n```scala\n\npackage me.yao.spark.streaming\nimport org.apache.spark.SparkConf\nimport org.apache.spark.streaming.{Seconds, StreamingContext}\nobject NetworkWordCount {\n    def main(args: Array[String]) {         //设置日志级别\n        LoggerLevel.setStreamingLogLevels()     //创建SparkConf并设置为本地模式运行     //注意local[2]代表开两个线程\n    val conf = new SparkConf().setMaster(\"local[2]\").setAppName(\"NetworkWordCount\")     //设置DStream批次时间间隔为2秒\n    val ssc = new StreamingContext(conf, Seconds(2))     //通过网络读取数据\n    val lines = ssc.socketTextStream(\"192.168.10.101\", 9999)     //将读到的数据用空格切成单词\n    val words = lines.flatMap(_.split(\" \"))     //将单词和1组成一个pair\n    val pairs = words.map(word => (word, 1))     //按单词进行分组求相同单词出现的次数\n    val wordCounts = pairs.reduceByKey(_ + _)     //打印结果到控制台\n    wordCounts.print()     //开始计算\n    ssc.start()     //等待停止\n    ssc.awaitTermination()\n        }\n    }\n```\n\n问题：结[果每次在]()Linux段输入的单词次数都被正确的统计出来，但是结果不能累加！如果需要累加需要使用updateStateByKey(func)来更新状态，下面给出一个例子：\n\n\n\n```scala\n  package me.yao.spark.streaming\n\n  import org.apache.spark.{HashPartitioner, SparkConf}\n  import org.apache.spark.streaming.{StreamingContext, Seconds}\n\n  object NetworkUpdateStateWordCount { \n  val updateFunc = (iter: Iterator[(String, Seq[Int], Option[Int])]) => {\n         ​    //iter.flatMap(it=>Some(it._2.sum + it._3.getOrElse(0)).map(x=>(it._1,x)))\n         ​    iter.flatMap{\n         ​    case(x,y,z)=>Some(y.sum + z.getOrElse(0)).map(m=>(x, m))}\n           }\n\n  def main(args: Array[String]) {\n​    LoggerLevel.setStreamingLogLevels*()\n​    val conf = new SparkConf().setMaster(\"local[2]\").setAppName(\"NetworkUpdateStateWordCount\")\n​    val ssc = new StreamingContext(conf, Seconds(5))\n​    //做checkpoint 写入共享存储中\n​    ssc.checkpoint(\"c://aaa\")\n​    **val **lines = ssc.socketTextStream(\"192.168.10.100\", 9999)\n​    //reduceByKey **结果不累加\n​    //val result = lines.flatMap(_.split(\" \")).map((_, 1)).reduceByKey(_+_)\n​    //updateStateByKey结果可以累加但是需要传入一个自定义的累加函数：updateFunc\n​   val results = lines.flatMap(_.split(\" \")).map((_,1)).updateStateByKey(updateFunc, new HashPartitioner(ssc.sparkContext.defaultParallelism), true)\n​    results.print()\n​    ssc.start()\n​    ssc.awaitTermination()\n  }\n}\n```\n\n\n# Dataset\n比RDD执行速度快很多倍，占用的内存更小，是从dataFrame发展而来，包含dataFrame \ndataFrame是处理结构化数据，有表头，有类型，\n\ndataSet从1.6.0开始出现，2.0做了重大改进，对dataFrame进行了整合 \ndataFrame在1.4系列出现的，现在很多公司都是用的RDD\n\n在spark的命令行里面： \n将dataFrame转成dataSet \nval ds = df.as[person] \n调用dataSet的方法 \nds.map \nds.show \nval ds = sqlContext.read.text(\"hdfs://bigdata1:9000/wc/).as[String] \nval res5 = ds.flatmap(.split(\" \")).map((,1)) \nflatmap将文本里面的每一行进行切分， \nrest.reduceByKey();会发现dataSet里面没有这个方法，在dataSet里面应该调用更高级的做法 \nds.flatmap(_.split(\" \")).groupBy($\"\"value).count.show 或者collect\n\n！在import里面打开idea查看类里面有哪些方法。 \n在spark1.6里面sqlContext.read....读取的就是dataFrame，和dataSet还未统一，需要将dataFrame用as转为dataSet\n\n\n\n","source":"_posts/DataStream简介.md","raw":"---\ntitle: DataStream DataSet简介\ndate: 2018年09月04日\ntags: [Spark]\ncategories: 大数据\ntoc: true\n---\n\n[TOC]\n# 什么是DStream\nDiscretized Stream是Spark Streaming的基础抽象，代表持续性的数据流和经过各种Spark原语操作后的结果数据流。在内部实现上，DStream是一系列连续的RDD来表示。每个RDD含有一段时间间隔内的数据，如下图：\n![](http://pebgsxjpj.bkt.clouddn.com/15360627803806.jpg)\n\n对数据的操作也是按照RDD为单位来进行的\n![](http://pebgsxjpj.bkt.clouddn.com/15360627860827.jpg)\n\n\n计算过程由Spark engine来完成\n![](http://pebgsxjpj.bkt.clouddn.com/15360627909583.jpg)\n\n\nDatasets 与DataFrames 与RDDs的关系\n![](http://pebgsxjpj.bkt.clouddn.com/15360698161149.jpg)\n\nSpark引入DataFrame，它可以提供high-level functions让Spark更好的处理结构数据的计算。这让Catalyst optimizer 和Tungsten（钨丝） execution engine自动加速大数据分析。\n发布DataFrame之后开发者收到了很多反馈，其中一个主要的是大家反映缺乏编译时类型安全。为了解决这个问题，Spark采用新的Dataset API (DataFrame API的类型扩展)。\nDataset API扩展DataFrame API支持静态类型和运行已经存在的Scala或Java语言的用户自定义函数。对比传统的RDD API，Dataset API提供更好的内存管理，特别是在长任务中有更好的性能提升\n\n# DStream相关操作\n\nDStream上的原语与RDD的类似，分为Transformations（转换）和OutputOperations（输出）两种，此外转换操作中还有一些比较特殊的原语，如：updateStateByKey()、transform()以及各种Window相关的原语。\n\n## Transformations on DStreams\n\n| **Transformation**               | **Meaning**                              |\n| -------------------------------- | ---------------------------------------- |\n| map(func)                        | Return a new DStream by passing each  element of the source DStream through a function func. |\n| flatMap(func)                    | Similar to map, but each input item can  be mapped to 0 or more output items. |\n| filter(func)                     | Return a new DStream by selecting only  the records of the source DStream on which func returns true. |\n| repartition(numPartitions)       | Changes the level of parallelism in this  DStream by creating more or fewer partitions. |\n| union(otherStream)               | Return a new DStream that contains the  union of the elements in the source DStream and otherDStream. |\n| count()                          | Return a new DStream of single-element  RDDs by counting the number of elements in each RDD of the source DStream. |\n| reduce(func)                     | Return a new DStream of single-element  RDDs by aggregating the elements in each RDD of the source DStream using a  function func (which takes two arguments and returns one). The function  should be associative so that it can be computed in parallel. |\n| countByValue()                   | When called on a DStream of elements of  type K, return a new DStream of (K, Long) pairs where the value of each key  is its frequency in each RDD of the source DStream. |\n| reduceByKey(func, [numTasks])    | When called on a DStream of (K, V) pairs,  return a new DStream of (K, V) pairs where the values for each key are  aggregated using the given reduce function. Note: By default, this uses Spark's  default number of parallel tasks (2 for local mode, and in cluster mode the  number is determined by the config property spark.default.parallelism) to do  the grouping. You can pass an optional numTasks argument to set a different  number of tasks. |\n| join(otherStream, [numTasks])    | When called on two DStreams of (K, V) and  (K, W) pairs, return a new DStream of (K, (V, W)) pairs with all pairs of  elements for each key. |\n| cogroup(otherStream, [numTasks]) | When called on a DStream of (K, V) and  (K, W) pairs, return a new DStream of (K, Seq[V], Seq[W]) tuples. |\n| transform(func)                  | Return a new DStream by applying a  RDD-to-RDD function to every RDD of the source DStream. This can be used to  do arbitrary RDD operations on the DStream. |\n| updateStateByKey(func)           | Return a new \"state\" DStream  where the state for each key is updated by applying the given function on the  previous state of the key and the new values for the key. This can be used to  maintain arbitrary state data for each key. |\n\n \n\n### 特殊的Transformations\n\n** **\n\n1. UpdateStateByKeyOperation\n\nUpdateStateByKey原语用于记录历史记录，上文中Word Count示例中就用到了该特性。若不用UpdateStateByKey来更新状态，那么每次数据进来后分析完成后，结果输出后将不在保存\n\n2. TransformOperation\n\nTransform原语允许DStream上执行任意的RDD-to-RDD函数。通过该函数可以方便的扩展Spark API。此外，MLlib（机器学习）以及Graphx也是通过本函数来进行结合的。\n\n\n\n3. WindowOperations\n\nWindow Operations有点类似于Storm中的State，可以设置窗口的大小和滑动窗口的间隔来动态的获取当前Steaming的允许状态\n![](http://pebgsxjpj.bkt.clouddn.com/15360679610176.jpg)\n\n\n## Output Operations on DStreams\n\nOutput Operations可以将DStream的数据输出到外部的数据库或文件系统，当某个Output Operations原语被调用时（与RDD的Action相同），streaming程序才会开始真正的计算过程。\n\n| Output Operation                    | Meaning                                  |\n| ----------------------------------- | ---------------------------------------- |\n| print()                             | Prints the first ten elements of every  batch of data in a DStream on the driver node running the streaming  application. This is useful for development and debugging. |\n| saveAsTextFiles(prefix, [suffix])   | Save this DStream's contents as text  files. The file name at each batch interval is generated based on prefix and  suffix: \"prefix-TIME_IN_MS[.suffix]\". |\n| saveAsObjectFiles(prefix, [suffix]) | Save this DStream's contents as  SequenceFiles of serialized Java objects. The file name at each batch  interval is generated based on prefix and suffix:  \"prefix-TIME_IN_MS[.suffix]\". |\n| saveAsHadoopFiles(prefix, [suffix]) | Save this DStream's contents as Hadoop  files. The file name at each batch interval is generated based on prefix and  suffix: \"prefix-TIME_IN_MS[.suffix]\". |\n| foreachRDD(func)                    | The most generic output operator that  applies a function, func, to each RDD generated from the stream. This  function should push the data in each RDD to an external system, such as  saving the RDD to files, or writing it over the network to a database. Note  that the function func is executed in the driver process running the  streaming application, and will usually have RDD actions in it that will  force the computation of the streaming RDDs. \n\n##  用Spark Streaming实现实时WordCount\n\n架构图：\n\n![](http://pebgsxjpj.bkt.clouddn.com/15360681467801.jpg)\n\n\n1.安装并启动生成者\n\n首先在一台Linux（ip：192.168.10.101）上用YUM安装nc工具\n\nyum install -y nc\n\n \n\n启动一个服务端并监听9999端口\n\nnc -lk 9999\n\n \n\n2.编写Spark Streaming程序\n\n```scala\n\npackage me.yao.spark.streaming\nimport org.apache.spark.SparkConf\nimport org.apache.spark.streaming.{Seconds, StreamingContext}\nobject NetworkWordCount {\n    def main(args: Array[String]) {         //设置日志级别\n        LoggerLevel.setStreamingLogLevels()     //创建SparkConf并设置为本地模式运行     //注意local[2]代表开两个线程\n    val conf = new SparkConf().setMaster(\"local[2]\").setAppName(\"NetworkWordCount\")     //设置DStream批次时间间隔为2秒\n    val ssc = new StreamingContext(conf, Seconds(2))     //通过网络读取数据\n    val lines = ssc.socketTextStream(\"192.168.10.101\", 9999)     //将读到的数据用空格切成单词\n    val words = lines.flatMap(_.split(\" \"))     //将单词和1组成一个pair\n    val pairs = words.map(word => (word, 1))     //按单词进行分组求相同单词出现的次数\n    val wordCounts = pairs.reduceByKey(_ + _)     //打印结果到控制台\n    wordCounts.print()     //开始计算\n    ssc.start()     //等待停止\n    ssc.awaitTermination()\n        }\n    }\n```\n\n问题：结[果每次在]()Linux段输入的单词次数都被正确的统计出来，但是结果不能累加！如果需要累加需要使用updateStateByKey(func)来更新状态，下面给出一个例子：\n\n\n\n```scala\n  package me.yao.spark.streaming\n\n  import org.apache.spark.{HashPartitioner, SparkConf}\n  import org.apache.spark.streaming.{StreamingContext, Seconds}\n\n  object NetworkUpdateStateWordCount { \n  val updateFunc = (iter: Iterator[(String, Seq[Int], Option[Int])]) => {\n         ​    //iter.flatMap(it=>Some(it._2.sum + it._3.getOrElse(0)).map(x=>(it._1,x)))\n         ​    iter.flatMap{\n         ​    case(x,y,z)=>Some(y.sum + z.getOrElse(0)).map(m=>(x, m))}\n           }\n\n  def main(args: Array[String]) {\n​    LoggerLevel.setStreamingLogLevels*()\n​    val conf = new SparkConf().setMaster(\"local[2]\").setAppName(\"NetworkUpdateStateWordCount\")\n​    val ssc = new StreamingContext(conf, Seconds(5))\n​    //做checkpoint 写入共享存储中\n​    ssc.checkpoint(\"c://aaa\")\n​    **val **lines = ssc.socketTextStream(\"192.168.10.100\", 9999)\n​    //reduceByKey **结果不累加\n​    //val result = lines.flatMap(_.split(\" \")).map((_, 1)).reduceByKey(_+_)\n​    //updateStateByKey结果可以累加但是需要传入一个自定义的累加函数：updateFunc\n​   val results = lines.flatMap(_.split(\" \")).map((_,1)).updateStateByKey(updateFunc, new HashPartitioner(ssc.sparkContext.defaultParallelism), true)\n​    results.print()\n​    ssc.start()\n​    ssc.awaitTermination()\n  }\n}\n```\n\n\n# Dataset\n比RDD执行速度快很多倍，占用的内存更小，是从dataFrame发展而来，包含dataFrame \ndataFrame是处理结构化数据，有表头，有类型，\n\ndataSet从1.6.0开始出现，2.0做了重大改进，对dataFrame进行了整合 \ndataFrame在1.4系列出现的，现在很多公司都是用的RDD\n\n在spark的命令行里面： \n将dataFrame转成dataSet \nval ds = df.as[person] \n调用dataSet的方法 \nds.map \nds.show \nval ds = sqlContext.read.text(\"hdfs://bigdata1:9000/wc/).as[String] \nval res5 = ds.flatmap(.split(\" \")).map((,1)) \nflatmap将文本里面的每一行进行切分， \nrest.reduceByKey();会发现dataSet里面没有这个方法，在dataSet里面应该调用更高级的做法 \nds.flatmap(_.split(\" \")).groupBy($\"\"value).count.show 或者collect\n\n！在import里面打开idea查看类里面有哪些方法。 \n在spark1.6里面sqlContext.read....读取的就是dataFrame，和dataSet还未统一，需要将dataFrame用as转为dataSet\n\n\n\n","slug":"DataStream简介","published":1,"updated":"2018-09-04T14:31:52.060Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloj0lky0009ykpbhomts40h"},{"title":"Docker-machine的创建，mac宿主机和docker容器网络互通Docker容器与宿主机在同一ip段下","date":"2018-07-19T19:02:08.124Z","toc":true,"_content":"\n\n\n\n此文纯属命令记录，后续更新原理解说\n\n # 更改virtual0的ip\n VBoxManage hostonlyif ipconfig vboxnet0 --ip 192.168.33.253 --netmask 255.255.255.0\n\n<!-- more -->\n\n# ifconfig 查看\n创建虚拟机配置文件  Vagrantfile\n\n也可以vagrant init  会生成一个空白的Vagrantfile\n# vi Vagrantfile\n\n```SHELL\n\tVagrant.configure(2) do |config|\n\t\t config.vm.box = \"dolbager/centos-7-docker\"\n\t\t config.vm.hostname = \"default\"\n\t\t  config.vm.network \"private_network\", ip: \"192.168.33.1\",netmask: \"255.255.255.0\"\n\t\t config.vm.provider \"virtualbox\" do |v|\n\t\t   v.name = \"default\"\n\t\t   v.memory = \"2048\"\n\t\t   # Change the network adapter type and promiscuous mode\n\t\t   v.customize ['modifyvm', :id, '--nictype1', 'Am79C973']\n\t\t   v.customize ['modifyvm', :id, '--nicpromisc1', 'allow-all']\n\t\t   v.customize ['modifyvm', :id, '--nictype2', 'Am79C973']\n\t\t   v.customize ['modifyvm', :id, '--nicpromisc2', 'allow-all']\n\t\t end\n\t\t # Install bridge-utils\n\t\t config.vm.provision \"shell\", inline: <<-SHELL\n\t\t    curl -o /etc/yum.repos.d/CentOS-Base.repohttp://mirrors.aliyun.com/repo/Centos-7.repo\n\t\t    curl -o /etc/yum.repos.d/epel.repohttp://mirrors.aliyun.com/repo/epel-7.repo\n\t\t   yum clean all\n\t\t   yum makecache\n\t\t   yum update -y\n\t\t   yum install bridge-utils net-tools -y\n\t\t SHELL\n\tend\n\n```\nvagrant up\nvagrant ssh\n\nvagrant ssh-config\n\n```bash\nscp ~/.vagrant.d/boxes/dolbager-VAGRANTSLASH-centos-7-docker/0.2/virtualbox/vagrant_private_key .vagrant/machines/default/virtualbox/private_key\n\n```\n\n`vagrant exit`\n\n\n\n\n\n\n```bash\ndocker-machine create \\\n --driver \"generic\" \\\n --generic-ip-address 192.168.33.1 \\\n --generic-ssh-user vagrant \\\n --generic-ssh-key .vagrant/machines/default/virtualbox/private_key \\\n --generic-ssh-port 22 \\\n default\n```\n\n创建网桥docker1 和 docker network br\n通过vagrant 从虚拟机的 eth0 登录到虚拟机\n\nvagrant ssh\nip -4 addr\n\n创建 docker network br\n\n\n```bash\nsudo docker network create \\\n    --driver bridge \\\n    --subnet=192.168.33.0/24 \\\n    --gateway=192.168.33.1 \\\n    --opt \"com.docker.network.bridge.enable_icc\"=\"true\" \\\n    --opt \"com.docker.network.bridge.enable_ip_masquerade\"=\"true\" \\\n    --opt \"com.docker.network.bridge.name\"=\"docker1\" \\\n    --opt \"com.docker.network.driver.mtu\"=\"1500\" \\\n    br\n\n```\n\n\n创建网桥配置文件docker1\n\n`vim /etc/sysconfig/network-scripts/ifcfg-docker1`\n\n```bash\nDEVICE=docker1\nTYPE=Bridge\nBOOTPROTO=static\nONBOOT=yes\nSTP=on\nIPADDR=\nNETMASK=\nGATEWAY=\nDNS1=\n```\n\n\n## 修改网卡配置 eth1 :\n\n`sudo vi /etc/sysconfig/network-scripts/ifcfg-eth1`\n\n```bash\nDEVICE=eth1\nBOOTPROTO=static\nHWADDR=\nONBOOT=yes\nNETMASK=\nGATEWAY=\nBRIDGE=docker1\nTYPE=Ethernet\n```\n\n\n初始化docker-machine变量\n\n提示报错Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running? \n\n```bash\n eval $(docker-machine env default) \n```\n\n\n\n参考：[docker-install-mac-vm-centos](https://github.com/SixQuant/engineering-excellence/blob/master/docker/docker-install-mac-vm-centos.md)","source":"_posts/Docker-machine的搭建(与宿主机在同一ip段下).md","raw":"---\ntitle:  Docker-machine的创建，mac宿主机和docker容器网络互通Docker容器与宿主机在同一ip段下\ndate: 2018年07月20日 03时02分26秒\ntags:  [Docker,Docker-machine,安装部署]\ncategories: Docker\ntoc: true\n---\n\n\n\n\n此文纯属命令记录，后续更新原理解说\n\n # 更改virtual0的ip\n VBoxManage hostonlyif ipconfig vboxnet0 --ip 192.168.33.253 --netmask 255.255.255.0\n\n<!-- more -->\n\n# ifconfig 查看\n创建虚拟机配置文件  Vagrantfile\n\n也可以vagrant init  会生成一个空白的Vagrantfile\n# vi Vagrantfile\n\n```SHELL\n\tVagrant.configure(2) do |config|\n\t\t config.vm.box = \"dolbager/centos-7-docker\"\n\t\t config.vm.hostname = \"default\"\n\t\t  config.vm.network \"private_network\", ip: \"192.168.33.1\",netmask: \"255.255.255.0\"\n\t\t config.vm.provider \"virtualbox\" do |v|\n\t\t   v.name = \"default\"\n\t\t   v.memory = \"2048\"\n\t\t   # Change the network adapter type and promiscuous mode\n\t\t   v.customize ['modifyvm', :id, '--nictype1', 'Am79C973']\n\t\t   v.customize ['modifyvm', :id, '--nicpromisc1', 'allow-all']\n\t\t   v.customize ['modifyvm', :id, '--nictype2', 'Am79C973']\n\t\t   v.customize ['modifyvm', :id, '--nicpromisc2', 'allow-all']\n\t\t end\n\t\t # Install bridge-utils\n\t\t config.vm.provision \"shell\", inline: <<-SHELL\n\t\t    curl -o /etc/yum.repos.d/CentOS-Base.repohttp://mirrors.aliyun.com/repo/Centos-7.repo\n\t\t    curl -o /etc/yum.repos.d/epel.repohttp://mirrors.aliyun.com/repo/epel-7.repo\n\t\t   yum clean all\n\t\t   yum makecache\n\t\t   yum update -y\n\t\t   yum install bridge-utils net-tools -y\n\t\t SHELL\n\tend\n\n```\nvagrant up\nvagrant ssh\n\nvagrant ssh-config\n\n```bash\nscp ~/.vagrant.d/boxes/dolbager-VAGRANTSLASH-centos-7-docker/0.2/virtualbox/vagrant_private_key .vagrant/machines/default/virtualbox/private_key\n\n```\n\n`vagrant exit`\n\n\n\n\n\n\n```bash\ndocker-machine create \\\n --driver \"generic\" \\\n --generic-ip-address 192.168.33.1 \\\n --generic-ssh-user vagrant \\\n --generic-ssh-key .vagrant/machines/default/virtualbox/private_key \\\n --generic-ssh-port 22 \\\n default\n```\n\n创建网桥docker1 和 docker network br\n通过vagrant 从虚拟机的 eth0 登录到虚拟机\n\nvagrant ssh\nip -4 addr\n\n创建 docker network br\n\n\n```bash\nsudo docker network create \\\n    --driver bridge \\\n    --subnet=192.168.33.0/24 \\\n    --gateway=192.168.33.1 \\\n    --opt \"com.docker.network.bridge.enable_icc\"=\"true\" \\\n    --opt \"com.docker.network.bridge.enable_ip_masquerade\"=\"true\" \\\n    --opt \"com.docker.network.bridge.name\"=\"docker1\" \\\n    --opt \"com.docker.network.driver.mtu\"=\"1500\" \\\n    br\n\n```\n\n\n创建网桥配置文件docker1\n\n`vim /etc/sysconfig/network-scripts/ifcfg-docker1`\n\n```bash\nDEVICE=docker1\nTYPE=Bridge\nBOOTPROTO=static\nONBOOT=yes\nSTP=on\nIPADDR=\nNETMASK=\nGATEWAY=\nDNS1=\n```\n\n\n## 修改网卡配置 eth1 :\n\n`sudo vi /etc/sysconfig/network-scripts/ifcfg-eth1`\n\n```bash\nDEVICE=eth1\nBOOTPROTO=static\nHWADDR=\nONBOOT=yes\nNETMASK=\nGATEWAY=\nBRIDGE=docker1\nTYPE=Ethernet\n```\n\n\n初始化docker-machine变量\n\n提示报错Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running? \n\n```bash\n eval $(docker-machine env default) \n```\n\n\n\n参考：[docker-install-mac-vm-centos](https://github.com/SixQuant/engineering-excellence/blob/master/docker/docker-install-mac-vm-centos.md)","slug":"Docker-machine的搭建(与宿主机在同一ip段下)","published":1,"updated":"2018-08-24T02:01:15.797Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloj0lkz000aykpbb3ixkpn4"},{"title":"Docker常用命令汇集","date":"2018-06-26T02:33:37.714Z","toc":true,"_content":"\n![](https://ws2.sinaimg.cn/large/006tNbRwgy1fu55c5h3g1j319i0eu0tg.jpg)\n\n[TOC]\n\n\n\n# Docker源配置\n\n  安装过程中需要重国外 docker 仓库下载文件，速度太慢，建议配置 docker 国内镜像仓库：\n  vi /etc/docker/daemon.json\n  {\"registry-mirrors\":[\"http://c1f0a193.m.daocloud.io\"] }\n\n启动容器\n\n\tdocker run -itd  --net=br  --name slave02 --hostname slave02 centos:hadoop-spark &> /dev/null\n\t如果以 /bin/bash启动的话，sshd服务不会启动(docker未知bug)\n## 创建容器\n\n\t--name    --hostname (同-h)  --net=    -d表示后台启动\n\t此命令不会打印出容器id\n\tdocker run -itd  --net=br  --name hm --hostname hadoop-master kiwenlau/hadoop:1.0 &> /dev/null   （hadoop镜像）\n\t设置静态固定ip\n\tdocker run -d --net=br --name=c6 --ip=192.168.33.6 nginx\n\n\n    自动分配Ip\n    docker run -d --net=br --name=c1 nginx\n    \n    设置docker默认ip段命令\n    docker run -itd   -P -p 50070:50070 -p 8088:8088 -p 8080:8080 --name master -h master --add-host slave01:172.17.0.3 --add-host slave02:172.17.0.4 centos:ssh-spark-hadoop\n\n## 容器挂载目录\n\ncompose文件：\n```Bash\nvolumes:\n\t- /Users/yaosong/Yao/dev/hadoop/dfs/name:/root/hadoop/dfs/name\n```\n\nshell命令：\n\n```bash\n-v : \ndocker run -it -v /test:/soft centos /bin/bash\n```\n\n\":\"前目录为宿主机目录，后目录为容器目录\n\n\n\n> 在virtualbox中设置共享文件夹的share名称对应mac的目录\n> 虚拟机中的目录\n> sudo mount -t vboxsf share  /Users/yaosong/Yao/share/\n> sudo mount -t vboxsf vagrant /Users/yaosong\n\n## 删除所有未用的 Data volumes\n\n```\ndocker volume prune\n```\n\n\n\n## run 命令解释\n\n```Bash\n-d 是后台启动\ndocker run -itd  --net=br  --name spark --hostname spark yaosong5/spark:2.1.0 &> /dev/null\nsudo docker exec -it spark bash（进入后台启动的容器）\n和下面一样（直接进入）\ndocker run -it --net=br  --name spark --hostname spark yaosong5/spark:2.1.0 bash\n```\n\n## exec 进入后台容器\n```Bash\ndocker exec -it spark bash\ndocker exec -it 容器名 bash\n执行命令 docker exec -it 容器名 ip addr 可以拿到 a0 容器的 ip\n```\n\n## logs查看容器启动日志\n\n```Bash\ndocker logs -f -t --tail 100  kanbigdata_namenode_1\n```\n\n\n\n\n\n## 查看容器信息\n\n```shell\ndocker inspect hm\n执行命令 docker exec -it 容器名 ip addr 可以拿到 a0 容器的 ip\n```\n\n\n\n## 启动 关闭 删除容器\n\n```shell\ndocker start \ndocker stop 容器名\ndocker rm 容器名\n```\n\n## cp容器宿主互拷文件\n\n```shell\ndocker cp /Users/yaosong/Yao/etc.tar  f7e795c0fddd:/\n后为容器id:/目录\n```\n\n## 删除镜像\n\n```shell\n（根据镜像id删除）\ndocker rmi 00de07ebadff\n用docker images -a 查看image id，\n也可docker rmi 镜像名:版本号\n```\n\n\n## 保存镜像\n```shell\ndocker commit -m \"centos-6.9 with spark 2.2.0 and hadoop 2.8.0\"  os   centos:hadoop-spark\n\ndocker commit -m \"bigdata:spark,hadoop,hive,mysql and shell  foundation\"   --author=\"yaosong\"  master   yao/os/bigdata:2.1\n```\n\n\n## Docker用DockerFile创建镜像\n\n```shell\ndocker build -t hadoop:v1- <Dockerfile\ndocker build -t=\"hadoop:v1\" .  （.表示是当前文件夹，也就是dockerfile所在文件夹）\ndocker build -f Dockerfile -t hadoop:v1 . 此命令也可\n```\n\n## 一键启动docker-compose.yml编排的所有服务\n\n```shell\ndocker-compose -f docker-compose.yml up d\n```\n\n## Docker改变标签\n\ndocker tag IMAGEID(镜像id) REPOSITORY:TAG（仓库：标签）\n\n`docker tag  b7a66cb0e8ba yaosong5/bigdata:1.0`\n\n## 搜索docker镜像\n\n```shell\ndocker search yaosong5\n```\n\n\n\n## 登录docker账户\n\n`docker login` 登录docker hub中注册的账户\n\n\n\n\n## 上传仓库\n\n`docker push yaosong5/elk:1.0`\n\n## 容器保存为镜像，加载本地镜像 引用\n\n```shell\ndocker save imageID > filename\ndocker load <filename\n如：\ndocker save 4f9e92e56941>  /Users/yaosong/centosSparkHadoop.tar\ndocker load </Users/yaosong/centosSparkHadoop.tar\n\n通过 image 保存的镜像会保存操作历史，可以回滚到历史版本。\n```\n\n## 保存，加载容器命令：\n```powershell\ndocker export containID > filename\ndocker import filename [newname]\n```\n通过容器保存的镜像不会保存操作历史，所以文件小一点。\n如果要运行通过容器加载的镜像， 需要在运行的时候加上相关命令。\n\n#  Docker-machine命令\n## 列出docker-machine\n\n```shell\ndocker-machine ls\n```\n\n## 开启虚拟机\n\n```shell\ndocker-machine start default\n```\n\n## 关闭虚拟机\n\n```shell\ndocker-machine stop default\n```\n\n## 重启虚拟机\n\n```bash\ndocker-machine restart default\n```\n\n## 删除虚拟机\n\n```bash\ndocker-machine rm default\n```\n\n## 设置环境变量docker-machine\n\n```bash\neval $(docker-machine env default) # Setup the environment\n```\n\n\n\n","source":"_posts/Docker命令汇集.md","raw":"---\ntitle:  Docker常用命令汇集\ndate: 2018年08月06日 22时15分52秒\ntags:  [Docker]\ncategories: Docker\ntoc: true\n\n---\n\n![](https://ws2.sinaimg.cn/large/006tNbRwgy1fu55c5h3g1j319i0eu0tg.jpg)\n\n[TOC]\n\n\n\n# Docker源配置\n\n  安装过程中需要重国外 docker 仓库下载文件，速度太慢，建议配置 docker 国内镜像仓库：\n  vi /etc/docker/daemon.json\n  {\"registry-mirrors\":[\"http://c1f0a193.m.daocloud.io\"] }\n\n启动容器\n\n\tdocker run -itd  --net=br  --name slave02 --hostname slave02 centos:hadoop-spark &> /dev/null\n\t如果以 /bin/bash启动的话，sshd服务不会启动(docker未知bug)\n## 创建容器\n\n\t--name    --hostname (同-h)  --net=    -d表示后台启动\n\t此命令不会打印出容器id\n\tdocker run -itd  --net=br  --name hm --hostname hadoop-master kiwenlau/hadoop:1.0 &> /dev/null   （hadoop镜像）\n\t设置静态固定ip\n\tdocker run -d --net=br --name=c6 --ip=192.168.33.6 nginx\n\n\n    自动分配Ip\n    docker run -d --net=br --name=c1 nginx\n    \n    设置docker默认ip段命令\n    docker run -itd   -P -p 50070:50070 -p 8088:8088 -p 8080:8080 --name master -h master --add-host slave01:172.17.0.3 --add-host slave02:172.17.0.4 centos:ssh-spark-hadoop\n\n## 容器挂载目录\n\ncompose文件：\n```Bash\nvolumes:\n\t- /Users/yaosong/Yao/dev/hadoop/dfs/name:/root/hadoop/dfs/name\n```\n\nshell命令：\n\n```bash\n-v : \ndocker run -it -v /test:/soft centos /bin/bash\n```\n\n\":\"前目录为宿主机目录，后目录为容器目录\n\n\n\n> 在virtualbox中设置共享文件夹的share名称对应mac的目录\n> 虚拟机中的目录\n> sudo mount -t vboxsf share  /Users/yaosong/Yao/share/\n> sudo mount -t vboxsf vagrant /Users/yaosong\n\n## 删除所有未用的 Data volumes\n\n```\ndocker volume prune\n```\n\n\n\n## run 命令解释\n\n```Bash\n-d 是后台启动\ndocker run -itd  --net=br  --name spark --hostname spark yaosong5/spark:2.1.0 &> /dev/null\nsudo docker exec -it spark bash（进入后台启动的容器）\n和下面一样（直接进入）\ndocker run -it --net=br  --name spark --hostname spark yaosong5/spark:2.1.0 bash\n```\n\n## exec 进入后台容器\n```Bash\ndocker exec -it spark bash\ndocker exec -it 容器名 bash\n执行命令 docker exec -it 容器名 ip addr 可以拿到 a0 容器的 ip\n```\n\n## logs查看容器启动日志\n\n```Bash\ndocker logs -f -t --tail 100  kanbigdata_namenode_1\n```\n\n\n\n\n\n## 查看容器信息\n\n```shell\ndocker inspect hm\n执行命令 docker exec -it 容器名 ip addr 可以拿到 a0 容器的 ip\n```\n\n\n\n## 启动 关闭 删除容器\n\n```shell\ndocker start \ndocker stop 容器名\ndocker rm 容器名\n```\n\n## cp容器宿主互拷文件\n\n```shell\ndocker cp /Users/yaosong/Yao/etc.tar  f7e795c0fddd:/\n后为容器id:/目录\n```\n\n## 删除镜像\n\n```shell\n（根据镜像id删除）\ndocker rmi 00de07ebadff\n用docker images -a 查看image id，\n也可docker rmi 镜像名:版本号\n```\n\n\n## 保存镜像\n```shell\ndocker commit -m \"centos-6.9 with spark 2.2.0 and hadoop 2.8.0\"  os   centos:hadoop-spark\n\ndocker commit -m \"bigdata:spark,hadoop,hive,mysql and shell  foundation\"   --author=\"yaosong\"  master   yao/os/bigdata:2.1\n```\n\n\n## Docker用DockerFile创建镜像\n\n```shell\ndocker build -t hadoop:v1- <Dockerfile\ndocker build -t=\"hadoop:v1\" .  （.表示是当前文件夹，也就是dockerfile所在文件夹）\ndocker build -f Dockerfile -t hadoop:v1 . 此命令也可\n```\n\n## 一键启动docker-compose.yml编排的所有服务\n\n```shell\ndocker-compose -f docker-compose.yml up d\n```\n\n## Docker改变标签\n\ndocker tag IMAGEID(镜像id) REPOSITORY:TAG（仓库：标签）\n\n`docker tag  b7a66cb0e8ba yaosong5/bigdata:1.0`\n\n## 搜索docker镜像\n\n```shell\ndocker search yaosong5\n```\n\n\n\n## 登录docker账户\n\n`docker login` 登录docker hub中注册的账户\n\n\n\n\n## 上传仓库\n\n`docker push yaosong5/elk:1.0`\n\n## 容器保存为镜像，加载本地镜像 引用\n\n```shell\ndocker save imageID > filename\ndocker load <filename\n如：\ndocker save 4f9e92e56941>  /Users/yaosong/centosSparkHadoop.tar\ndocker load </Users/yaosong/centosSparkHadoop.tar\n\n通过 image 保存的镜像会保存操作历史，可以回滚到历史版本。\n```\n\n## 保存，加载容器命令：\n```powershell\ndocker export containID > filename\ndocker import filename [newname]\n```\n通过容器保存的镜像不会保存操作历史，所以文件小一点。\n如果要运行通过容器加载的镜像， 需要在运行的时候加上相关命令。\n\n#  Docker-machine命令\n## 列出docker-machine\n\n```shell\ndocker-machine ls\n```\n\n## 开启虚拟机\n\n```shell\ndocker-machine start default\n```\n\n## 关闭虚拟机\n\n```shell\ndocker-machine stop default\n```\n\n## 重启虚拟机\n\n```bash\ndocker-machine restart default\n```\n\n## 删除虚拟机\n\n```bash\ndocker-machine rm default\n```\n\n## 设置环境变量docker-machine\n\n```bash\neval $(docker-machine env default) # Setup the environment\n```\n\n\n\n","slug":"Docker命令汇集","published":1,"updated":"2018-08-24T02:13:02.239Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloj0ll2000dykpbb2gr2qdq"},{"title":"Docker安装Hadoop集群【引用】","date":"2018-06-03T06:36:21.404Z","toc":true,"_content":" Docker配置Hadoop集群环境\n 在网上找到一个网友自制的镜像，拉取配置都是参考的，记录一下。\n<!--more-->\n# 拉取镜像\n>sudo docker pull kiwenlau/hadoop-master:0.1.0\n>sudo docker pull kiwenlau/hadoop-slave:0.1.0\n>sudo docker pull kiwenlau/hadoop-base:0.1.0\n>sudo docker pull kiwenlau/serf-dnsmasq:0.1.0\n\n\n## 查看下载的镜像\n![下载的镜像](https://www.github.com/yaosong5/tuchuang/raw/master/mdtc/2018/6/3/1528038081307.jpg)\n\n\n\n\n> sudo docker images\n\n# 在github中拉取源代码\n(或者在oschina中拉取)\ngit clone https://github.com/kiwenlau/hadoop-cluster-docker\n开源中国\ngit clone http://git.oschina.net/kiwenlau/hadoop-cluster-docker\n\n\n# 运行容器\n拉取镜像后，打开源代码文件夹，并且运行脚本\n>cd hadoop-cluster-docker\n\n\n![源包下文件](https://www.github.com/yaosong5/tuchuang/raw/master/mdtc/2018/6/3/1528038513960.jpg)\n\n注意：运行脚本时,需要先启动docker服务\n>./start-container.sh\n>![enter description here](https://www.github.com/yaosong5/tuchuang/raw/master/mdtc/2018/6/3/1528039457334.jpg)\n\n一共开启了 3 个容器，1 个 master, 2 个 slave。开启容器后就进入了 master 容器 root 用户的根目录（/root）\n\n## 查看root目录下文件\n![enter description here](https://www.github.com/yaosong5/tuchuang/raw/master/mdtc/2018/6/3/1528039642562.jpg)\n\n## 测试容器是否正常运行\n```serf members```\n<!-- more -->\n\n--------\n参考：[基于 Docker 快速搭建多节点 Hadoop 集群](http://dockone.io/article/395)","source":"_posts/Docker安装Hadoop集群【引用】.md","raw":"---\ntitle:  Docker安装Hadoop集群【引用】\ndate: 2018年06月03日 14时36分28秒\ntags:  [Docker,Hadoop]\ncategories: 环境配置\ntoc: true\n---\n Docker配置Hadoop集群环境\n 在网上找到一个网友自制的镜像，拉取配置都是参考的，记录一下。\n<!--more-->\n# 拉取镜像\n>sudo docker pull kiwenlau/hadoop-master:0.1.0\n>sudo docker pull kiwenlau/hadoop-slave:0.1.0\n>sudo docker pull kiwenlau/hadoop-base:0.1.0\n>sudo docker pull kiwenlau/serf-dnsmasq:0.1.0\n\n\n## 查看下载的镜像\n![下载的镜像](https://www.github.com/yaosong5/tuchuang/raw/master/mdtc/2018/6/3/1528038081307.jpg)\n\n\n\n\n> sudo docker images\n\n# 在github中拉取源代码\n(或者在oschina中拉取)\ngit clone https://github.com/kiwenlau/hadoop-cluster-docker\n开源中国\ngit clone http://git.oschina.net/kiwenlau/hadoop-cluster-docker\n\n\n# 运行容器\n拉取镜像后，打开源代码文件夹，并且运行脚本\n>cd hadoop-cluster-docker\n\n\n![源包下文件](https://www.github.com/yaosong5/tuchuang/raw/master/mdtc/2018/6/3/1528038513960.jpg)\n\n注意：运行脚本时,需要先启动docker服务\n>./start-container.sh\n>![enter description here](https://www.github.com/yaosong5/tuchuang/raw/master/mdtc/2018/6/3/1528039457334.jpg)\n\n一共开启了 3 个容器，1 个 master, 2 个 slave。开启容器后就进入了 master 容器 root 用户的根目录（/root）\n\n## 查看root目录下文件\n![enter description here](https://www.github.com/yaosong5/tuchuang/raw/master/mdtc/2018/6/3/1528039642562.jpg)\n\n## 测试容器是否正常运行\n```serf members```\n<!-- more -->\n\n--------\n参考：[基于 Docker 快速搭建多节点 Hadoop 集群](http://dockone.io/article/395)","slug":"Docker安装Hadoop集群【引用】","published":1,"updated":"2018-08-06T19:27:34.504Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloj0ll3000eykpbd6sckh8u"},{"title":"Docker构建免密ssh免密镜像","date":"2018-07-19T18:49:08.996Z","toc":true,"_content":"\n##  免密登录\n参考的是http://www.shushilvshe.com/data/docker-ssh.html\n文中涉及命令\n```\nsudo yum -y install openssh-server openssh-clients\nssh-keygen -t rsa\ncp /root/.ssh/id_rsa.pub /root/.ssh/authorized_keys\nchmod 700 ~/.ssh\nchmod 600 ~/.ssh/authorized_keys\n```\n\n<!--more-->\n**vim /etc/ssh/sshd_config**\n　　找到以下内容，并去掉注释符”#“\n\n```\nRSAAuthentication yes\nPubkeyAuthentication yes\nAuthorizedKeysFile      .ssh/authorized_keys\n```\n\n**vim /etc/ssh/ssh_config**\n\n```\nHost *\n\tStrictHostKeyChecking no\n\tUserKnownHostsFile=/dev/null\n```\n\n​\t\t此文也可参考 http://www.voidcn.com/article/p-gxkeusey-ma.html\n\n\n\n> https://blog.csdn.net/a85820069/article/details/78745899\n> 坑\n> 使用 docker run -i -t –name c1 centos6.6:basic /bin/bash 运行容器，sshd 服务是不开启的，必须先 - d 在用 exec 切入。\n\n\nhttps://www.cnblogs.com/aiweixiao/p/5516974.html\n\n\n1.【查看是否启动】\n\n　　启动 SSH 服务 “/etc/init.d/sshd start”。然后用 netstat -antulp | grep ssh 看是否能看到相关信息就可以了。\n\n2.【设置自动启动】\n\n　　如何设置把 ssh 等一些服务随系统开机自动启动？\n\n\t\t方法一：[root@localhost ~]# vi /etc/rc.local\n加入：service sshd start 或  /etc/init.d/sshd start\n\n\n\n**chmod 777 /etc/ssh/ssh_host_ecdsa_key**\n\n```\n# 免密登录\n\nmkdir -p /root/.ssh  \ntouch /root/.ssh/config  \necho \"StrictHostKeyChecking no\" > /root/.ssh/config  \nsed -i \"a UserKnownHostsFile /dev/null\" /root/.ssh/config \n\n# 开机启动\n\nRUN yum install -y openssh-server sudo  \nRUN sed -i 's/UsePAM yes/UsePAM no/g' /etc/ssh/sshd_config  \n\n# 下面这两句比较特殊，在centos6上必须要有，否则创建出来的容器sshd不能登录\n\nRUN ssh-keygen -t dsa -f /etc/ssh/ssh_host_dsa_key  \nRUN ssh-keygen -t rsa -f /etc/ssh/ssh_host_rsa_key \n```\n\n\n\n## ssh服务文章当中的\n```bash\ncurl http://mirrors.aliyun.com/repo/Centos-6.repo > /etc/yum.repos.d/CentOS-Base-6-aliyun.repo\nmv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.bak\nyum makecache\nyum install -y net-tools which openssh-clients openssh-server iproute.x86_64 wget\n\nservice sshd start\n\nsed -i 's/UsePAM yes/UsePAM no/g' /etc/ssh/sshd_config\nsed -ri 's/session required pam_loginuid.so/#session required pam_loginuid.so/g' /etc/pam.d/sshd\n\nchkconfig sshd on\n\ncd ~;ssh-keygen -t rsa -P '' -f ~/.ssh/id_dsa;cd .ssh;cat id_dsa.pub >> authorized_keys\n```\n","source":"_posts/Docker构建免密登录.md","raw":"---\ntitle:  Docker构建免密ssh免密镜像\ndate: 2018年06月21日 22时15分52秒\ntags:  [Docker]\ncategories: Docker\ntoc: true\n---\n\n##  免密登录\n参考的是http://www.shushilvshe.com/data/docker-ssh.html\n文中涉及命令\n```\nsudo yum -y install openssh-server openssh-clients\nssh-keygen -t rsa\ncp /root/.ssh/id_rsa.pub /root/.ssh/authorized_keys\nchmod 700 ~/.ssh\nchmod 600 ~/.ssh/authorized_keys\n```\n\n<!--more-->\n**vim /etc/ssh/sshd_config**\n　　找到以下内容，并去掉注释符”#“\n\n```\nRSAAuthentication yes\nPubkeyAuthentication yes\nAuthorizedKeysFile      .ssh/authorized_keys\n```\n\n**vim /etc/ssh/ssh_config**\n\n```\nHost *\n\tStrictHostKeyChecking no\n\tUserKnownHostsFile=/dev/null\n```\n\n​\t\t此文也可参考 http://www.voidcn.com/article/p-gxkeusey-ma.html\n\n\n\n> https://blog.csdn.net/a85820069/article/details/78745899\n> 坑\n> 使用 docker run -i -t –name c1 centos6.6:basic /bin/bash 运行容器，sshd 服务是不开启的，必须先 - d 在用 exec 切入。\n\n\nhttps://www.cnblogs.com/aiweixiao/p/5516974.html\n\n\n1.【查看是否启动】\n\n　　启动 SSH 服务 “/etc/init.d/sshd start”。然后用 netstat -antulp | grep ssh 看是否能看到相关信息就可以了。\n\n2.【设置自动启动】\n\n　　如何设置把 ssh 等一些服务随系统开机自动启动？\n\n\t\t方法一：[root@localhost ~]# vi /etc/rc.local\n加入：service sshd start 或  /etc/init.d/sshd start\n\n\n\n**chmod 777 /etc/ssh/ssh_host_ecdsa_key**\n\n```\n# 免密登录\n\nmkdir -p /root/.ssh  \ntouch /root/.ssh/config  \necho \"StrictHostKeyChecking no\" > /root/.ssh/config  \nsed -i \"a UserKnownHostsFile /dev/null\" /root/.ssh/config \n\n# 开机启动\n\nRUN yum install -y openssh-server sudo  \nRUN sed -i 's/UsePAM yes/UsePAM no/g' /etc/ssh/sshd_config  \n\n# 下面这两句比较特殊，在centos6上必须要有，否则创建出来的容器sshd不能登录\n\nRUN ssh-keygen -t dsa -f /etc/ssh/ssh_host_dsa_key  \nRUN ssh-keygen -t rsa -f /etc/ssh/ssh_host_rsa_key \n```\n\n\n\n## ssh服务文章当中的\n```bash\ncurl http://mirrors.aliyun.com/repo/Centos-6.repo > /etc/yum.repos.d/CentOS-Base-6-aliyun.repo\nmv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.bak\nyum makecache\nyum install -y net-tools which openssh-clients openssh-server iproute.x86_64 wget\n\nservice sshd start\n\nsed -i 's/UsePAM yes/UsePAM no/g' /etc/ssh/sshd_config\nsed -ri 's/session required pam_loginuid.so/#session required pam_loginuid.so/g' /etc/pam.d/sshd\n\nchkconfig sshd on\n\ncd ~;ssh-keygen -t rsa -P '' -f ~/.ssh/id_dsa;cd .ssh;cat id_dsa.pub >> authorized_keys\n```\n","slug":"Docker构建免密登录","published":1,"updated":"2018-08-10T19:24:44.124Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloj0ll5000jykpbpv7o6771"},{"utitle":"HBase原理性能分析","date":"2018-08-15T07:24:37.471Z","toc":true,"_content":"\n[TOC]\n\n\n\n![](https://ws3.sinaimg.cn/large/0069RVTdgy1fuap8gxtquj31ca0ncdij.jpg)\n\n# HBase介绍\n\nHBase表很大：一个表可以有数十亿行，上百万列；\n\nHBase的表将会分成很多个分区，每个分区部分会存在不同的机器上 \n分区是为了便于查询，放在不同机器上，io也增大，假如一个机器的io的是100m，两个就为200m，读取速度就变快了==>**多台机器的io能得到充分利用**\n\n<!-- more -->\n\nHBase表无模式：每行都有一个可排序的主键好任意多的列，列可以根据需要动态的增加，同一张表中不同的行可以有不同的列；\n\n面向列：列独立检索；\n\n稀疏：空列并不占用存储空间，表可以设计的非常稀疏；\n\n数据类型单一：HBase中的数据都是字符串，没有类型\n\n\n\nHBase采用类LSM的架构体系，数据写入并没有直接写入数据文件，而是会先写入缓存（Memstore），在满足一定条件下缓存数据再会异步刷新到硬盘。为了防止数据写入缓存之后不会因为RegionServer进程发生异常导致数据丢失，在写入缓存之前会首先将数据顺序写入HLog中。如果不幸一旦发生RegionServer宕机或者其他异常，这种设计可以从HLog中进行日志回放进行数据补救，保证数据不丢失。HBase故障恢复的最大看点就在于如何通过HLog回放补救丢失数据。\n\n\n\n# HBase结构\n\nHBase进行存储的服务器\n\nHRegion是HBase当中的一个类，**一个表分区的类，按照行分区** \n一个HRegion只会在一个HBase上，一个HBase上可以有多个HRegion \nHBase表每个分区（按照行来分区）的数据被封装到一个类HRegion内 \n如：HBase存在user表，role表，共4个regionServer，HRegion1存储管理user表的一部分，HRegion2存储管理user表的一部分，HRegion3存储管理role表的一部分，HRegion4存储管理role表的一部分\n\n## HRegionserver\n\n管理用户对Table的增、删、改、查操作；\n记录region在哪台Hregion server上\n在Region Split后，负责新Region的分配；\n新机器加入时，管理HRegion Server的负载均衡，调整Region分布\n在HRegion Server宕机后，负责失效HRegion Server 上的Regions迁移。\n\n\n\n## HBase\n\nHRegion Server主要负责响应用户I/O请求，向HDFS文件系统中读写数据，是HBase中最核心的模块。\n\nHRegion Server管理了很多table的分区，也就是region。\n\n## HRegion构成\n\nHRegion类中有**HLog，store**成员，分别代表硬盘和内存 \n\n### Store\n\n每个Region包含着多个Store对象，一个列簇对应一个store 。每个Store包含一个MemStore和若干StoreFile，StoreFile包含一个或多个HFile，StoreFile是对HFile的一种封装。MemStore存放在内存中，StoreFile存储在HDFS上。\n\n### HLog\n\nHLog最终是放在hdfs上。\n\n当我们客户端上传一个表名，一个列簇，一个值，这条命令的值会原封不动的将其写入到HLog里面， 这个是一个appendLog,只可以从底部追加，不允许修改，写到HLog之后，再将数据写入到内存（memstore）当中，HLog里面是存储的操作信息的数据 写在HLog中是因为，防止在写入到内存中的时候，宕机\n\n## Region的划分\n\nRegion按大小分割的，随着数据增多，Region不断增大，当增大到一个阀值（默认256m）的时候，Region就会分成两个新的Region\n\n\n\n## HRegion的存储\n\n### ROOT表和META表\n\nHBase的所有Region元数据被存储在.META.表中，随着Region的增多，.META.表中的数据也会增大，并分裂成多个新的Region。为了定位.META.表中各个Region的位置，把.META.表中所有Region的元数据保存在-ROOT-表中，最后由Zookeeper记录-ROOT-表的位置信息。所有客户端访问用户数据前，需要首先访问Zookeeper获得-ROOT-的位置，然后访问-ROOT-表获得.META.表的位置，最后根据.META.表中的信息确定用户数据存放的位置，如下图所示。\n![](https://ws1.sinaimg.cn/large/006tNbRwgy1fuag5ugi8yj30y60ds0tw.jpg)\n\n-ROOT-表永远不会被分割，它只有一个Region，这样可以保证最多只需要三次跳转就可以定位任意一个Region。为了加快访问速度，.META.表的所有Region全部保存在内存中。客户端会将查询过的位置信息缓存起来，且缓存不会主动失效。如果客户端根据缓存信息还访问不到数据，则询问相关.META.表的Region服务器，试图获取数据的位置，如果还是失败，则询问-ROOT-表相关的.META.表在哪里。最后，如果前面的信息全部失效，则通过ZooKeeper重新定位Region的信息。所以如果客户端上的缓存全部是失效，则需要进行6次网络来回，才能定位到正确的Region。\n\n\n\nroot表,mate表都不会很大 \n因为root表，只是记录位置，本身就不会太大， \n**meta表，和root表在过程中都会被加载到内存中** \n经过3次来回，总共六次，会得到数据表的位置 \n1，client向zookeeper获取root表的位置 2，zookeeper返回root表地址信息 \n3，client读取root表，获得table1的meta表的地址，4 root表所在机器返回meta表地址 \n5，client向mete表读取table地址，6 client向table插入数据 \n读取和写入都会经历上面的过程\n\n\n\n# HBase写数据流程\n\nclient向HRegionserver发送写请求。 \nHRegionserver将**操作信息**数据写到hlog（write ahead log）。为了数据的持久化和恢复。 HLog记录的是操作数据 \n\nHRegionserver将**实际数据**写到内存（memstore） \n反馈client写成功。\n\n\n\n## 数据flush\n\n当memstore数据达到阈值64（新版本默认是128M），将内存集合中的数据刷到硬盘，将内存中的数据删除，同时删除Hlog中的历史数据。 \n并将数据存储到hdfs中。以**数据块**的形式存储。 \n在hlog中做标记点。\n\n### flush的说明\n\n当内存文件memstore文件达到64m的时候，会将数据合并刷新写入到StroeFile文件里面，再将数据写入到HFile里面，HFile文件是一个hdfs文件，序列化到hdfs里面，再通过hdfs的api写入到hdfs集群里面 \n提交到hdfs集群后，HLog，memstore的数据将会被清除\n\n\n\n## 数据合并\n\n1、当（hdfs中）数据块达到4块，hmaster将数据块**加载到本地**(HRegionserver)，进行合并 \n注：这个数据块单块没有大小限制 \n2、当合并的数据超过256M，进行拆分，将拆分后的region分配给不同的hregionserver管理 \n注：如果不大于256M，将数据原封不动写回hdfs \n3、当hregionsever**宕机**后，将该hregionserver上的hlog拆分（按表拆分)，然后分配给不同的hregionserver加载，修改.META. \n注：由Hmaster来更改.META.文件，不会对HRegionserver的性能造成影响 \n4、注意：hlog会同步到hdfs \n注：合并的数据是对相同rowkey的分组合并，如user表中，对id='1'的操作内容合并，对id='2'的合并\n\n\n\n### 合并的好处\n\n**合并操作是由hmaster来工作** \n合并操作是针对一个表来说，user表合并user表，role表合并role表 \n1、清理了垃圾数据 \n2、将大的数据块拆分后，给多个机器管理，优化读取操作等速率\n\n# HBase的读流程\n\n通过zookeeper和-ROOT- .META.表定位HBase。\n数据从内存和硬盘合并后返回给client\n数据块会缓存\n\n\n\n\n\n# Client\n\nHBase Client使用HBase的RPC机制与HRegionserver和RegionServer进行通信\n管理类操作：Client与HRegionserver进行RPC；\n数据读写类操作：Client与HBase进行RPC。\n\n\n\n\n\n\n\n# 读取数据与写入数据流程的不同\n\n除了在表中读取数据，还要在内存磁盘上去搜寻还未存到hdfs里面的数据。 \n所以数据块太大的应该拆分，可以加快查询速度 \n经常查询的数据块还应该放在内存中（HRegionserver的内存中）\n\n\n\n# HBase的出现\n\nhdfs是分布式文件系统，只能保存整个文件，如果一行一行的保存数据，namenode的压力会很大 \n假如有一个文件下有100w小个文件，每个文件都是1k，在datanode中不会占用128m的分块大，但是每个文件元数据所占的大小是一样的，这样的话，namenode空间占满时，datanode中的数据实际上很少。 \nHBase就会很好的解决这个问题，一个文件一个文件写的时候，是先写入到HBase中，先写入到HBase集群中（HBase也分为主从，主为HMaster，从为HRegionserver） \n，HRegionserver的内存中，当数据量达到128m的时候，将数据写入到hdfs中，这样128m数据的元数据只有一条\n\n# HBase细节\n\nHBase实际上是一个缓存层，存储的数据量很少，存的一部分缓存的数据，HBase需要zookeeper来定位HBase查找数据的偏移量\n\n# HBase 主从之间的关系\n\nhmaster只是一个管理者，而且只管理，当HBase集群挂掉之后，数据偏移信息和表的信息，而不管理数据信息，所以有一种极端情况，当HBase集群启动之后，表创建完成，正常运行之后，将hmaster关闭也不会影响整个集群的运行。不像namenode挂了之后不能响应了\n\n# note：\n\nHBase写快读慢，读慢是相对于写来说的，但是跟mysql相比，也不是一个量级的 \n\n\n\n","source":"_posts/HBase性能分析.md","raw":"---\nutitle: HBase原理性能分析\ndate: 2018年08月06日 22时15分52秒\ntags: [HBase,原理]\ncategories: 大数据\ntoc: true\n---\n\n[TOC]\n\n\n\n![](https://ws3.sinaimg.cn/large/0069RVTdgy1fuap8gxtquj31ca0ncdij.jpg)\n\n# HBase介绍\n\nHBase表很大：一个表可以有数十亿行，上百万列；\n\nHBase的表将会分成很多个分区，每个分区部分会存在不同的机器上 \n分区是为了便于查询，放在不同机器上，io也增大，假如一个机器的io的是100m，两个就为200m，读取速度就变快了==>**多台机器的io能得到充分利用**\n\n<!-- more -->\n\nHBase表无模式：每行都有一个可排序的主键好任意多的列，列可以根据需要动态的增加，同一张表中不同的行可以有不同的列；\n\n面向列：列独立检索；\n\n稀疏：空列并不占用存储空间，表可以设计的非常稀疏；\n\n数据类型单一：HBase中的数据都是字符串，没有类型\n\n\n\nHBase采用类LSM的架构体系，数据写入并没有直接写入数据文件，而是会先写入缓存（Memstore），在满足一定条件下缓存数据再会异步刷新到硬盘。为了防止数据写入缓存之后不会因为RegionServer进程发生异常导致数据丢失，在写入缓存之前会首先将数据顺序写入HLog中。如果不幸一旦发生RegionServer宕机或者其他异常，这种设计可以从HLog中进行日志回放进行数据补救，保证数据不丢失。HBase故障恢复的最大看点就在于如何通过HLog回放补救丢失数据。\n\n\n\n# HBase结构\n\nHBase进行存储的服务器\n\nHRegion是HBase当中的一个类，**一个表分区的类，按照行分区** \n一个HRegion只会在一个HBase上，一个HBase上可以有多个HRegion \nHBase表每个分区（按照行来分区）的数据被封装到一个类HRegion内 \n如：HBase存在user表，role表，共4个regionServer，HRegion1存储管理user表的一部分，HRegion2存储管理user表的一部分，HRegion3存储管理role表的一部分，HRegion4存储管理role表的一部分\n\n## HRegionserver\n\n管理用户对Table的增、删、改、查操作；\n记录region在哪台Hregion server上\n在Region Split后，负责新Region的分配；\n新机器加入时，管理HRegion Server的负载均衡，调整Region分布\n在HRegion Server宕机后，负责失效HRegion Server 上的Regions迁移。\n\n\n\n## HBase\n\nHRegion Server主要负责响应用户I/O请求，向HDFS文件系统中读写数据，是HBase中最核心的模块。\n\nHRegion Server管理了很多table的分区，也就是region。\n\n## HRegion构成\n\nHRegion类中有**HLog，store**成员，分别代表硬盘和内存 \n\n### Store\n\n每个Region包含着多个Store对象，一个列簇对应一个store 。每个Store包含一个MemStore和若干StoreFile，StoreFile包含一个或多个HFile，StoreFile是对HFile的一种封装。MemStore存放在内存中，StoreFile存储在HDFS上。\n\n### HLog\n\nHLog最终是放在hdfs上。\n\n当我们客户端上传一个表名，一个列簇，一个值，这条命令的值会原封不动的将其写入到HLog里面， 这个是一个appendLog,只可以从底部追加，不允许修改，写到HLog之后，再将数据写入到内存（memstore）当中，HLog里面是存储的操作信息的数据 写在HLog中是因为，防止在写入到内存中的时候，宕机\n\n## Region的划分\n\nRegion按大小分割的，随着数据增多，Region不断增大，当增大到一个阀值（默认256m）的时候，Region就会分成两个新的Region\n\n\n\n## HRegion的存储\n\n### ROOT表和META表\n\nHBase的所有Region元数据被存储在.META.表中，随着Region的增多，.META.表中的数据也会增大，并分裂成多个新的Region。为了定位.META.表中各个Region的位置，把.META.表中所有Region的元数据保存在-ROOT-表中，最后由Zookeeper记录-ROOT-表的位置信息。所有客户端访问用户数据前，需要首先访问Zookeeper获得-ROOT-的位置，然后访问-ROOT-表获得.META.表的位置，最后根据.META.表中的信息确定用户数据存放的位置，如下图所示。\n![](https://ws1.sinaimg.cn/large/006tNbRwgy1fuag5ugi8yj30y60ds0tw.jpg)\n\n-ROOT-表永远不会被分割，它只有一个Region，这样可以保证最多只需要三次跳转就可以定位任意一个Region。为了加快访问速度，.META.表的所有Region全部保存在内存中。客户端会将查询过的位置信息缓存起来，且缓存不会主动失效。如果客户端根据缓存信息还访问不到数据，则询问相关.META.表的Region服务器，试图获取数据的位置，如果还是失败，则询问-ROOT-表相关的.META.表在哪里。最后，如果前面的信息全部失效，则通过ZooKeeper重新定位Region的信息。所以如果客户端上的缓存全部是失效，则需要进行6次网络来回，才能定位到正确的Region。\n\n\n\nroot表,mate表都不会很大 \n因为root表，只是记录位置，本身就不会太大， \n**meta表，和root表在过程中都会被加载到内存中** \n经过3次来回，总共六次，会得到数据表的位置 \n1，client向zookeeper获取root表的位置 2，zookeeper返回root表地址信息 \n3，client读取root表，获得table1的meta表的地址，4 root表所在机器返回meta表地址 \n5，client向mete表读取table地址，6 client向table插入数据 \n读取和写入都会经历上面的过程\n\n\n\n# HBase写数据流程\n\nclient向HRegionserver发送写请求。 \nHRegionserver将**操作信息**数据写到hlog（write ahead log）。为了数据的持久化和恢复。 HLog记录的是操作数据 \n\nHRegionserver将**实际数据**写到内存（memstore） \n反馈client写成功。\n\n\n\n## 数据flush\n\n当memstore数据达到阈值64（新版本默认是128M），将内存集合中的数据刷到硬盘，将内存中的数据删除，同时删除Hlog中的历史数据。 \n并将数据存储到hdfs中。以**数据块**的形式存储。 \n在hlog中做标记点。\n\n### flush的说明\n\n当内存文件memstore文件达到64m的时候，会将数据合并刷新写入到StroeFile文件里面，再将数据写入到HFile里面，HFile文件是一个hdfs文件，序列化到hdfs里面，再通过hdfs的api写入到hdfs集群里面 \n提交到hdfs集群后，HLog，memstore的数据将会被清除\n\n\n\n## 数据合并\n\n1、当（hdfs中）数据块达到4块，hmaster将数据块**加载到本地**(HRegionserver)，进行合并 \n注：这个数据块单块没有大小限制 \n2、当合并的数据超过256M，进行拆分，将拆分后的region分配给不同的hregionserver管理 \n注：如果不大于256M，将数据原封不动写回hdfs \n3、当hregionsever**宕机**后，将该hregionserver上的hlog拆分（按表拆分)，然后分配给不同的hregionserver加载，修改.META. \n注：由Hmaster来更改.META.文件，不会对HRegionserver的性能造成影响 \n4、注意：hlog会同步到hdfs \n注：合并的数据是对相同rowkey的分组合并，如user表中，对id='1'的操作内容合并，对id='2'的合并\n\n\n\n### 合并的好处\n\n**合并操作是由hmaster来工作** \n合并操作是针对一个表来说，user表合并user表，role表合并role表 \n1、清理了垃圾数据 \n2、将大的数据块拆分后，给多个机器管理，优化读取操作等速率\n\n# HBase的读流程\n\n通过zookeeper和-ROOT- .META.表定位HBase。\n数据从内存和硬盘合并后返回给client\n数据块会缓存\n\n\n\n\n\n# Client\n\nHBase Client使用HBase的RPC机制与HRegionserver和RegionServer进行通信\n管理类操作：Client与HRegionserver进行RPC；\n数据读写类操作：Client与HBase进行RPC。\n\n\n\n\n\n\n\n# 读取数据与写入数据流程的不同\n\n除了在表中读取数据，还要在内存磁盘上去搜寻还未存到hdfs里面的数据。 \n所以数据块太大的应该拆分，可以加快查询速度 \n经常查询的数据块还应该放在内存中（HRegionserver的内存中）\n\n\n\n# HBase的出现\n\nhdfs是分布式文件系统，只能保存整个文件，如果一行一行的保存数据，namenode的压力会很大 \n假如有一个文件下有100w小个文件，每个文件都是1k，在datanode中不会占用128m的分块大，但是每个文件元数据所占的大小是一样的，这样的话，namenode空间占满时，datanode中的数据实际上很少。 \nHBase就会很好的解决这个问题，一个文件一个文件写的时候，是先写入到HBase中，先写入到HBase集群中（HBase也分为主从，主为HMaster，从为HRegionserver） \n，HRegionserver的内存中，当数据量达到128m的时候，将数据写入到hdfs中，这样128m数据的元数据只有一条\n\n# HBase细节\n\nHBase实际上是一个缓存层，存储的数据量很少，存的一部分缓存的数据，HBase需要zookeeper来定位HBase查找数据的偏移量\n\n# HBase 主从之间的关系\n\nhmaster只是一个管理者，而且只管理，当HBase集群挂掉之后，数据偏移信息和表的信息，而不管理数据信息，所以有一种极端情况，当HBase集群启动之后，表创建完成，正常运行之后，将hmaster关闭也不会影响整个集群的运行。不像namenode挂了之后不能响应了\n\n# note：\n\nHBase写快读慢，读慢是相对于写来说的，但是跟mysql相比，也不是一个量级的 \n\n\n\n","slug":"HBase性能分析","published":1,"updated":"2018-08-15T14:46:17.237Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloj0ll7000lykpbsrjgnpq1"},{"title":"HBase拷贝生产环境数据到本地Spark解析运行调试","date":"2018-08-10T10:19:15.453Z","toc":true,"_content":"\n[TOC]\n\n> 由于线上环境要经过跳板机跳转，并且打包测试，上传jar包步骤多，不然的话，要进行各种端口转发，且有权限控制，不易在本地idea编辑器上进行程序运行及调试\n>\n> 现在想法是，将线上测试环境的数据拷贝小部分到本地自己搭建的集群，进行程序的逻辑和初期调试\n>\n> 此贴就是记录一些操作\n\n这都是要基于本地有HBASE及其依赖组件的。\n\n主要思路是，拷贝线上查询的结果到文件hbaseout1.txt，将hbaseout1.txt文件sz导入本地\n\n再在本地集群上将数据插入到hbase\n\n<!-- more -->\n\n# 1、创建和线上同名通结构的表\n\n在线上执行 `describe 'beehive:a_up_rawdata'`\n\n得到\n\n![](https://ws4.sinaimg.cn/large/0069RVTdgy1fu4t1ryqfbj31kw074n4w.jpg)\n\n\n\n在本地执行\n\n```\nhbase shell\ncreate_namespace 'beehive'\n\ncreate 'beehive:a_up_rawdata',{NAME => 'cf', BLOOMFILTER => 'ROW', VERSIONS => '1', IN_MEMORY => 'false', KEEP_DELETED_CELLS => 'FALSE', DATA_BLOCK_ENCODING => 'NONE', COMPRESSION => 'NONE', TTL => 'FOREVER', MIN_VERSIONS => '0', BLOCKCACHE => 'true', BLOCKSIZE => '65536', REPLICATION_SCOPE => '1'}\n```\n\n\n\n# 2、拷贝线上hbase数据\n\n\n\n## 查询结果导入文件\n\n在线上机器任意目录执行\n\n```bash\necho \"get 'beehive:a_up_rawdata','530111199211287371',{COLUMN=>'cf:273468436_data'}\"| hbase shell> hbaseout1.txt\n```\n\n\n\n解析: `get 'beehive:a_up_rawdata','530111199211287371',{COLUMN=>'cf:273468436_data'}`是执行的hbase的查询语句，将查询的结果存入到当前目录 **hbaseout1.txt**文件中\n\n## 查询文件下载到本地\n\n`sz hbaseout1.txt`\n\n## 修改文件内容\n\n可以查看hbaseout1.txt中可以看到会有表头\n\n![](https://ws2.sinaimg.cn/large/0069RVTdgy1fu4s99k250j31g208qgs4.jpg)\n\n需要将这部分表头数据删除，组成标准的导入文件\n\n## 修改文件编码\n\n![](https://ws1.sinaimg.cn/large/0069RVTdgy1fu4shn9bpnj31l203i0tv.jpg)\n\n在通过 hbase shell 查看中文值时, 是 unicode 编码格式，使得直接查看中文值不太方便。如果要查看需要把 unicode 编码进行 decode\n\n[参考]: https://blog.csdn.net/zychun1991/article/details/69938992\t\"hbase shell 中文 unicode 编码\"\n\n将查询结果导出来\n\n```bash\nprint ('需要转码内容'.decode('utf-8'))\n\n命令样例\npython 2.7 \n\tprint ('***\\xE4\\xBD\\xA010009 '.decode('utf-8'))\npython 3 \n\tprint '***\\xE4\\xBD\\xA010009 '.decode('utf-8')\n```\n\n可以有更友好的将内容设置为文件名，然后将转码后重新写入到一个文件，后续会更新\n\n\n\n转码过后，文字显示正确\n\n![](https://ws4.sinaimg.cn/large/0069RVTdgy1fu4sp3u3w6j31ak0f27fi.jpg)\n\n\n\n## 重新组合文件\n\n由于导入到hbase命令为 **`格式：hbase [类][分隔符] [行键，列族][表] [导入文件`]\n\n由于我这次导入的文件里面有“,”，所有将分隔符设置为“|”\n\n更改后的文件格式为\n\n![](https://ws2.sinaimg.cn/large/0069RVTdgy1fu4ssvedr6j319a030wel.jpg)\n\n将文件上传到hdfs\n\n```bash\nhadoop fs -put hadoop fs -put hbaseout1.txt /local/\n```\n\n## 将数据导入到本地hbase\n\n```Bash\nhbase org.apache.hadoop.hbase.mapreduce.ImportTsv  -Dimporttsv.separator=\"|\"  -Dimporttsv.columns=HBASE_ROW_KEY,cf:273468436_data beehive:a_up_rawdata /local/hbaseout2.txt\n```\n\n\n# 3、校验查看\n\n在hue上查看hbase内容，显示有数据\n\n![](https://ws1.sinaimg.cn/large/006tNbRwgy1fu50q6kl65j31kg0kymxw.jpg)\n\n在hbase shell 查看\n\n![](https://ws4.sinaimg.cn/large/006tNbRwgy1fu515ozpw6j31kw08b7dl.jpg)\n\n","source":"_posts/HBase拷贝生产环境数据到本地运行调试.md","raw":"---\ntitle: HBase拷贝生产环境数据到本地Spark解析运行调试\ndate: 2018年08月06日 22时15分52秒\ntags: [HBase,操作]\ncategories: 大数据\ntoc: true\n---\n\n[TOC]\n\n> 由于线上环境要经过跳板机跳转，并且打包测试，上传jar包步骤多，不然的话，要进行各种端口转发，且有权限控制，不易在本地idea编辑器上进行程序运行及调试\n>\n> 现在想法是，将线上测试环境的数据拷贝小部分到本地自己搭建的集群，进行程序的逻辑和初期调试\n>\n> 此贴就是记录一些操作\n\n这都是要基于本地有HBASE及其依赖组件的。\n\n主要思路是，拷贝线上查询的结果到文件hbaseout1.txt，将hbaseout1.txt文件sz导入本地\n\n再在本地集群上将数据插入到hbase\n\n<!-- more -->\n\n# 1、创建和线上同名通结构的表\n\n在线上执行 `describe 'beehive:a_up_rawdata'`\n\n得到\n\n![](https://ws4.sinaimg.cn/large/0069RVTdgy1fu4t1ryqfbj31kw074n4w.jpg)\n\n\n\n在本地执行\n\n```\nhbase shell\ncreate_namespace 'beehive'\n\ncreate 'beehive:a_up_rawdata',{NAME => 'cf', BLOOMFILTER => 'ROW', VERSIONS => '1', IN_MEMORY => 'false', KEEP_DELETED_CELLS => 'FALSE', DATA_BLOCK_ENCODING => 'NONE', COMPRESSION => 'NONE', TTL => 'FOREVER', MIN_VERSIONS => '0', BLOCKCACHE => 'true', BLOCKSIZE => '65536', REPLICATION_SCOPE => '1'}\n```\n\n\n\n# 2、拷贝线上hbase数据\n\n\n\n## 查询结果导入文件\n\n在线上机器任意目录执行\n\n```bash\necho \"get 'beehive:a_up_rawdata','530111199211287371',{COLUMN=>'cf:273468436_data'}\"| hbase shell> hbaseout1.txt\n```\n\n\n\n解析: `get 'beehive:a_up_rawdata','530111199211287371',{COLUMN=>'cf:273468436_data'}`是执行的hbase的查询语句，将查询的结果存入到当前目录 **hbaseout1.txt**文件中\n\n## 查询文件下载到本地\n\n`sz hbaseout1.txt`\n\n## 修改文件内容\n\n可以查看hbaseout1.txt中可以看到会有表头\n\n![](https://ws2.sinaimg.cn/large/0069RVTdgy1fu4s99k250j31g208qgs4.jpg)\n\n需要将这部分表头数据删除，组成标准的导入文件\n\n## 修改文件编码\n\n![](https://ws1.sinaimg.cn/large/0069RVTdgy1fu4shn9bpnj31l203i0tv.jpg)\n\n在通过 hbase shell 查看中文值时, 是 unicode 编码格式，使得直接查看中文值不太方便。如果要查看需要把 unicode 编码进行 decode\n\n[参考]: https://blog.csdn.net/zychun1991/article/details/69938992\t\"hbase shell 中文 unicode 编码\"\n\n将查询结果导出来\n\n```bash\nprint ('需要转码内容'.decode('utf-8'))\n\n命令样例\npython 2.7 \n\tprint ('***\\xE4\\xBD\\xA010009 '.decode('utf-8'))\npython 3 \n\tprint '***\\xE4\\xBD\\xA010009 '.decode('utf-8')\n```\n\n可以有更友好的将内容设置为文件名，然后将转码后重新写入到一个文件，后续会更新\n\n\n\n转码过后，文字显示正确\n\n![](https://ws4.sinaimg.cn/large/0069RVTdgy1fu4sp3u3w6j31ak0f27fi.jpg)\n\n\n\n## 重新组合文件\n\n由于导入到hbase命令为 **`格式：hbase [类][分隔符] [行键，列族][表] [导入文件`]\n\n由于我这次导入的文件里面有“,”，所有将分隔符设置为“|”\n\n更改后的文件格式为\n\n![](https://ws2.sinaimg.cn/large/0069RVTdgy1fu4ssvedr6j319a030wel.jpg)\n\n将文件上传到hdfs\n\n```bash\nhadoop fs -put hadoop fs -put hbaseout1.txt /local/\n```\n\n## 将数据导入到本地hbase\n\n```Bash\nhbase org.apache.hadoop.hbase.mapreduce.ImportTsv  -Dimporttsv.separator=\"|\"  -Dimporttsv.columns=HBASE_ROW_KEY,cf:273468436_data beehive:a_up_rawdata /local/hbaseout2.txt\n```\n\n\n# 3、校验查看\n\n在hue上查看hbase内容，显示有数据\n\n![](https://ws1.sinaimg.cn/large/006tNbRwgy1fu50q6kl65j31kg0kymxw.jpg)\n\n在hbase shell 查看\n\n![](https://ws4.sinaimg.cn/large/006tNbRwgy1fu515ozpw6j31kw08b7dl.jpg)\n\n","slug":"HBase拷贝生产环境数据到本地运行调试","published":1,"updated":"2018-08-15T14:29:52.538Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloj0ll9000qykpb5yhcvqab"},{"title":"HDFS元数据备份流程","date":"2018-08-15T15:56:42.315Z","toc":true,"_content":"\n[TOC]\n\n\n\n<!-- more -->","source":"_posts/HDFS元数据备份流程.md","raw":"---\ntitle: HDFS元数据备份流程\ndate: 2018年08月06日 22时15分52秒\ntags: [HDFS,原理,Hadoop]\ncategories: 大数据\ntoc: true\n---\n\n[TOC]\n\n\n\n<!-- more -->","slug":"HDFS元数据备份流程","published":1,"updated":"2018-08-15T15:56:42.934Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloj0lla000sykpbhafm48qd"},{"title":"Hadoop-HA-Federation机制","date":"2018-08-15T15:21:34.817Z","toc":true,"_content":"\n[TOC]\n\n![](https://ws1.sinaimg.cn/large/006tNbRwly1fubqgn0culj31eo0nm401.jpg)\n\n（1）hadoop-HA集群运作机制介绍\n\n所谓HA，即高可用（7*24小时不中断服务）\n\n实现高可用最关键的是消除单点故障\n\nhadoop-ha严格来说应该分成各个组件的HA机制——HDFS的HA、YARN的HA\n\n \n\n（2）HDFS的HA机制详解\n\n通过双namenode消除单点故障\n\n双namenode协调工作的要点：\n\n​    A、元数据管理方式需要改变：\n\n​    内存中各自保存一份元数据\n\n​    Edits日志只能有一份，只有Active状态的namenode节点可以做写操作\n\n​    两个namenode都可以读取edits\n\n​    共享的edits放在一个共享存储中管理（qjournal和NFS两个主流实现）\n\n​    B、需要一个状态管理功能模块\n\n​    实现了一个zkfailover，常驻在每一个namenode所在的节点\n\n​    每一个zkfailover负责监控自己所在namenode节点，利用zk进行状态标识\n\n​    当需要进行状态切换时，由zkfailover来负责切换\n\n​    切换时需要防止brain split现象的发生\n\n\n\n\n\n\n\nHadoop-HA的主要思想是有两个NameNode，一个作为主NameNode，一个作为standby，两个NameNode使用同一个命名空间。通过zookeepr（JournalNode）来进行协调，实现NameNode的主备切换。\n\n<!-- more -->","source":"_posts/Hadoop-构成及HA-.md","raw":"---\ntitle: Hadoop-HA-Federation机制\ndate: 2018年08月06日 22时15分52秒\ntags: [Hadoop]\ncategories: 大数据\ntoc: true\n---\n\n[TOC]\n\n![](https://ws1.sinaimg.cn/large/006tNbRwly1fubqgn0culj31eo0nm401.jpg)\n\n（1）hadoop-HA集群运作机制介绍\n\n所谓HA，即高可用（7*24小时不中断服务）\n\n实现高可用最关键的是消除单点故障\n\nhadoop-ha严格来说应该分成各个组件的HA机制——HDFS的HA、YARN的HA\n\n \n\n（2）HDFS的HA机制详解\n\n通过双namenode消除单点故障\n\n双namenode协调工作的要点：\n\n​    A、元数据管理方式需要改变：\n\n​    内存中各自保存一份元数据\n\n​    Edits日志只能有一份，只有Active状态的namenode节点可以做写操作\n\n​    两个namenode都可以读取edits\n\n​    共享的edits放在一个共享存储中管理（qjournal和NFS两个主流实现）\n\n​    B、需要一个状态管理功能模块\n\n​    实现了一个zkfailover，常驻在每一个namenode所在的节点\n\n​    每一个zkfailover负责监控自己所在namenode节点，利用zk进行状态标识\n\n​    当需要进行状态切换时，由zkfailover来负责切换\n\n​    切换时需要防止brain split现象的发生\n\n\n\n\n\n\n\nHadoop-HA的主要思想是有两个NameNode，一个作为主NameNode，一个作为standby，两个NameNode使用同一个命名空间。通过zookeepr（JournalNode）来进行协调，实现NameNode的主备切换。\n\n<!-- more -->","slug":"Hadoop-构成及HA-","published":1,"updated":"2018-08-16T10:52:49.096Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloj0llc000xykpbr76wxx2c"},{"title":"Hadoop零碎知识点","date":"2018-08-15T16:34:55.243Z","toc":true,"_content":"\n[TOC]\n\n## 查看元数据信息\n可以通过hdfs的一个工具来查看edits中的信息\n\n```bash\nbin/hdfs oev -i edits -o edits.xml\nbin/hdfs oiv -i fsimage_0000000000000000087 -p XML -o fsimage.xml\n```\n\n\n\n<!-- more -->\n\n","source":"_posts/Hadoop零碎知识点.md","raw":"---\ntitle: Hadoop零碎知识点\ndate: 2018年08月06日 22时15分52秒\ntags: [HDFS,原理,Hadoop]\ncategories: 大数据\ntoc: true\n---\n\n[TOC]\n\n## 查看元数据信息\n可以通过hdfs的一个工具来查看edits中的信息\n\n```bash\nbin/hdfs oev -i edits -o edits.xml\nbin/hdfs oiv -i fsimage_0000000000000000087 -p XML -o fsimage.xml\n```\n\n\n\n<!-- more -->\n\n","slug":"Hadoop零碎知识点","published":1,"updated":"2018-09-05T02:23:54.650Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloj0llc000yykpbuqo65hwa"},{"title":"Hbase-shell操作","date":"2018-08-10T09:27:05.100Z","toc":true,"_content":"\n[TOC]\n\n![](https://ws3.sinaimg.cn/large/006tNbRwgy1fu5599pvv8j30y60b0dfw.jpg)\n\nhbase使用命令行操作，简单直接，方便快捷，掌握一点必备的基础命令。\n\nHBase启动命令行\n\n```bash\n$HBASE_HOME/bin/hbase shell\n```\n\n<!-- more -->\n\n## 创建表\n\n```bash\ncreate 'testtable',{NAME=>'cf',VERSIONS=>2},{NAME=>'cf2',VERSIONS=>2}\n```\n\n## 创建namespace\n\n```bash\ncreate_namespace 'beehive'\n```\n\n\n\n## 查看表结构\n\n```bash\ndisable 'testtable'\n```\n\n\n\n## 删除表\n\n```bash\ndrop 'testtable'\n```\n\n## 修改表\n\n```bash\ndisable 'testtable'\nalter 'testtable',{NAME=>'cf',TTL=>'10000000'},{NAME=>'cf2',TTL=>'10000000'}\nenable 'testtable'\n修改表必须先 disable 表\n```\n\n## 表数据的增删查改：\n\n### 添加数据：\n\n```Bash\nput 'testtable','rowkey1','cf:key1','val1'\n```\n\n\n\n### 查询数据:\n\n```bash\nget 'testtable','rowkey1','cf:key1'\nget 'testtable','rowkey1', {COLUMN=>'cf:key1'}\n```\n\n\n\n### 扫描表:\n\n```bash\nscan 'testtable',{COLUMNS=>cf:col1,LIMIT=>5} #可以添加STARTROW、TIMERANGE和FITLER等高级功能\n```\n\n### 查询表中的数据行数:\n\n语法：`count <table>, {INTERVAL => intervalNum, CACHE => cacheNum}`\n\n```Bash\ncount 'testtable',{INTERVAL => 100, CACHE => 500}\n```\n\n\n\n### 删除数据:\n\n```bash\ndelete 'testtable','rowkey1','cf:key1'\ntruncate 'testtable'\n```\n\n","source":"_posts/Hbase-shell操作.md","raw":"---\ntitle: Hbase-shell操作\ndate: 2018年08月06日 22时15分52秒\ntags:  [HBase,Shell]\ncategories: 大数据\ntoc: true\n---\n\n[TOC]\n\n![](https://ws3.sinaimg.cn/large/006tNbRwgy1fu5599pvv8j30y60b0dfw.jpg)\n\nhbase使用命令行操作，简单直接，方便快捷，掌握一点必备的基础命令。\n\nHBase启动命令行\n\n```bash\n$HBASE_HOME/bin/hbase shell\n```\n\n<!-- more -->\n\n## 创建表\n\n```bash\ncreate 'testtable',{NAME=>'cf',VERSIONS=>2},{NAME=>'cf2',VERSIONS=>2}\n```\n\n## 创建namespace\n\n```bash\ncreate_namespace 'beehive'\n```\n\n\n\n## 查看表结构\n\n```bash\ndisable 'testtable'\n```\n\n\n\n## 删除表\n\n```bash\ndrop 'testtable'\n```\n\n## 修改表\n\n```bash\ndisable 'testtable'\nalter 'testtable',{NAME=>'cf',TTL=>'10000000'},{NAME=>'cf2',TTL=>'10000000'}\nenable 'testtable'\n修改表必须先 disable 表\n```\n\n## 表数据的增删查改：\n\n### 添加数据：\n\n```Bash\nput 'testtable','rowkey1','cf:key1','val1'\n```\n\n\n\n### 查询数据:\n\n```bash\nget 'testtable','rowkey1','cf:key1'\nget 'testtable','rowkey1', {COLUMN=>'cf:key1'}\n```\n\n\n\n### 扫描表:\n\n```bash\nscan 'testtable',{COLUMNS=>cf:col1,LIMIT=>5} #可以添加STARTROW、TIMERANGE和FITLER等高级功能\n```\n\n### 查询表中的数据行数:\n\n语法：`count <table>, {INTERVAL => intervalNum, CACHE => cacheNum}`\n\n```Bash\ncount 'testtable',{INTERVAL => 100, CACHE => 500}\n```\n\n\n\n### 删除数据:\n\n```bash\ndelete 'testtable','rowkey1','cf:key1'\ntruncate 'testtable'\n```\n\n","slug":"Hbase-shell操作","published":1,"updated":"2018-08-10T18:00:25.636Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloj0lle0012ykpbhgvw700x"},{"title":"Hdfs结构性能分析及读写流程","date":"2018-08-15T15:55:15.892Z","toc":true,"_content":"\n[TOC]\n\n\n\n\n\n<!-- more -->\n\n# namenode和secondaryNameNode最好不要放在一台机器上\n\n宕机可能导致数据不能恢复 \n测试环境或者学习环境可以弄在一台机器上\n\n# hdfs中namenode和datanode的初始化\n\nhdfs会在配置文件中配置一个datanode的工作目录元数据 \n查看目录结构 tree hddata/ \n![img](file:///var/folders/9p/dbpbsyq158n7y12303j34hxm0000gp/T/WizNote/3172cdcb-77fe-4f72-8882-12fe40ddef6a/index_files/4ee70fb7-cfdc-4010-a387-986e268b5a1e.jpg) \ndatanode的工作目录是在datanode启动后初始化的 \n而hadoop namenode format 只会初始name的工作目录，和datanode没有关系\n\n# 把一个hdfs的一个节点加入到另一个集群\n\n必须要将hdfs datanode的工作目录删除，不然持有上一个集群的datanode的工作目录，会认为是一个误操作，为了防止丢失数据，不会让其连接上\n\n# 如果集群够大，上百台机器\n\n那么在hdfs上面，是需要配置机架感知\n\n# namenode管理元数据\n\nnamenode会将元数据放在内存里面，这样方便快速对数据的请求 \n但是放在内存中是不安全的，所有就序列化到fsimage里面 \n![img](file:///var/folders/9p/dbpbsyq158n7y12303j34hxm0000gp/T/WizNote/3172cdcb-77fe-4f72-8882-12fe40ddef6a/index_files/2d3df4da-f64b-4ccf-967b-9ade7c2ab46f.jpg) \n就像jvm中dump，将内存中所有数据dump出去 \n假如 \n![img](file:///var/folders/9p/dbpbsyq158n7y12303j34hxm0000gp/T/WizNote/3172cdcb-77fe-4f72-8882-12fe40ddef6a/index_files/8fa4e8c2-8b29-4809-8219-b383aa6d8664.jpg) \n所以存大文件划算，因为元数据消耗的内存都是一样的 \n![img](file:///var/folders/9p/dbpbsyq158n7y12303j34hxm0000gp/T/WizNote/3172cdcb-77fe-4f72-8882-12fe40ddef6a/index_files/2a0de522-13be-4777-b2f4-68377648bbb4.jpg) \n但是内存中的数据量太大，不可能经常序列化，所以需要定时序列化\n\n## 所以引入了secondaryNameNode\n\n更新元数据的时候，不可能去直接跟更改元数据fsimage文件，因为文件是线性结构，假如遇到更改中间内容会很不方便，所有就将操作信息记录在edits日志文件中，只是记录操作信息\n\n### edits文件定期转为元数据\n\n为了防止edits过多，导致在启动hdfs集群datanode的时候会很慢，因为需要将edits通过转化形成为元数据fsimage文件，所以应该定期将edits文件转换为fsimage元数据，然后将fsimage替换掉\n\n### secondaryNameNode的出现\n\n如果nameNode来做上面的edits转换为元数据的话，由于消耗的资源太大，就不能为其他比如从hdfs中读取数据服务提供资源，或者提供服务的效果不好 \n所以这个时候就把合并操作交给secondNameNode来做 \n这个过程叫做checkpoint \n![img](file:///var/folders/9p/dbpbsyq158n7y12303j34hxm0000gp/T/WizNote/3172cdcb-77fe-4f72-8882-12fe40ddef6a/index_files/d6a7699e-3158-4cfc-ab83-9fec25286004.jpg)\n\n## 为了防止namenode宕机导致了数据丢失\n\n可以在hdfs-site.xml文件中在多个机器上的目录来保存name的edits，fsimage文件\n\n `<property>``    <name>dfs.name.dir</name>``    <value>/home/bigdata/names1,/home/bigdata/names2</value>``</property>`\n\n配置的多个的话，会同时往这两个目录中写\n\n如果不配置这个默认的目录是core-site.xml文件中配置的hadoop的临时文件 \n ` \n <property> \n​       <name>hadoop.tmp.dir</name> \n​       <value>/home/bigdata/apps/hadoop-2.6.4/tmp</value> \n   </property> `\n\n# Hdfs的结构\n\n1.HDFS集群分为两大角色：NameNode、DataNode （secondary NameNode）\n2.NameNode负责管理整个文件系统的元数据\n记录文件在哪里\n3.DataNode 负责管理用户的文件数据块\n不负责切块，负责保管\n4.文件会按照固定的大小（blocksize）切成若干块后分布式存储在若干台datanode上\n5.每一个文件块可以有多个副本，并存放在不同的datanode上\n副本不会放在同一个机器上，因为副本就是防止宕机，\n6.Datanode会定期向Namenode汇报自身所保存的文件block信息，而namenode则会负责保持文件的副本数量\n因为datanode如果宕机的话，name该机器上的对应的副本数据将会消失，这样需要将其在其他机器上进行恢复，恢复的话，就需要上面就需要数据和未宕机时的数据尽量保持一致，所以需要依赖于datanode定期汇报，不然差距的数据会很大\n7.HDFS的内部工作机制对客户端保持透明，客户端请求访问HDFS都是通过向namenode申请来进行\n\n\n\n## Hdfs写操作\n\n 详细步骤解析\n\n1、根namenode通信请求上传文件，namenode检查目标文件是否已存在，父目录是否存在\n\n不存在则会返回path not exist异常\n\n2、namenode返回是否可以上传\n\n3、client请求第一个 block（0-128m）该传输到哪些datanode服务器上\n\n返回该block存放的位置，及其副本的信息存放的位置\n\n4、namenode返回3个datanode服务器ABC\n\n副本选择策略\n\n考虑空间和距离的因素，网络跳转的跳数，比如说机架的位置，\n\n第一台是看谁比较近（机架），因为传输比较快，副本则是是看谁比较远，防止机架出问题（如断电），干扰性更小\n\n而集群全线崩塌\n\n5、client请求3台dn中的一台A上传数据（本质上是一个RPC调用，建立pipeline），A收到请求会继续调用B，然后B调用C，将真个pipeline建立完成，逐级返回客户端\n\n这样是防止整个流程变慢，同时创建通道，先建立通道pipeline,通道\n\n6、client开始往A上传第一个block（先从磁盘读取数据放到一个本地内存缓存bytebuf），以packet为单位，A收到一个packet就会传给B，B传给C；A每传一个packet会放入一个应答队列等待应答\n\n \n\n因为等一个block写满之后再传送，速度会很慢，所以是接收一个packet就会写入到管道流pipeline中。\n\n只要上传一个成功，则客户端视为上传成功，因为如果没上传成功，namenode会进行异步的复制副本的信息\n\n7、当一个block传输完成之后，client再次请求**namenode**上传第二个block的服务器。\n\n注：写的过程中，namenode记录下来了文件路径，文件有几个block也记录下来了，每个block分配到哪些机器上也记录下到了，及其每个block的副本信息，副本在那几个机器上。\n\n校验的时候不是一个packet（一批chunk，共64k）校验，而是以一个chunk来校验，一个chunk是512byte（字节）\n\n# Hdfs读操作\n\n1、跟namenode通信查询元数据，找到文件块所在的datanode服务器\n\n2、挑选一台datanode（就近原则，然后随机）服务器，请求建立socket流\n\n3、datanode开始发送数据（从磁盘里面读取数据放入流，以packet为单位来做校验）\n\n4、客户端以packet为单位接收，现在本地缓存，然后写入目标文件","source":"_posts/Hdfs结构性能分析及读写流程.md","raw":"---\ntitle: Hdfs结构性能分析及读写流程\ndate: 2018年08月06日 22时15分52秒\ntags: [HDFS,原理,Hadoop]\ncategories: 大数据\ntoc: true\n---\n\n[TOC]\n\n\n\n\n\n<!-- more -->\n\n# namenode和secondaryNameNode最好不要放在一台机器上\n\n宕机可能导致数据不能恢复 \n测试环境或者学习环境可以弄在一台机器上\n\n# hdfs中namenode和datanode的初始化\n\nhdfs会在配置文件中配置一个datanode的工作目录元数据 \n查看目录结构 tree hddata/ \n![img](file:///var/folders/9p/dbpbsyq158n7y12303j34hxm0000gp/T/WizNote/3172cdcb-77fe-4f72-8882-12fe40ddef6a/index_files/4ee70fb7-cfdc-4010-a387-986e268b5a1e.jpg) \ndatanode的工作目录是在datanode启动后初始化的 \n而hadoop namenode format 只会初始name的工作目录，和datanode没有关系\n\n# 把一个hdfs的一个节点加入到另一个集群\n\n必须要将hdfs datanode的工作目录删除，不然持有上一个集群的datanode的工作目录，会认为是一个误操作，为了防止丢失数据，不会让其连接上\n\n# 如果集群够大，上百台机器\n\n那么在hdfs上面，是需要配置机架感知\n\n# namenode管理元数据\n\nnamenode会将元数据放在内存里面，这样方便快速对数据的请求 \n但是放在内存中是不安全的，所有就序列化到fsimage里面 \n![img](file:///var/folders/9p/dbpbsyq158n7y12303j34hxm0000gp/T/WizNote/3172cdcb-77fe-4f72-8882-12fe40ddef6a/index_files/2d3df4da-f64b-4ccf-967b-9ade7c2ab46f.jpg) \n就像jvm中dump，将内存中所有数据dump出去 \n假如 \n![img](file:///var/folders/9p/dbpbsyq158n7y12303j34hxm0000gp/T/WizNote/3172cdcb-77fe-4f72-8882-12fe40ddef6a/index_files/8fa4e8c2-8b29-4809-8219-b383aa6d8664.jpg) \n所以存大文件划算，因为元数据消耗的内存都是一样的 \n![img](file:///var/folders/9p/dbpbsyq158n7y12303j34hxm0000gp/T/WizNote/3172cdcb-77fe-4f72-8882-12fe40ddef6a/index_files/2a0de522-13be-4777-b2f4-68377648bbb4.jpg) \n但是内存中的数据量太大，不可能经常序列化，所以需要定时序列化\n\n## 所以引入了secondaryNameNode\n\n更新元数据的时候，不可能去直接跟更改元数据fsimage文件，因为文件是线性结构，假如遇到更改中间内容会很不方便，所有就将操作信息记录在edits日志文件中，只是记录操作信息\n\n### edits文件定期转为元数据\n\n为了防止edits过多，导致在启动hdfs集群datanode的时候会很慢，因为需要将edits通过转化形成为元数据fsimage文件，所以应该定期将edits文件转换为fsimage元数据，然后将fsimage替换掉\n\n### secondaryNameNode的出现\n\n如果nameNode来做上面的edits转换为元数据的话，由于消耗的资源太大，就不能为其他比如从hdfs中读取数据服务提供资源，或者提供服务的效果不好 \n所以这个时候就把合并操作交给secondNameNode来做 \n这个过程叫做checkpoint \n![img](file:///var/folders/9p/dbpbsyq158n7y12303j34hxm0000gp/T/WizNote/3172cdcb-77fe-4f72-8882-12fe40ddef6a/index_files/d6a7699e-3158-4cfc-ab83-9fec25286004.jpg)\n\n## 为了防止namenode宕机导致了数据丢失\n\n可以在hdfs-site.xml文件中在多个机器上的目录来保存name的edits，fsimage文件\n\n `<property>``    <name>dfs.name.dir</name>``    <value>/home/bigdata/names1,/home/bigdata/names2</value>``</property>`\n\n配置的多个的话，会同时往这两个目录中写\n\n如果不配置这个默认的目录是core-site.xml文件中配置的hadoop的临时文件 \n ` \n <property> \n​       <name>hadoop.tmp.dir</name> \n​       <value>/home/bigdata/apps/hadoop-2.6.4/tmp</value> \n   </property> `\n\n# Hdfs的结构\n\n1.HDFS集群分为两大角色：NameNode、DataNode （secondary NameNode）\n2.NameNode负责管理整个文件系统的元数据\n记录文件在哪里\n3.DataNode 负责管理用户的文件数据块\n不负责切块，负责保管\n4.文件会按照固定的大小（blocksize）切成若干块后分布式存储在若干台datanode上\n5.每一个文件块可以有多个副本，并存放在不同的datanode上\n副本不会放在同一个机器上，因为副本就是防止宕机，\n6.Datanode会定期向Namenode汇报自身所保存的文件block信息，而namenode则会负责保持文件的副本数量\n因为datanode如果宕机的话，name该机器上的对应的副本数据将会消失，这样需要将其在其他机器上进行恢复，恢复的话，就需要上面就需要数据和未宕机时的数据尽量保持一致，所以需要依赖于datanode定期汇报，不然差距的数据会很大\n7.HDFS的内部工作机制对客户端保持透明，客户端请求访问HDFS都是通过向namenode申请来进行\n\n\n\n## Hdfs写操作\n\n 详细步骤解析\n\n1、根namenode通信请求上传文件，namenode检查目标文件是否已存在，父目录是否存在\n\n不存在则会返回path not exist异常\n\n2、namenode返回是否可以上传\n\n3、client请求第一个 block（0-128m）该传输到哪些datanode服务器上\n\n返回该block存放的位置，及其副本的信息存放的位置\n\n4、namenode返回3个datanode服务器ABC\n\n副本选择策略\n\n考虑空间和距离的因素，网络跳转的跳数，比如说机架的位置，\n\n第一台是看谁比较近（机架），因为传输比较快，副本则是是看谁比较远，防止机架出问题（如断电），干扰性更小\n\n而集群全线崩塌\n\n5、client请求3台dn中的一台A上传数据（本质上是一个RPC调用，建立pipeline），A收到请求会继续调用B，然后B调用C，将真个pipeline建立完成，逐级返回客户端\n\n这样是防止整个流程变慢，同时创建通道，先建立通道pipeline,通道\n\n6、client开始往A上传第一个block（先从磁盘读取数据放到一个本地内存缓存bytebuf），以packet为单位，A收到一个packet就会传给B，B传给C；A每传一个packet会放入一个应答队列等待应答\n\n \n\n因为等一个block写满之后再传送，速度会很慢，所以是接收一个packet就会写入到管道流pipeline中。\n\n只要上传一个成功，则客户端视为上传成功，因为如果没上传成功，namenode会进行异步的复制副本的信息\n\n7、当一个block传输完成之后，client再次请求**namenode**上传第二个block的服务器。\n\n注：写的过程中，namenode记录下来了文件路径，文件有几个block也记录下来了，每个block分配到哪些机器上也记录下到了，及其每个block的副本信息，副本在那几个机器上。\n\n校验的时候不是一个packet（一批chunk，共64k）校验，而是以一个chunk来校验，一个chunk是512byte（字节）\n\n# Hdfs读操作\n\n1、跟namenode通信查询元数据，找到文件块所在的datanode服务器\n\n2、挑选一台datanode（就近原则，然后随机）服务器，请求建立socket流\n\n3、datanode开始发送数据（从磁盘里面读取数据放入流，以packet为单位来做校验）\n\n4、客户端以packet为单位接收，现在本地缓存，然后写入目标文件","slug":"Hdfs结构性能分析及读写流程","published":1,"updated":"2018-08-16T15:48:44.374Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloj0llf0015ykpbxzgr3v4u"},{"title":"Hive建表及sql相关","date":"2018-08-11T02:31:24.062Z","toc":true,"_content":"\n[TOC]\n\n![](https://ws1.sinaimg.cn/large/0069RVTdgy1fu5k3varq8j31880g8js9.jpg)\n\n\n\nhive主要是做离线日志分析的，不是为了做单行的事务控制的数据\n新版hive也支持单行数据的读取，但是效率非常低，所以也没有什么updata语句\n\n<!-- more -->\n\n\nhdfs的数据是放在hdfs里面的，表的描述的结构元数据信息是放在mysql里面\nhdfs中数据的信息在以下类似目录\n**/user/hive/warehouse/thishive.db/book/country=japan**\n\n可以在hive的客户端直接敲用hdfs的命令查看到\n```\nhdfs dfs -ls /hive目录\n```\n\n## 本地模式\n\nset hive.exec.mode.local.auto=true;\n\n## 建表(默认是内部表)\n\n```sql\ncreate table inner_table(id bigint, account string, income double, expenses double, time string) row format delimited fields terminated by '\\t';\n```\n\n### 建分区表\n```sql\ncreate table outter_table(id bigint, account string, income double, expenses double, time string) partitioned by (logdate string) row format delimited fields terminated by '\\t';\n```\n\n### 建外部表\n\n```sql\ncreate external table td_ext(id bigint, account string, income double, expenses double, time string) row format delimited fields terminated by '\\t' location '/td_ext';\n```\n\nlocaltion是表示存放的位置\n\n## 复制表\n\n```\ncreate  table 表1 like 表2 ;\n```\n\n将表2的结构复制到表1\n将文件的数据导入到表中\n\n## 导入数据到表中\n\n   给表导入数据（若是分区表，则导入的时候需要加partition(#####)）\n\n```bash\nload data local inpath '/home/hadoop/mylog.log' into table 表名 partition(datestr='2013-09-18') ;\n```\n\n如果是导入本地文件，需要加参数local，如果是hdfs上的话，则不加\n\n## 导出hive表中数据\n\n```\ninsert overwrite local directory '/home/hadoop/student.txt'  select * from 表名;\n```\n\n> 不加local表示导出到hdfs\n\n## 外部表和内部表的区别\n\ndrop table 外部表； 只会将外部表的结构 元数据信息删除，而不会删除外表的数据\ndrop table 内部表；会将内部表的结构元数据信息及其数据信息全部删除\n\n# 保存select查询结果的几种方式：\n\n```\n1、将查询结果保存到一张新的hive表中\n\ncreate table t_tmp\nas\nselect * from t_p;\n\n2、将查询结果保存到一张已经存在的hive表中\n\ninsert into  table t_tmp \nselect * from t_p;\n\n3、将查询结果保存到指定的文件目录（可以是本地，也可以是hdfs）\n\n本地\ninsert overwrite local directory '/home/hadoop/student.txt'\n\nselect * from student;\n\n导入到mysql\ninsert overwrite directory '/aaa/test'\nselect * from t_p;\n\n\n\n```\n\n## 分区表\n\n普通表和分区表区别：有大量数据增加的需要建分区表\n分区的字段会自动加在表结构上\n\n这个是将导入到fruit的分区里面\n\n```bash\nload data local inpath '/home/bigdata/food.txt' overwrite into table book partition (type='fruit')；\n```\n\n\n在hdfs里面，分区表会存在多个不同的目录，但是在查询的时候，还是将多个分区表的信息融入到一个表中\n\n## 使用\n\n如果是使用overwrite命令，必须加stored as textfile；\n\n### 小操作\n\n以下资源来自网络（若有不合适，请联系我）\n\n### students.txt\n\n```\n95001,李勇,男,20,CS\n95002,刘晨,女,19,IS\n95003,王敏,女,22,MA\n95004,张立,男,19,IS\n95005,刘刚,男,18,MA\n95006,孙庆,男,23,CS\n95007,易思玲,女,19,MA\n95008,李娜,女,18,CS\n95009,梦圆圆,女,18,MA\n95010,孔小涛,男,19,CS\n95011,包小柏,男,18,MA\n95012,孙花,女,20,CS\n95013,冯伟,男,21,CS\n95014,王小丽,女,19,CS\n95015,王君,男,18,MA\n95016,钱国,男,21,MA\n95017,王风娟,女,18,IS\n95018,王一,女,19,IS\n95019,邢小丽,女,19,IS\n95020,赵钱,男,21,IS\n95021,周二,男,17,MA\n95022,郑明,男,20,MA\n```\n\n### sc.txt\n\n```\n95001,1,81\n95001,2,85\n95001,3,88\n95001,4,70\n95002,2,90\n95002,3,80\n95002,4,71\n95002,5,60\n95003,1,82\n95003,3,90\n95003,5,100\n95004,1,80\n95004,2,92\n95004,4,91\n95004,5,70\n95005,1,70\n95005,2,92\n95005,3,99\n95005,6,87\n95006,1,72\n95006,2,62\n95006,3,100\n95006,4,59\n95006,5,60\n95006,6,98\n95007,3,68\n95007,4,91\n95007,5,94\n95007,6,78\n95008,1,98\n95008,3,89\n95008,6,91\n95009,2,81\n95009,4,89\n95009,6,100\n95010,2,98\n95010,5,90\n95010,6,80\n95011,1,81\n95011,2,91\n95011,3,81\n95011,4,86\n95012,1,81\n95012,3,78\n95012,4,85\n95012,6,98\n95013,1,98\n95013,2,58\n95013,4,88\n95013,5,93\n95014,1,91\n95014,2,100\n95014,4,98\n95015,1,91\n95015,3,59\n95015,4,100\n95015,6,95\n95016,1,92\n95016,2,99\n95016,4,82\n95017,4,82\n95017,5,100\n95017,6,58\n95018,1,95\n95018,2,100\n95018,3,67\n95018,4,78\n95019,1,77\n95019,2,90\n95019,3,91\n95019,4,67\n95019,5,87\n95020,1,66\n95020,2,99\n95020,5,93\n95021,2,93\n95021,5,91\n95021,6,99\n95022,3,69\n95022,4,93\n95022,5,82\n95022,6,100\n```\n\n\n\n### course.txt\n\n```\n1,数据库\n2,数学\n3,信息系统\n4,操作系统\n5,数据结构\n6,数据处理\n```\n\n### 建表\n\n```sql\ncreate table student(Sno int,Sname string,Sex string,Sage int,Sdept string)row format delimited fields terminated by ','stored as textfile;\ncreate table course(Cno int,Cname string) row format delimited fields terminated by ',' stored as textfile;\ncreate table sc(Sno int,Cno int,Grade int)row format delimited fields terminated by ',' stored as textfile;\n\nload data local inpath '/home/bigdata/apps/hive/hivedata/students.txt' overwrite into table student;\nload data local inpath '/home/bigdata/apps/hive/hivedata/sc.txt' overwrite into table sc;\nload data local inpath '/home/bigdata/apps/hive/hivedata/course.txt' overwrite into table course;\n```\n### sql需求\n\n```sql\n查询全体学生的学号与姓名\n　　hive> select Sno,Sname from student;\n\n查询选修了课程的学生姓名\n　　hive> select distinct Sname from student inner join sc on student.Sno=Sc.Sno;\n\n----hive的group by 和集合函数\n\n查询学生的总人数\n　　hive> select count(distinct Sno)count from student;\n\n计算1号课程的学生平均成绩\n　　hive> select avg(distinct Grade) from sc where Cno=1;\n查询各科成绩平均分\n\t\thive> select Cno,avg(Grade) from sc group by Cno;  \n查询选修1号课程的学生最高分数\n　　select Grade from sc where Cno=1 sort by Grade desc limit 1; \n(注意比较:select * from sc where Cno=1 sort by Grade\n\t\t  select Grade from sc where Cno=1 order by Grade)     \n　　   \n　　\n求各个课程号及相应的选课人数 \n　　hive> select Cno,count(1) from sc group by Cno;\n\n\n查询选修了3门以上的课程的学生学号\n　　hive> select Sno from (select Sno,count(Cno) CountCno from sc group by Sno)a where a.CountCno>3;\n或　hive> select Sno from sc group by Sno having count(Cno)>3; \n\n----hive的Order By/Sort By/Distribute By\n　　Order By ，在strict 模式下（hive.mapred.mode=strict),order by 语句必须跟着limit语句，但是在nonstrict下就不是必须的，这样做的理由是必须有一个reduce对最终的结果进行排序，如果最后输出的行数过多，一个reduce需要花费很长的时间。\n\n查询学生信息，结果按学号全局有序\n　　hive> set hive.mapred.mode=strict;   <默认nonstrict>\nhive> select Sno from student order by Sno;\nFAILED: Error in semantic analysis: 1:33 In strict mode, if ORDER BY is specified, LIMIT must also be specified. Error encountered near token 'Sno'\n　　Sort By，它通常发生在每一个redcue里，“order by” 和“sort by”的区别在于，前者能给保证输出都是有顺序的，而后者如果有多个reduce的时候只是保证了输出的部分有序。set mapred.reduce.tasks=<number>在sort by可以指定，在用sort by的时候，如果没有指定列，它会随机的分配到不同的reduce里去。distribute by 按照指定的字段对数据进行划分到不同的输出reduce中 \n　　此方法会根据性别划分到不同的reduce中 ，然后按年龄排序并输出到不同的文件中。\n\n查询学生信息，按性别分区，在分区内按年龄有序\n　　hive> set mapred.reduce.tasks=2;\n　　hive> insert overwrite local directory '/home/hadoop/out' \nselect * from student distribute by Sex sort by Sage;\n\n----Join查询,join只支持等值连接 \n查询每个学生及其选修课程的情况\n　　hive> select student.*,sc.* from student join sc on (student.Sno =sc.Sno);\n查询学生的得分情况。\n　　hive>select student.Sname,course.Cname,sc.Grade from student join sc on student.Sno=sc.Sno join course on sc.cno=course.cno;\n\n查询选修2号课程且成绩在90分以上的所有学生。\n　　hive> select student.Sname,sc.Grade from student join sc on student.Sno=sc.Sno \nwhere  sc.Cno=2 and sc.Grade>90;\n　　\n----LEFT，RIGHT 和 FULL OUTER JOIN ,inner join, left semi join\n查询所有学生的信息，如果在成绩表中有成绩，则输出成绩表中的课程号\n　　hive> select student.Sname,sc.Cno from student left outer join sc on student.Sno=sc.Sno;\n　　如果student的sno值对应的sc在中没有值，则会输出student.Sname null.如果用right out join会保留右边的值，左边的为null。\n　　Join 发生在WHERE 子句之前。如果你想限制 join 的输出，应该在 WHERE 子句中写过滤条件——或是在join 子句中写。\n　　\n----LEFT SEMI JOIN  Hive 当前没有实现 IN/EXISTS 子查询，可以用 LEFT SEMI JOIN 重写子查询语句\n\n重写以下子查询为LEFT SEMI JOIN\n  SELECT a.key, a.value\n  FROM a\n  WHERE a.key exist in\n   (SELECT b.key\n    FROM B);\n可以被重写为：\n   SELECT a.key, a.val\n   FROM a LEFT SEMI JOIN b on (a.key = b.key)\n\n查询与“刘晨”在同一个系学习的学生\n　　hive> select s1.Sname from student s1 left semi join student s2 on s1.Sdept=s2.Sdept and s2.Sname='刘晨';\n\n注意比较：\nselect * from student s1 left join student s2 on s1.Sdept=s2.Sdept and s2.Sname='刘晨';\nselect * from student s1 right join student s2 on s1.Sdept=s2.Sdept and s2.Sname='刘晨';\nselect * from student s1 inner join student s2 on s1.Sdept=s2.Sdept and s2.Sname='刘晨';\nselect * from student s1 left semi join student s2 on s1.Sdept=s2.Sdept and s2.Sname='刘晨';\nselect s1.Sname from student s1 right semi join student s2 on s1.Sdept=s2.Sdept and s2.Sname='刘晨';\n```\n\n","source":"_posts/Hive sql相关.md","raw":"---\ntitle: Hive建表及sql相关\ndate: 2018年08月06日 22时15分52秒\ntags: [Hive,使用]\ncategories: 大数据\ntoc: true\n---\n\n[TOC]\n\n![](https://ws1.sinaimg.cn/large/0069RVTdgy1fu5k3varq8j31880g8js9.jpg)\n\n\n\nhive主要是做离线日志分析的，不是为了做单行的事务控制的数据\n新版hive也支持单行数据的读取，但是效率非常低，所以也没有什么updata语句\n\n<!-- more -->\n\n\nhdfs的数据是放在hdfs里面的，表的描述的结构元数据信息是放在mysql里面\nhdfs中数据的信息在以下类似目录\n**/user/hive/warehouse/thishive.db/book/country=japan**\n\n可以在hive的客户端直接敲用hdfs的命令查看到\n```\nhdfs dfs -ls /hive目录\n```\n\n## 本地模式\n\nset hive.exec.mode.local.auto=true;\n\n## 建表(默认是内部表)\n\n```sql\ncreate table inner_table(id bigint, account string, income double, expenses double, time string) row format delimited fields terminated by '\\t';\n```\n\n### 建分区表\n```sql\ncreate table outter_table(id bigint, account string, income double, expenses double, time string) partitioned by (logdate string) row format delimited fields terminated by '\\t';\n```\n\n### 建外部表\n\n```sql\ncreate external table td_ext(id bigint, account string, income double, expenses double, time string) row format delimited fields terminated by '\\t' location '/td_ext';\n```\n\nlocaltion是表示存放的位置\n\n## 复制表\n\n```\ncreate  table 表1 like 表2 ;\n```\n\n将表2的结构复制到表1\n将文件的数据导入到表中\n\n## 导入数据到表中\n\n   给表导入数据（若是分区表，则导入的时候需要加partition(#####)）\n\n```bash\nload data local inpath '/home/hadoop/mylog.log' into table 表名 partition(datestr='2013-09-18') ;\n```\n\n如果是导入本地文件，需要加参数local，如果是hdfs上的话，则不加\n\n## 导出hive表中数据\n\n```\ninsert overwrite local directory '/home/hadoop/student.txt'  select * from 表名;\n```\n\n> 不加local表示导出到hdfs\n\n## 外部表和内部表的区别\n\ndrop table 外部表； 只会将外部表的结构 元数据信息删除，而不会删除外表的数据\ndrop table 内部表；会将内部表的结构元数据信息及其数据信息全部删除\n\n# 保存select查询结果的几种方式：\n\n```\n1、将查询结果保存到一张新的hive表中\n\ncreate table t_tmp\nas\nselect * from t_p;\n\n2、将查询结果保存到一张已经存在的hive表中\n\ninsert into  table t_tmp \nselect * from t_p;\n\n3、将查询结果保存到指定的文件目录（可以是本地，也可以是hdfs）\n\n本地\ninsert overwrite local directory '/home/hadoop/student.txt'\n\nselect * from student;\n\n导入到mysql\ninsert overwrite directory '/aaa/test'\nselect * from t_p;\n\n\n\n```\n\n## 分区表\n\n普通表和分区表区别：有大量数据增加的需要建分区表\n分区的字段会自动加在表结构上\n\n这个是将导入到fruit的分区里面\n\n```bash\nload data local inpath '/home/bigdata/food.txt' overwrite into table book partition (type='fruit')；\n```\n\n\n在hdfs里面，分区表会存在多个不同的目录，但是在查询的时候，还是将多个分区表的信息融入到一个表中\n\n## 使用\n\n如果是使用overwrite命令，必须加stored as textfile；\n\n### 小操作\n\n以下资源来自网络（若有不合适，请联系我）\n\n### students.txt\n\n```\n95001,李勇,男,20,CS\n95002,刘晨,女,19,IS\n95003,王敏,女,22,MA\n95004,张立,男,19,IS\n95005,刘刚,男,18,MA\n95006,孙庆,男,23,CS\n95007,易思玲,女,19,MA\n95008,李娜,女,18,CS\n95009,梦圆圆,女,18,MA\n95010,孔小涛,男,19,CS\n95011,包小柏,男,18,MA\n95012,孙花,女,20,CS\n95013,冯伟,男,21,CS\n95014,王小丽,女,19,CS\n95015,王君,男,18,MA\n95016,钱国,男,21,MA\n95017,王风娟,女,18,IS\n95018,王一,女,19,IS\n95019,邢小丽,女,19,IS\n95020,赵钱,男,21,IS\n95021,周二,男,17,MA\n95022,郑明,男,20,MA\n```\n\n### sc.txt\n\n```\n95001,1,81\n95001,2,85\n95001,3,88\n95001,4,70\n95002,2,90\n95002,3,80\n95002,4,71\n95002,5,60\n95003,1,82\n95003,3,90\n95003,5,100\n95004,1,80\n95004,2,92\n95004,4,91\n95004,5,70\n95005,1,70\n95005,2,92\n95005,3,99\n95005,6,87\n95006,1,72\n95006,2,62\n95006,3,100\n95006,4,59\n95006,5,60\n95006,6,98\n95007,3,68\n95007,4,91\n95007,5,94\n95007,6,78\n95008,1,98\n95008,3,89\n95008,6,91\n95009,2,81\n95009,4,89\n95009,6,100\n95010,2,98\n95010,5,90\n95010,6,80\n95011,1,81\n95011,2,91\n95011,3,81\n95011,4,86\n95012,1,81\n95012,3,78\n95012,4,85\n95012,6,98\n95013,1,98\n95013,2,58\n95013,4,88\n95013,5,93\n95014,1,91\n95014,2,100\n95014,4,98\n95015,1,91\n95015,3,59\n95015,4,100\n95015,6,95\n95016,1,92\n95016,2,99\n95016,4,82\n95017,4,82\n95017,5,100\n95017,6,58\n95018,1,95\n95018,2,100\n95018,3,67\n95018,4,78\n95019,1,77\n95019,2,90\n95019,3,91\n95019,4,67\n95019,5,87\n95020,1,66\n95020,2,99\n95020,5,93\n95021,2,93\n95021,5,91\n95021,6,99\n95022,3,69\n95022,4,93\n95022,5,82\n95022,6,100\n```\n\n\n\n### course.txt\n\n```\n1,数据库\n2,数学\n3,信息系统\n4,操作系统\n5,数据结构\n6,数据处理\n```\n\n### 建表\n\n```sql\ncreate table student(Sno int,Sname string,Sex string,Sage int,Sdept string)row format delimited fields terminated by ','stored as textfile;\ncreate table course(Cno int,Cname string) row format delimited fields terminated by ',' stored as textfile;\ncreate table sc(Sno int,Cno int,Grade int)row format delimited fields terminated by ',' stored as textfile;\n\nload data local inpath '/home/bigdata/apps/hive/hivedata/students.txt' overwrite into table student;\nload data local inpath '/home/bigdata/apps/hive/hivedata/sc.txt' overwrite into table sc;\nload data local inpath '/home/bigdata/apps/hive/hivedata/course.txt' overwrite into table course;\n```\n### sql需求\n\n```sql\n查询全体学生的学号与姓名\n　　hive> select Sno,Sname from student;\n\n查询选修了课程的学生姓名\n　　hive> select distinct Sname from student inner join sc on student.Sno=Sc.Sno;\n\n----hive的group by 和集合函数\n\n查询学生的总人数\n　　hive> select count(distinct Sno)count from student;\n\n计算1号课程的学生平均成绩\n　　hive> select avg(distinct Grade) from sc where Cno=1;\n查询各科成绩平均分\n\t\thive> select Cno,avg(Grade) from sc group by Cno;  \n查询选修1号课程的学生最高分数\n　　select Grade from sc where Cno=1 sort by Grade desc limit 1; \n(注意比较:select * from sc where Cno=1 sort by Grade\n\t\t  select Grade from sc where Cno=1 order by Grade)     \n　　   \n　　\n求各个课程号及相应的选课人数 \n　　hive> select Cno,count(1) from sc group by Cno;\n\n\n查询选修了3门以上的课程的学生学号\n　　hive> select Sno from (select Sno,count(Cno) CountCno from sc group by Sno)a where a.CountCno>3;\n或　hive> select Sno from sc group by Sno having count(Cno)>3; \n\n----hive的Order By/Sort By/Distribute By\n　　Order By ，在strict 模式下（hive.mapred.mode=strict),order by 语句必须跟着limit语句，但是在nonstrict下就不是必须的，这样做的理由是必须有一个reduce对最终的结果进行排序，如果最后输出的行数过多，一个reduce需要花费很长的时间。\n\n查询学生信息，结果按学号全局有序\n　　hive> set hive.mapred.mode=strict;   <默认nonstrict>\nhive> select Sno from student order by Sno;\nFAILED: Error in semantic analysis: 1:33 In strict mode, if ORDER BY is specified, LIMIT must also be specified. Error encountered near token 'Sno'\n　　Sort By，它通常发生在每一个redcue里，“order by” 和“sort by”的区别在于，前者能给保证输出都是有顺序的，而后者如果有多个reduce的时候只是保证了输出的部分有序。set mapred.reduce.tasks=<number>在sort by可以指定，在用sort by的时候，如果没有指定列，它会随机的分配到不同的reduce里去。distribute by 按照指定的字段对数据进行划分到不同的输出reduce中 \n　　此方法会根据性别划分到不同的reduce中 ，然后按年龄排序并输出到不同的文件中。\n\n查询学生信息，按性别分区，在分区内按年龄有序\n　　hive> set mapred.reduce.tasks=2;\n　　hive> insert overwrite local directory '/home/hadoop/out' \nselect * from student distribute by Sex sort by Sage;\n\n----Join查询,join只支持等值连接 \n查询每个学生及其选修课程的情况\n　　hive> select student.*,sc.* from student join sc on (student.Sno =sc.Sno);\n查询学生的得分情况。\n　　hive>select student.Sname,course.Cname,sc.Grade from student join sc on student.Sno=sc.Sno join course on sc.cno=course.cno;\n\n查询选修2号课程且成绩在90分以上的所有学生。\n　　hive> select student.Sname,sc.Grade from student join sc on student.Sno=sc.Sno \nwhere  sc.Cno=2 and sc.Grade>90;\n　　\n----LEFT，RIGHT 和 FULL OUTER JOIN ,inner join, left semi join\n查询所有学生的信息，如果在成绩表中有成绩，则输出成绩表中的课程号\n　　hive> select student.Sname,sc.Cno from student left outer join sc on student.Sno=sc.Sno;\n　　如果student的sno值对应的sc在中没有值，则会输出student.Sname null.如果用right out join会保留右边的值，左边的为null。\n　　Join 发生在WHERE 子句之前。如果你想限制 join 的输出，应该在 WHERE 子句中写过滤条件——或是在join 子句中写。\n　　\n----LEFT SEMI JOIN  Hive 当前没有实现 IN/EXISTS 子查询，可以用 LEFT SEMI JOIN 重写子查询语句\n\n重写以下子查询为LEFT SEMI JOIN\n  SELECT a.key, a.value\n  FROM a\n  WHERE a.key exist in\n   (SELECT b.key\n    FROM B);\n可以被重写为：\n   SELECT a.key, a.val\n   FROM a LEFT SEMI JOIN b on (a.key = b.key)\n\n查询与“刘晨”在同一个系学习的学生\n　　hive> select s1.Sname from student s1 left semi join student s2 on s1.Sdept=s2.Sdept and s2.Sname='刘晨';\n\n注意比较：\nselect * from student s1 left join student s2 on s1.Sdept=s2.Sdept and s2.Sname='刘晨';\nselect * from student s1 right join student s2 on s1.Sdept=s2.Sdept and s2.Sname='刘晨';\nselect * from student s1 inner join student s2 on s1.Sdept=s2.Sdept and s2.Sname='刘晨';\nselect * from student s1 left semi join student s2 on s1.Sdept=s2.Sdept and s2.Sname='刘晨';\nselect s1.Sname from student s1 right semi join student s2 on s1.Sdept=s2.Sdept and s2.Sname='刘晨';\n```\n\n","slug":"Hive sql相关","published":1,"updated":"2018-08-30T04:00:08.449Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloj0llg0019ykpb5c4es12n"},{"title":"Hive分桶表,分区表简单分析","date":"2018-08-11T03:21:32.532Z","toc":true,"_content":"\n[TOC]\n\n![](https://ws2.sinaimg.cn/large/0069RVTdgy1fu81tzpekzj305z06j3yc.jpg)\n\n对于每一个表或者是分区，Hive 可以进一步组织成桶，也就是说桶是更为细粒度的数据范围划分。Hive 是针对某一列进行分桶。Hive 采用对列值哈希，然后除以桶的个数求余的方式决定该条记录存放在哪个桶中。分桶的好处是可以获得更高的查询处理效率。使取样更高效。\n\n分桶依赖于yarn的所以分桶的时候需要启动yarn\n\n<!-- more -->\n\n# 分桶表创建\n\n\\#设置变量,设置分桶为true, 设置reduce数量是分桶的数量个数\n\n```sql\nset hive.enforce.bucketing = true;\nset mapreduce.job.reduces=4;\n```\n\n创建表\n\n```sql\ncreate table person_buck(id int,name string,sex string,age int)\nclustered by(id) \nsorted by(id DESC)\ninto 4 buckets\nrow format delimited\nfields terminated by ',';\n```\n\n\n\n```\n开会往创建的分桶表插入数据(插入数据需要是已分桶, 且排序的)\n可以使用distribute by(id) sort by(id asc)  或是排序和分桶的字段相同的时候使用Cluster by(字段)\n注意使用cluster by  就等同于分桶+排序(sort)\n```\n\n\n\n```sql\ninsert into table person_buck select id,name,sex,age from student distribute by(id) sort by(id asc);\n```\n\n\n\n\n\n\n\n## 分桶模式的参数\n\n设置变量,设置分桶为true, 设置reduce数量是分桶的数量个数\n\nset hive.enforce.bucketing = true;\n\n不设置reduce的数量会使用默认的数量，默认的数量会和分桶的数量不一致，则不能分出正确分桶\n\nset mapreduce.job.reduces=4;\n\n本地模式\n\nset hive.exec.mode.local.auto=true\n\n动态分区\n\n--设置为true表示开启动态分区功能（默认为false）\n\nset hive.exec.dynamic.partition=true;\n\n--设置为nonstrict,表示允许所有分区都是动态的（默认为strict）\n\nset hive.exec.dynamic.partition.mode=nonstrict;\n\n\n\n## Update与分桶表关系\n\nHive对使用Update功能的表有特定的语法要求, 语法要求如下:\n(1)要执行Update的表中, 建表时必须带有buckets(分桶)属性\n(2)要执行Update的表中, 需要指定格式,其余格式目前赞不支持, 如:parquet格式, 目前只支持ORCFileformat和AcidOutputFormat\n(3)要执行Update的表中, 建表时必须指定参数('transactional' = true);\n举例:\n\n```\ncreate table student (id bigint,name string) clustered by (name) into 2 buckets stored as orc TBLPROPERTIES('transactional'='true');\n```\n\n\n## 更新语句:\n\n```\nupdate student set id='444' where name='tom';\n```\n\n\n\n# 分桶表测试\n\n这个例子就是将分区的字段进行hash散列将数据分桶到分桶数个文件中去\n\n导入一个文件到分桶表里面\n\n##  创建表\n\n```sql\ncreate table t_buk(id int,name string) clustered by(id)  sorted by(id DESC) into 4 buckets row format delimited``fields terminated by ',';\n```\n\n## 创建数据\n\n**cd /usr/hive/hivedata/**\n\n**vim buk.txt** \n\n```\n1,数据库\n2,数学\n3,信息系统\n4,操作系统\n5,数据结构\n6,数据no\n7,数据other\n8,数据time\n9,数据操作\n10,数据挖掘\n11,数据挖机\n12,数据信号\n```\n\n\n\n## 读取本地文件\n\n```\nload data local inpath '/usr/hive/hivedata/buk.txt' into table t_buk;\n```\n\nload方式这样导入数据到一个分桶表里面，是不会作出分桶的操作的，不会分成桶数个文件，还是一个文件在hdfs系统中\n\n# 注意\n\n1. 要想导入到数据到分桶表里面，必须是一个是已经是分桶的数据，比如已经形成了分桶数据个文件，才可以导入到分桶表里面，导数据的时候是不会将原来的数据形式变成分桶的数据形式\n\n# hive分桶表的使用场景\n\n所以一般是在一个表中查询了数据然后在塞入到一个分区表里面，查询是走mapReduce程序，然后将数据按分桶表照分桶的策略写入到分桶表中\n\n形如\n\n```sql\ninsert into t_buk select * from other … …;\n```\n\n后面的\n\n清除数据\n\n```sql\ntruncate table t_buk;\n```\n\n创建一个表来读取数据\n\n```sql\ncreate table t_p(id int,name string)\nrow format delimited\nfields terminated by ',';\n\nload data local inpath '/usr/hive/hivedata/buk.txt' into table t_p;\n```\n\n insert into table t_buk select id,name from t_p; \n\n insert overwirte 也可以\n\n## 结果如下\n\n```\nNumber of reduce tasks is set to 0 since there's no reduce operator\nINFO  : number of splits:1\nINFO  : Submitting tokens for job: job_1502537431423_0011\nINFO  : The url to track the job: http://bigdata1:8088/proxy/application_1502537431423_0011/\nINFO  : Starting Job = job_1502537431423_0011, Tracking URL = http://bigdata1:8088/proxy/application_1502537431423_0011/\nINFO  : Kill Command = /home/bigdata/apps/hadoop/bin/hadoop job  -kill job_1502537431423_0011\nINFO  : Hadoop job information for Stage-1: number of mappers: 1; number of reducers: 0\nINFO  : 2017-08-15 21:12:15,669 Stage-1 map = 0%,  reduce = 0%\nINFO  : 2017-08-15 21:12:32,386 Stage-1 map = 100%,  reduce = 0%, Cumulative CPU 1.27 sec\nINFO  : MapReduce Total cumulative CPU time: 1 seconds 270 msec\nINFO  : Ended Job = job_1502537431423_0011\nINFO  : Stage-4 is selected by condition resolver.\nINFO  : Stage-3 is filtered out by condition resolver.\nINFO  : Stage-5 is filtered out by condition resolver.\nINFO  : Moving data to: hdfs://bigdata1:9000/user/hive/warehouse/t_buk/.hive-staging_hive_2017-08-15_21-12-02_490_4088487413275551800-3/-ext-10000 from hdfs://bigdata1:9000/user/hive/warehouse/t_buk/.hive-staging_hive_2017-08-15_21-12-02_490_4088487413275551800-3/-ext-10002\nINFO  : Loading data to table default.t_buk from hdfs://bigdata1:9000/user/hive/warehouse/t_buk/.hive-staging_hive_2017-08-15_21-12-02_490_4088487413275551800-3/-ext-10000\nINFO  : Table default.t_buk stats: [numFiles=1, numRows=12, totalSize=167, rawDataSize=155]\n```\n\n查看hdfs管理页面 50070\n\n![](https://ws2.sinaimg.cn/large/006tNbRwgy1fu7ufetxnpj30yw06fmx9.jpg)\n\n 还是只有一文件，表示分桶不成功，没设reduce数量，使用默认的数量1，和我们期望分桶数量不一致\n\n# 设置分桶参数\n\n因为没有启动模式的开关，如下\n\n设置变量,设置分桶为true, 设置reduce数量是分桶的数量个数\n\n```\nset hive.enforce.bucketing = true;\nset mapreduce.job.reduces=4;\nset hive.exec.mode.local.auto=true;\nset hive.exec.dynamic.partition=true;\nset hive.exec.dynamic.partition.mode=nonstrict;\n```\n\n## 重新创建表\n\n\n\n可以通过set hive.enforce.bucketing查看是否设置成功\n\n先查看sort by (id)；\n\n根据4个reduce来局部有序，每个reduce有序，但是从哪儿截断每个reduce并不确定\n\n```\nselect id,name from t_p sort by (id);\nINFO  : Number of reduce tasks not specified. Defaulting to jobconf value of: 4\nINFO  : In order to change the average load for a reducer (in bytes):\nINFO  :   set hive.exec.reducers.bytes.per.reducer=<number>\nINFO  : In order to limit the maximum number of reducers:\nINFO  :   set hive.exec.reducers.max=<number>\nINFO  : In order to set a constant number of reducers:\nINFO  :   set mapreduce.job.reduces=<number>\nINFO  : number of splits:1\nINFO  : Submitting tokens for job: job_1502537431423_0012\nINFO  : The url to track the job: http://bigdata1:8088/proxy/application_1502537431423_0012/\nINFO  : Starting Job = job_1502537431423_0012, Tracking URL = http://bigdata1:8088/proxy/application_1502537431423_0012/\nINFO  : Kill Command = /home/bigdata/apps/hadoop/bin/hadoop job  -kill job_1502537431423_0012\nINFO  : Hadoop job information for Stage-1: number of mappers: 1; number of reducers: 4\nINFO  : 2017-08-15 21:26:14,284 Stage-1 map = 0%,  reduce = 0%\nINFO  : 2017-08-15 21:26:24,633 Stage-1 map = 100%,  reduce = 0%, Cumulative CPU 2.29 sec\nINFO  : 2017-08-15 21:26:38,745 Stage-1 map = 100%,  reduce = 50%, Cumulative CPU 6.99 sec\nINFO  : 2017-08-15 21:26:43,887 Stage-1 map = 100%,  reduce = 67%, Cumulative CPU 6.99 sec\nINFO  : 2017-08-15 21:26:46,970 Stage-1 map = 100%,  reduce = 75%, Cumulative CPU 9.06 sec\nINFO  : 2017-08-15 21:26:50,081 Stage-1 map = 100%,  reduce = 100%, Cumulative CPU 10.8 sec\nINFO  : MapReduce Total cumulative CPU time: 10 seconds 800 msec\nINFO  : Ended Job = job_1502537431423_0012\n+-----+----------+--+\n| id  |   name   |\n+-----+----------+--+\n| 4   | 操作系统     |\n| 8   | 数据time   |\n| 12  | 数据信号     |\n| 2   | 数学       |\n| 6   | 数据no     |\n| 1   | 数据库      |\n| 3   | 信息系统     |\n| 5   | 数据结构     |\n| 10  | 数据挖掘     |\n| 11  | 数据挖机     |\n| 7   | 数据other  |\n| 9   | 数据操作     |\n+-----+----------+--+\n```\n\n\n\n再试一次select 插入（将t_buk truncate也可，也可使用overwrite关键字）\n\n `insert overwrite table t_buk select id,name from t_p cluster by (id);`\n\n再查看hdfs ui页面50070\n\n![](https://ws2.sinaimg.cn/large/006tNbRwgy1fu7uk05fz5j30x70a8mxm.jpg)\n\n## 再分别查看这几个文件\n\n```\n$HADOOP_HOME/bin/hadoop fs -cat /user/hive/warehouse/t_buk/000000_0\n$HADOOP_HOME/bin/hadoop fs -cat /user/hive/warehouse/t_buk/000001_0  \n$HADOOP_HOME/bin/hadoop fs -cat /user/hive/warehouse/t_buk/000002_0  \n$HADOOP_HOME/bin/hadoop fs -cat /user/hive/warehouse/t_buk/000003_0\n```\n\n## 得到结果\n\n```\n[bigdata@master hivedata]$  hadoop fs -cat /user/hive/warehouse/t_buk/000000_0  \n4,操作系统\n8,数据time\n12,数据信号\n[bigdata@master hivedata]$  hadoop fs -cat /user/hive/warehouse/t_buk/000001_0  \n1,数据库\n5,数据结构\n9,数据操作\n[bigdata@master hivedata]$  hadoop fs -cat /user/hive/warehouse/t_buk/000002_0  \n2,数学\n6,数据no\n10,数据挖掘\n[bigdata@master hivedata]$  hadoop fs -cat /user/hive/warehouse/t_buk/000003_0\n3,信息系统\n7,数据other\n11,数据挖机\n```\n\n# 分桶表疑问\n\n## 为什么每个桶里面的数据条数不一样\n\n```\nhash散列的时候数据可能将数据有的分的多，有的分的少\n```\n\ncluster by （id） 根据id分桶，桶内根据id排序，相当于 distribute by 和 sort by的集合，只是指定的字段都是同一个\n用两个组合更加强大，分桶字段排序字段可以设置为不同\n\n# 分桶表的意义：\n\n提高join操作的效率案例\n\n> 如果a表和b表已经是分桶表，而且分桶的字段都是是id字段\n> 做这个join操作是，还需要做笛卡尔积吗？ 这样不需要，因为同一id哈希后的数据是一致的，这就是分桶表存在的意义\n\n# 注意\n\n1. 在分桶表中使用order by 是非常不建议的，这样会设置成一个reduce，强行将数据写入，一个reduce的内存会爆炸\n2. 使用cluster by  就等同于分桶+排序(sort) \n\n insert overwrite table student_buck  select * from student cluster by(Sno) sort by(Sage);  报错,cluster 和 sort 不能共存\n\n","source":"_posts/Hive分桶表相关.md","raw":"---\ntitle: Hive分桶表,分区表简单分析\ndate: 2018年08月06日 22时15分52秒\ntags: [Hive]\ncategories: 大数据\ntoc: true\n---\n\n[TOC]\n\n![](https://ws2.sinaimg.cn/large/0069RVTdgy1fu81tzpekzj305z06j3yc.jpg)\n\n对于每一个表或者是分区，Hive 可以进一步组织成桶，也就是说桶是更为细粒度的数据范围划分。Hive 是针对某一列进行分桶。Hive 采用对列值哈希，然后除以桶的个数求余的方式决定该条记录存放在哪个桶中。分桶的好处是可以获得更高的查询处理效率。使取样更高效。\n\n分桶依赖于yarn的所以分桶的时候需要启动yarn\n\n<!-- more -->\n\n# 分桶表创建\n\n\\#设置变量,设置分桶为true, 设置reduce数量是分桶的数量个数\n\n```sql\nset hive.enforce.bucketing = true;\nset mapreduce.job.reduces=4;\n```\n\n创建表\n\n```sql\ncreate table person_buck(id int,name string,sex string,age int)\nclustered by(id) \nsorted by(id DESC)\ninto 4 buckets\nrow format delimited\nfields terminated by ',';\n```\n\n\n\n```\n开会往创建的分桶表插入数据(插入数据需要是已分桶, 且排序的)\n可以使用distribute by(id) sort by(id asc)  或是排序和分桶的字段相同的时候使用Cluster by(字段)\n注意使用cluster by  就等同于分桶+排序(sort)\n```\n\n\n\n```sql\ninsert into table person_buck select id,name,sex,age from student distribute by(id) sort by(id asc);\n```\n\n\n\n\n\n\n\n## 分桶模式的参数\n\n设置变量,设置分桶为true, 设置reduce数量是分桶的数量个数\n\nset hive.enforce.bucketing = true;\n\n不设置reduce的数量会使用默认的数量，默认的数量会和分桶的数量不一致，则不能分出正确分桶\n\nset mapreduce.job.reduces=4;\n\n本地模式\n\nset hive.exec.mode.local.auto=true\n\n动态分区\n\n--设置为true表示开启动态分区功能（默认为false）\n\nset hive.exec.dynamic.partition=true;\n\n--设置为nonstrict,表示允许所有分区都是动态的（默认为strict）\n\nset hive.exec.dynamic.partition.mode=nonstrict;\n\n\n\n## Update与分桶表关系\n\nHive对使用Update功能的表有特定的语法要求, 语法要求如下:\n(1)要执行Update的表中, 建表时必须带有buckets(分桶)属性\n(2)要执行Update的表中, 需要指定格式,其余格式目前赞不支持, 如:parquet格式, 目前只支持ORCFileformat和AcidOutputFormat\n(3)要执行Update的表中, 建表时必须指定参数('transactional' = true);\n举例:\n\n```\ncreate table student (id bigint,name string) clustered by (name) into 2 buckets stored as orc TBLPROPERTIES('transactional'='true');\n```\n\n\n## 更新语句:\n\n```\nupdate student set id='444' where name='tom';\n```\n\n\n\n# 分桶表测试\n\n这个例子就是将分区的字段进行hash散列将数据分桶到分桶数个文件中去\n\n导入一个文件到分桶表里面\n\n##  创建表\n\n```sql\ncreate table t_buk(id int,name string) clustered by(id)  sorted by(id DESC) into 4 buckets row format delimited``fields terminated by ',';\n```\n\n## 创建数据\n\n**cd /usr/hive/hivedata/**\n\n**vim buk.txt** \n\n```\n1,数据库\n2,数学\n3,信息系统\n4,操作系统\n5,数据结构\n6,数据no\n7,数据other\n8,数据time\n9,数据操作\n10,数据挖掘\n11,数据挖机\n12,数据信号\n```\n\n\n\n## 读取本地文件\n\n```\nload data local inpath '/usr/hive/hivedata/buk.txt' into table t_buk;\n```\n\nload方式这样导入数据到一个分桶表里面，是不会作出分桶的操作的，不会分成桶数个文件，还是一个文件在hdfs系统中\n\n# 注意\n\n1. 要想导入到数据到分桶表里面，必须是一个是已经是分桶的数据，比如已经形成了分桶数据个文件，才可以导入到分桶表里面，导数据的时候是不会将原来的数据形式变成分桶的数据形式\n\n# hive分桶表的使用场景\n\n所以一般是在一个表中查询了数据然后在塞入到一个分区表里面，查询是走mapReduce程序，然后将数据按分桶表照分桶的策略写入到分桶表中\n\n形如\n\n```sql\ninsert into t_buk select * from other … …;\n```\n\n后面的\n\n清除数据\n\n```sql\ntruncate table t_buk;\n```\n\n创建一个表来读取数据\n\n```sql\ncreate table t_p(id int,name string)\nrow format delimited\nfields terminated by ',';\n\nload data local inpath '/usr/hive/hivedata/buk.txt' into table t_p;\n```\n\n insert into table t_buk select id,name from t_p; \n\n insert overwirte 也可以\n\n## 结果如下\n\n```\nNumber of reduce tasks is set to 0 since there's no reduce operator\nINFO  : number of splits:1\nINFO  : Submitting tokens for job: job_1502537431423_0011\nINFO  : The url to track the job: http://bigdata1:8088/proxy/application_1502537431423_0011/\nINFO  : Starting Job = job_1502537431423_0011, Tracking URL = http://bigdata1:8088/proxy/application_1502537431423_0011/\nINFO  : Kill Command = /home/bigdata/apps/hadoop/bin/hadoop job  -kill job_1502537431423_0011\nINFO  : Hadoop job information for Stage-1: number of mappers: 1; number of reducers: 0\nINFO  : 2017-08-15 21:12:15,669 Stage-1 map = 0%,  reduce = 0%\nINFO  : 2017-08-15 21:12:32,386 Stage-1 map = 100%,  reduce = 0%, Cumulative CPU 1.27 sec\nINFO  : MapReduce Total cumulative CPU time: 1 seconds 270 msec\nINFO  : Ended Job = job_1502537431423_0011\nINFO  : Stage-4 is selected by condition resolver.\nINFO  : Stage-3 is filtered out by condition resolver.\nINFO  : Stage-5 is filtered out by condition resolver.\nINFO  : Moving data to: hdfs://bigdata1:9000/user/hive/warehouse/t_buk/.hive-staging_hive_2017-08-15_21-12-02_490_4088487413275551800-3/-ext-10000 from hdfs://bigdata1:9000/user/hive/warehouse/t_buk/.hive-staging_hive_2017-08-15_21-12-02_490_4088487413275551800-3/-ext-10002\nINFO  : Loading data to table default.t_buk from hdfs://bigdata1:9000/user/hive/warehouse/t_buk/.hive-staging_hive_2017-08-15_21-12-02_490_4088487413275551800-3/-ext-10000\nINFO  : Table default.t_buk stats: [numFiles=1, numRows=12, totalSize=167, rawDataSize=155]\n```\n\n查看hdfs管理页面 50070\n\n![](https://ws2.sinaimg.cn/large/006tNbRwgy1fu7ufetxnpj30yw06fmx9.jpg)\n\n 还是只有一文件，表示分桶不成功，没设reduce数量，使用默认的数量1，和我们期望分桶数量不一致\n\n# 设置分桶参数\n\n因为没有启动模式的开关，如下\n\n设置变量,设置分桶为true, 设置reduce数量是分桶的数量个数\n\n```\nset hive.enforce.bucketing = true;\nset mapreduce.job.reduces=4;\nset hive.exec.mode.local.auto=true;\nset hive.exec.dynamic.partition=true;\nset hive.exec.dynamic.partition.mode=nonstrict;\n```\n\n## 重新创建表\n\n\n\n可以通过set hive.enforce.bucketing查看是否设置成功\n\n先查看sort by (id)；\n\n根据4个reduce来局部有序，每个reduce有序，但是从哪儿截断每个reduce并不确定\n\n```\nselect id,name from t_p sort by (id);\nINFO  : Number of reduce tasks not specified. Defaulting to jobconf value of: 4\nINFO  : In order to change the average load for a reducer (in bytes):\nINFO  :   set hive.exec.reducers.bytes.per.reducer=<number>\nINFO  : In order to limit the maximum number of reducers:\nINFO  :   set hive.exec.reducers.max=<number>\nINFO  : In order to set a constant number of reducers:\nINFO  :   set mapreduce.job.reduces=<number>\nINFO  : number of splits:1\nINFO  : Submitting tokens for job: job_1502537431423_0012\nINFO  : The url to track the job: http://bigdata1:8088/proxy/application_1502537431423_0012/\nINFO  : Starting Job = job_1502537431423_0012, Tracking URL = http://bigdata1:8088/proxy/application_1502537431423_0012/\nINFO  : Kill Command = /home/bigdata/apps/hadoop/bin/hadoop job  -kill job_1502537431423_0012\nINFO  : Hadoop job information for Stage-1: number of mappers: 1; number of reducers: 4\nINFO  : 2017-08-15 21:26:14,284 Stage-1 map = 0%,  reduce = 0%\nINFO  : 2017-08-15 21:26:24,633 Stage-1 map = 100%,  reduce = 0%, Cumulative CPU 2.29 sec\nINFO  : 2017-08-15 21:26:38,745 Stage-1 map = 100%,  reduce = 50%, Cumulative CPU 6.99 sec\nINFO  : 2017-08-15 21:26:43,887 Stage-1 map = 100%,  reduce = 67%, Cumulative CPU 6.99 sec\nINFO  : 2017-08-15 21:26:46,970 Stage-1 map = 100%,  reduce = 75%, Cumulative CPU 9.06 sec\nINFO  : 2017-08-15 21:26:50,081 Stage-1 map = 100%,  reduce = 100%, Cumulative CPU 10.8 sec\nINFO  : MapReduce Total cumulative CPU time: 10 seconds 800 msec\nINFO  : Ended Job = job_1502537431423_0012\n+-----+----------+--+\n| id  |   name   |\n+-----+----------+--+\n| 4   | 操作系统     |\n| 8   | 数据time   |\n| 12  | 数据信号     |\n| 2   | 数学       |\n| 6   | 数据no     |\n| 1   | 数据库      |\n| 3   | 信息系统     |\n| 5   | 数据结构     |\n| 10  | 数据挖掘     |\n| 11  | 数据挖机     |\n| 7   | 数据other  |\n| 9   | 数据操作     |\n+-----+----------+--+\n```\n\n\n\n再试一次select 插入（将t_buk truncate也可，也可使用overwrite关键字）\n\n `insert overwrite table t_buk select id,name from t_p cluster by (id);`\n\n再查看hdfs ui页面50070\n\n![](https://ws2.sinaimg.cn/large/006tNbRwgy1fu7uk05fz5j30x70a8mxm.jpg)\n\n## 再分别查看这几个文件\n\n```\n$HADOOP_HOME/bin/hadoop fs -cat /user/hive/warehouse/t_buk/000000_0\n$HADOOP_HOME/bin/hadoop fs -cat /user/hive/warehouse/t_buk/000001_0  \n$HADOOP_HOME/bin/hadoop fs -cat /user/hive/warehouse/t_buk/000002_0  \n$HADOOP_HOME/bin/hadoop fs -cat /user/hive/warehouse/t_buk/000003_0\n```\n\n## 得到结果\n\n```\n[bigdata@master hivedata]$  hadoop fs -cat /user/hive/warehouse/t_buk/000000_0  \n4,操作系统\n8,数据time\n12,数据信号\n[bigdata@master hivedata]$  hadoop fs -cat /user/hive/warehouse/t_buk/000001_0  \n1,数据库\n5,数据结构\n9,数据操作\n[bigdata@master hivedata]$  hadoop fs -cat /user/hive/warehouse/t_buk/000002_0  \n2,数学\n6,数据no\n10,数据挖掘\n[bigdata@master hivedata]$  hadoop fs -cat /user/hive/warehouse/t_buk/000003_0\n3,信息系统\n7,数据other\n11,数据挖机\n```\n\n# 分桶表疑问\n\n## 为什么每个桶里面的数据条数不一样\n\n```\nhash散列的时候数据可能将数据有的分的多，有的分的少\n```\n\ncluster by （id） 根据id分桶，桶内根据id排序，相当于 distribute by 和 sort by的集合，只是指定的字段都是同一个\n用两个组合更加强大，分桶字段排序字段可以设置为不同\n\n# 分桶表的意义：\n\n提高join操作的效率案例\n\n> 如果a表和b表已经是分桶表，而且分桶的字段都是是id字段\n> 做这个join操作是，还需要做笛卡尔积吗？ 这样不需要，因为同一id哈希后的数据是一致的，这就是分桶表存在的意义\n\n# 注意\n\n1. 在分桶表中使用order by 是非常不建议的，这样会设置成一个reduce，强行将数据写入，一个reduce的内存会爆炸\n2. 使用cluster by  就等同于分桶+排序(sort) \n\n insert overwrite table student_buck  select * from student cluster by(Sno) sort by(Sage);  报错,cluster 和 sort 不能共存\n\n","slug":"Hive分桶表相关","published":1,"updated":"2018-08-13T09:00:52.971Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloj0llh001dykpbriihxwra"},{"title":"Hive搭建及启动","date":"2018-07-19T18:51:21.978Z","toc":true,"_content":"\n[TOC]\n# 配置HOME\n\n下载hive包，并解压\n\n```\nhttp://archive.apache.org/dist/\n```\n\n`ln -s hive-2.1.1  /usr/hive`\n\n\n**vi ~/.bashrc**\n\n```bash\nexport PATH=$JAVA_HOME/bin:$PATH\nexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar\n$HIVE_HOME/bin/hive\nexport HIVE_HOME=/usr/hive\nPATH=$HIVE_HOME/bin:$PATH\n#hive依赖于hadoop(可以不运行在同一主机，但是需要hadoop的配置)\n$HADOOP_HOME=/usr/hadoop\n```\n\n**source ~/.bashrc**\n\n<!--more -->\n\n# 安装mysql\n\n> ## Hive元数据介绍\n>\n> Hive 将元数据存储在 RDBMS 中，一般常用 MySQL 和 Derby。默认情况下，Hive 元数据保存在内嵌的 Derby 数据库中，只能允许一个会话连接，只适合简单的测试。实际生产环境中不适用， 为了支持多用户会话，则需要一个独立的元数据库，使用 MySQL 作为元数据库，Hive 内部对 MySQL 提供了很好的支持，配置一个独立的元数据库\n\n```bash\nyum install -y mysql-server\nchkconfig --add mysqld\nchkconfig mysqld on\nchkconfig --list mysqld\nservice mysqld start\n\nmysql -u root -p\nEnter password:           //默认密码为空，输入后回车即可\nset password for root@localhost=password('root'); 　　密码设置为root\nset password for root@=password('root');\n默认情况下Mysql只允许本地登录，所以只需配置root@localhost就好\n设置所有ip访问密码为root\nset password for root@%=password('root'); 　　　　　　密码设置为root （其实这一步可以不配）\n设置master访问密码为root\nset password for root@master=password('root'); 　　密码设置为root （其实这一步可以不配）\n查询密码\nselect user,host,password from mysql.user;  　　查看密码是否设置成功\n设置所有ip可以通过root访问\nGRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'root' WITH GRANT OPTION;\nGRANT ALL PRIVILEGES ON *.* TO 'hive'@'%' IDENTIFIED BY 'hive' WITH GRANT OPTION;\n\nmysql -uroot -proot\ncreate user 'hive' identified by 'hive';\ncreate user 'hive'@'%' identified by 'hive';\n\ncreate database hive;\n```\n\n\n\n\n# 配置Hive\n\n`mkdir iotmp`\n\n`cp hive-default.xml.template hive-site.xml`\n\n`vim hive-site.xml`\n```xml\n<configuration>\n<property>\n    <name>javax.jdo.option.ConnectionDriverName</name>\n    <value>com.mysql.jdbc.Driver</value>\n    <description>Driver class name for a JDBC metastore</description>\n</property>\n\n<property>\n    <name>javax.jdo.option.ConnectionURL</name>\n    <value>jdbc:mysql://localhost:3306/hive?characterEncoding=UTF-8</value>\n    <description>JDBC connect string for a JDBC metastore</description>\n</property>\n\n<property>\n    <name>javax.jdo.option.ConnectionUserName</name>\n    <value>root</value>\n    <description>Username to use against metastore database</description>\n</property>\n\n<property>\n    <name>javax.jdo.option.ConnectionPassword</name>\n    <value>root</value>\n    <description>password to use against metastore database</description>\n</property>\n<property>\n    <name>hive.querylog.location</name>\n    <value>/usr/hive/iotmp</value>\n    <description>Location of Hive run time structured log file</description>\n</property>\n\n<property>\n    <name>hive.exec.local.scratchdir</name>\n    <value>/usr/hive/iotmp</value>\n    <description>Local scratch space for Hive jobs</description>\n</property>\n\n<property>\n    <name>hive.downloaded.resources.dir</name>\n    <value>/usr/hive/iotmp</value>\n    <description>Temporary local directory for added resources in the remote file system.</description>\n</property>\n<property>\n\t<name>hive.metastore.uris</name>\n\t<value>thrift://master:9083</value>\n</property>\n</configuration>\n```\nHive 的元数据可以存储在本地的 MySQL 中，但是大多数情况会是一个 mysql 集群，而且不在本地。所以在 hive 中需要开启远程 metastore。由于我是本地的 mysql，我就不配置下列属性了，但是如果是远程的 metastore，配置下面的属性。\n```xml\n<property>\n      <name>hive.metastore.uris</name>\n      <value></value>\n  <description>Thrift URI for the remote metastore. Used by metastore client to connect to remote metastore.</description>\n</property>\n<property>\n      <name>hive.server2.transport.mode</name>\n      <value>http</value>\n      <description>Server transport mode. \"binary\" or \"http\".</description>\n</property>\n\n链接：https://www.jianshu.com/p/87b76a686216\n```\n\n# Hive命令\n\n## 启动hive\n\n```bash\n$HIVE_HOME/bin/hive\n如果调试，可以加上参数\n$HIVE_HOME/bin/hivehive -hiveconf hive.root.logger=DEBUG,console\n```\n\n## 启动hiveserver2\n\n```bash\n$HIVE_HOME/bin/hive --service hiveserver2\n\nor nohup $HIVE_HOME/bin/hiveserver2 1>/var/log/hiveserver.log 2>/var/log/hiveserver.err &\n```\n\n> hiveserver端口号默认是10000\n\n**hiveserver2是否启动**\n`netstat -nl|grep 10000`\n\n## beeline工具测试使用jdbc方式连接\n\n可以在部署了hive任意节点上用beeline去连接\n\n```bash\n$HIVE_HOME/bin/beeline -u jdbc:hive2://hive:10000\nor\n$HIVE_HOME/bin/beeline -u jdbc:hive2://hive:10000 -n bigdata \n最后一个参数是用户\nor \n$HIVE_HOME/bin/beeline 回车，进入beeline的命令界面 \n输入命令连接hiveserver2 \nbeeline> !connect jdbc:hive2://hive:10000 \n```\n\n使用beeline通过jdbc连接上之后就可以像client一样操作。\n\nhiveserver2会同时启动一个webui，端口号默认为10002，可以通过http://localhost:10002/访问\n界面中可以看到Session/Query/Software等信息。(此网页只可查看，不可以操作hive数据仓库)\n\n> 参考https://blog.csdn.net/lblblblblzdx/article/details/79760959\n>\n> 参考https://www.cnblogs.com/netuml/p/7841387.html\n\n\n\nhive元数据库（就是hive库）中有几个表（有好几十个，但只需要记住其中几个就可以了），有哪些字段 \n元数据库最重要的作用是保存一些信息，hive的描述信息，比如说hive有几个database，有几个表，这些表对应的hdfs的地址在哪儿，表有几个字段，建了几个分区，创建了几个自定义函数\n\ncolumns_v2表记录是主外键关系表， \nfuncs表，是存的创建了什么函数 \npartition表是记录的创建了什么分区 \n\n# 报错\n\n> 报错 Hive 2.3.3 MetaException(message:Version information not found in metastore.)\n\n```\nschematool -initSchema -dbType mysql\n```\n\n> 参考https://stackoverflow.com/questions/50230515/hive-2-3-3-metaexceptionmessageversion-information-not-found-in-metastore\n>\n> http://sishuok.com/forum/blogPost/list/6221.html\n>\n> https://blog.csdn.net/nokia_hp/article/details/79054079\n\n\n\n","source":"_posts/Hive搭建及启动.md","raw":"---\ntitle: Hive搭建及启动\ndate: 2018年08月06日 22时15分52秒\ntags: [Hive,Docker]\ncategories: 安装部署\ntoc: true\n---\n\n[TOC]\n# 配置HOME\n\n下载hive包，并解压\n\n```\nhttp://archive.apache.org/dist/\n```\n\n`ln -s hive-2.1.1  /usr/hive`\n\n\n**vi ~/.bashrc**\n\n```bash\nexport PATH=$JAVA_HOME/bin:$PATH\nexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar\n$HIVE_HOME/bin/hive\nexport HIVE_HOME=/usr/hive\nPATH=$HIVE_HOME/bin:$PATH\n#hive依赖于hadoop(可以不运行在同一主机，但是需要hadoop的配置)\n$HADOOP_HOME=/usr/hadoop\n```\n\n**source ~/.bashrc**\n\n<!--more -->\n\n# 安装mysql\n\n> ## Hive元数据介绍\n>\n> Hive 将元数据存储在 RDBMS 中，一般常用 MySQL 和 Derby。默认情况下，Hive 元数据保存在内嵌的 Derby 数据库中，只能允许一个会话连接，只适合简单的测试。实际生产环境中不适用， 为了支持多用户会话，则需要一个独立的元数据库，使用 MySQL 作为元数据库，Hive 内部对 MySQL 提供了很好的支持，配置一个独立的元数据库\n\n```bash\nyum install -y mysql-server\nchkconfig --add mysqld\nchkconfig mysqld on\nchkconfig --list mysqld\nservice mysqld start\n\nmysql -u root -p\nEnter password:           //默认密码为空，输入后回车即可\nset password for root@localhost=password('root'); 　　密码设置为root\nset password for root@=password('root');\n默认情况下Mysql只允许本地登录，所以只需配置root@localhost就好\n设置所有ip访问密码为root\nset password for root@%=password('root'); 　　　　　　密码设置为root （其实这一步可以不配）\n设置master访问密码为root\nset password for root@master=password('root'); 　　密码设置为root （其实这一步可以不配）\n查询密码\nselect user,host,password from mysql.user;  　　查看密码是否设置成功\n设置所有ip可以通过root访问\nGRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'root' WITH GRANT OPTION;\nGRANT ALL PRIVILEGES ON *.* TO 'hive'@'%' IDENTIFIED BY 'hive' WITH GRANT OPTION;\n\nmysql -uroot -proot\ncreate user 'hive' identified by 'hive';\ncreate user 'hive'@'%' identified by 'hive';\n\ncreate database hive;\n```\n\n\n\n\n# 配置Hive\n\n`mkdir iotmp`\n\n`cp hive-default.xml.template hive-site.xml`\n\n`vim hive-site.xml`\n```xml\n<configuration>\n<property>\n    <name>javax.jdo.option.ConnectionDriverName</name>\n    <value>com.mysql.jdbc.Driver</value>\n    <description>Driver class name for a JDBC metastore</description>\n</property>\n\n<property>\n    <name>javax.jdo.option.ConnectionURL</name>\n    <value>jdbc:mysql://localhost:3306/hive?characterEncoding=UTF-8</value>\n    <description>JDBC connect string for a JDBC metastore</description>\n</property>\n\n<property>\n    <name>javax.jdo.option.ConnectionUserName</name>\n    <value>root</value>\n    <description>Username to use against metastore database</description>\n</property>\n\n<property>\n    <name>javax.jdo.option.ConnectionPassword</name>\n    <value>root</value>\n    <description>password to use against metastore database</description>\n</property>\n<property>\n    <name>hive.querylog.location</name>\n    <value>/usr/hive/iotmp</value>\n    <description>Location of Hive run time structured log file</description>\n</property>\n\n<property>\n    <name>hive.exec.local.scratchdir</name>\n    <value>/usr/hive/iotmp</value>\n    <description>Local scratch space for Hive jobs</description>\n</property>\n\n<property>\n    <name>hive.downloaded.resources.dir</name>\n    <value>/usr/hive/iotmp</value>\n    <description>Temporary local directory for added resources in the remote file system.</description>\n</property>\n<property>\n\t<name>hive.metastore.uris</name>\n\t<value>thrift://master:9083</value>\n</property>\n</configuration>\n```\nHive 的元数据可以存储在本地的 MySQL 中，但是大多数情况会是一个 mysql 集群，而且不在本地。所以在 hive 中需要开启远程 metastore。由于我是本地的 mysql，我就不配置下列属性了，但是如果是远程的 metastore，配置下面的属性。\n```xml\n<property>\n      <name>hive.metastore.uris</name>\n      <value></value>\n  <description>Thrift URI for the remote metastore. Used by metastore client to connect to remote metastore.</description>\n</property>\n<property>\n      <name>hive.server2.transport.mode</name>\n      <value>http</value>\n      <description>Server transport mode. \"binary\" or \"http\".</description>\n</property>\n\n链接：https://www.jianshu.com/p/87b76a686216\n```\n\n# Hive命令\n\n## 启动hive\n\n```bash\n$HIVE_HOME/bin/hive\n如果调试，可以加上参数\n$HIVE_HOME/bin/hivehive -hiveconf hive.root.logger=DEBUG,console\n```\n\n## 启动hiveserver2\n\n```bash\n$HIVE_HOME/bin/hive --service hiveserver2\n\nor nohup $HIVE_HOME/bin/hiveserver2 1>/var/log/hiveserver.log 2>/var/log/hiveserver.err &\n```\n\n> hiveserver端口号默认是10000\n\n**hiveserver2是否启动**\n`netstat -nl|grep 10000`\n\n## beeline工具测试使用jdbc方式连接\n\n可以在部署了hive任意节点上用beeline去连接\n\n```bash\n$HIVE_HOME/bin/beeline -u jdbc:hive2://hive:10000\nor\n$HIVE_HOME/bin/beeline -u jdbc:hive2://hive:10000 -n bigdata \n最后一个参数是用户\nor \n$HIVE_HOME/bin/beeline 回车，进入beeline的命令界面 \n输入命令连接hiveserver2 \nbeeline> !connect jdbc:hive2://hive:10000 \n```\n\n使用beeline通过jdbc连接上之后就可以像client一样操作。\n\nhiveserver2会同时启动一个webui，端口号默认为10002，可以通过http://localhost:10002/访问\n界面中可以看到Session/Query/Software等信息。(此网页只可查看，不可以操作hive数据仓库)\n\n> 参考https://blog.csdn.net/lblblblblzdx/article/details/79760959\n>\n> 参考https://www.cnblogs.com/netuml/p/7841387.html\n\n\n\nhive元数据库（就是hive库）中有几个表（有好几十个，但只需要记住其中几个就可以了），有哪些字段 \n元数据库最重要的作用是保存一些信息，hive的描述信息，比如说hive有几个database，有几个表，这些表对应的hdfs的地址在哪儿，表有几个字段，建了几个分区，创建了几个自定义函数\n\ncolumns_v2表记录是主外键关系表， \nfuncs表，是存的创建了什么函数 \npartition表是记录的创建了什么分区 \n\n# 报错\n\n> 报错 Hive 2.3.3 MetaException(message:Version information not found in metastore.)\n\n```\nschematool -initSchema -dbType mysql\n```\n\n> 参考https://stackoverflow.com/questions/50230515/hive-2-3-3-metaexceptionmessageversion-information-not-found-in-metastore\n>\n> http://sishuok.com/forum/blogPost/list/6221.html\n>\n> https://blog.csdn.net/nokia_hp/article/details/79054079\n\n\n\n","slug":"Hive搭建及启动","published":1,"updated":"2018-08-15T18:14:43.446Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloj0llj001gykpb8h5czhiu"},{"title":"Hive累计报表","date":"2018-08-13T03:49:13.857Z","toc":true,"_content":"\n[TOC]\n\n在 hive 做统计的时候，总是涉及到做累计的报表处理，下面案列就是来做相应处理\n\n# 准备\n\n## 创建数据文件\n\n（在hadoop所在的机器）\n\n**vim /usr/hadoop/hivedata/t_sales.dat**\n\n```\n舒肤佳,2018-06,5\n舒肤佳,2018-06,15\n美姿,2018-06,5\n舒肤佳,2018-06,8\n美姿,2018-06,25\n舒肤佳,2018-06,5\n舒肤佳,2018-07,4\n舒肤佳,2018-07,6\n美姿,2018-07,10\n美姿,2018-07,5\n```\n\n上传到hdfs\n\n```shell\nhadoop fs -put /usr/hadoop/hivedata/t_sales.dat /local/hivedata/t_sales.dat\n```\n\n<!-- more -->\n\n## 创建表及读取数据\n\n```sql\ncreate table t_sales(brandname string,month string,sales int)\nrow format delimited fields terminated by ',';\nload data inpath '/local/hivedata/t_sales.dat' into table t_sales;\n```\n\n如果是上传本地文件（如果在hive所在主机上） 则在load  data 后加 local，如 `load data local inpath '/usr/hadoop/hivedata/t_sales.dat' into table t_sales;`\n\n\n\n# 1、先求每个品牌的月总金额\n\n```\nselect brandname,month,sum(sales) as all_sales from t_sales group by brandname,month\n```\n\n![](https://ws1.sinaimg.cn/large/0069RVTdgy1fu87l2nswej31500smq3k.jpg)\n\n\n\n# 2、将月总金额自连接\n\n```sql\nselect * from  (select brandname,month,sum(sales) as sal from t_sales group by brandname,month) A \n    inner join \n   (select brandname,month,sum(sales) as sal from t_sales group by brandname,month) B\n    on\nA.brandname=B.brandname\nwhere \nB.month <= A.month;\n```\n\n![](https://ws1.sinaimg.cn/large/006tNbRwgy1fu88kcmiosj31ik0zgq4y.jpg)\n\n\n\n\n\n# 3、从上一步的结果中进行分组查询\n\n分组的字段是 a.brandname a.month\n\n求月累计值： 将 b.month <= a.month 的所有 b.sals求和即可\n\n```\nselect A.brandname,A.month,max(A.sales) as sales,sum(B.sales) as accumulate\nfrom \n(select brandname,month,sum(sales) as sales from t_sales group by brandname,month) A \ninner join \n(select brandname,month,sum(sales) as sales from t_sales group by brandname,month) B\non\nA.brandname=B.brandname\nwhere B.month <= A.month\ngroup by A.brandname,A.month\norder by A.brandname,A.month;\n```\n\n![](https://ws4.sinaimg.cn/large/006tNbRwgy1fu88tmmjfqj31ag0vamyy.jpg)","source":"_posts/Hive累计报表.md","raw":"---\ntitle: Hive累计报表\ndate: 2018年08月06日 22时15分52秒\ntags: [Hive,报表]\ncategories: 大数据\ntoc: true\n---\n\n[TOC]\n\n在 hive 做统计的时候，总是涉及到做累计的报表处理，下面案列就是来做相应处理\n\n# 准备\n\n## 创建数据文件\n\n（在hadoop所在的机器）\n\n**vim /usr/hadoop/hivedata/t_sales.dat**\n\n```\n舒肤佳,2018-06,5\n舒肤佳,2018-06,15\n美姿,2018-06,5\n舒肤佳,2018-06,8\n美姿,2018-06,25\n舒肤佳,2018-06,5\n舒肤佳,2018-07,4\n舒肤佳,2018-07,6\n美姿,2018-07,10\n美姿,2018-07,5\n```\n\n上传到hdfs\n\n```shell\nhadoop fs -put /usr/hadoop/hivedata/t_sales.dat /local/hivedata/t_sales.dat\n```\n\n<!-- more -->\n\n## 创建表及读取数据\n\n```sql\ncreate table t_sales(brandname string,month string,sales int)\nrow format delimited fields terminated by ',';\nload data inpath '/local/hivedata/t_sales.dat' into table t_sales;\n```\n\n如果是上传本地文件（如果在hive所在主机上） 则在load  data 后加 local，如 `load data local inpath '/usr/hadoop/hivedata/t_sales.dat' into table t_sales;`\n\n\n\n# 1、先求每个品牌的月总金额\n\n```\nselect brandname,month,sum(sales) as all_sales from t_sales group by brandname,month\n```\n\n![](https://ws1.sinaimg.cn/large/0069RVTdgy1fu87l2nswej31500smq3k.jpg)\n\n\n\n# 2、将月总金额自连接\n\n```sql\nselect * from  (select brandname,month,sum(sales) as sal from t_sales group by brandname,month) A \n    inner join \n   (select brandname,month,sum(sales) as sal from t_sales group by brandname,month) B\n    on\nA.brandname=B.brandname\nwhere \nB.month <= A.month;\n```\n\n![](https://ws1.sinaimg.cn/large/006tNbRwgy1fu88kcmiosj31ik0zgq4y.jpg)\n\n\n\n\n\n# 3、从上一步的结果中进行分组查询\n\n分组的字段是 a.brandname a.month\n\n求月累计值： 将 b.month <= a.month 的所有 b.sals求和即可\n\n```\nselect A.brandname,A.month,max(A.sales) as sales,sum(B.sales) as accumulate\nfrom \n(select brandname,month,sum(sales) as sales from t_sales group by brandname,month) A \ninner join \n(select brandname,month,sum(sales) as sales from t_sales group by brandname,month) B\non\nA.brandname=B.brandname\nwhere B.month <= A.month\ngroup by A.brandname,A.month\norder by A.brandname,A.month;\n```\n\n![](https://ws4.sinaimg.cn/large/006tNbRwgy1fu88tmmjfqj31ag0vamyy.jpg)","slug":"Hive累计报表","published":1,"updated":"2018-08-14T08:48:15.072Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloj0llk001jykpbpblb368u"},{"title":"Hive自定义函数UDF相关","date":"2018-08-11T03:16:01.806Z","toc":true,"_content":"\n[TOC]\n\n# UDF开发及使用\n\n1. 打成jar包上传到服务器，将jar包添加到hive的classpath\n\n```sql\n或者 hive>add JAR /home/hadoop/udf.jar;\n```\n\n1. 创建临时函数与开发好的java class关联\n\n```\nHive>create temporary function runTime as 'me.yao.bigdata.udf.RunTime';\n```\n\n即可在hql中使用自定义的函数time() \n\nSelect time(name),age from t_test;\n\n> add jar只在一次会话中生效\n\n<!-- more -->\n\n\n\n# transform案例:可以不需要上传jar包\n\n## 1、加载数据\n\n先加载rating.json([链接](https://pan.baidu.com/s/1kJnjv-en3R3HoFB8vhM9AA))文件到hive的一个原始表 rat_json\n\n```sql\ncreate table rat_json(line string) row format delimited;\nload data local inpath '/home/bigdata/apps/hive/hivedata/rating.json' into table rat_json;\n```\n\n## 2、解析字段\n\n需要解析json数据成四个字段，插入一张新的表 t_rating\n\n```sql\ncreate table t_rating as\nselect get_json_object(line,'$.movie') as movieid,get_json_object(line,'$.rate')as rate,get_json_object(line,'$.timeStamp')as timestring,get_json_object(line,'$.uid')as uid from rat_json;\n\n\n```\n\n或者\n\n```sql\ninsert overwrite table t_rating\nselect get_json_object(line,'$.movie') as movieid,get_json_object(line,'$.rate')as rate,get_json_object(line,'$.timeStamp')as timestring,get_json_object(line,'$.uid')as uid from rat_json;\n```\n\n## 3、转换weekday\n\n使用transform+python的方式去转换unixtime为weekday\n\n先编辑一个python脚本文件\n\n**cd /usr/hive/hivedata/**\n\n**vim weekday_mapper.py**\n\n```python\n#!/bin/python\n\nimport sys\n\nimport datetime\n\nfor line in sys.stdin:\n\n  line = line.strip()\n\n  movieid, rating, unixtime,userid = line.split('\\t')\n\n  weekday = datetime.datetime.fromtimestamp(float(unixtime)).isoweekday()\n\n  print '\\t'.join([movieid, rating, str(weekday),userid])\n```\n\n## 将文件加入classpath\n\n保存文件\n\n然后，将文件加入hive的classpath：\n\n```sql\nhive>add FILE /usr/hive/hivedata/weekday_mapper.py;\n```\n\n## 再创建表\n\n```sql\ncreate TABLE u_data_new as\nSELECT\n  TRANSFORM (movieid, rate, timestring,uid)\n  USING 'python weekday_mapper.py'\n  AS (movieid, rate, weekday,uid)\nFROM t_rating;\n```\n\n## 查询表\n\n```sql\nselect distinct(weekday) from u_data_new limit 10;\n```\n\n","source":"_posts/Hive自定义函数流程.md","raw":"---\ntitle: Hive自定义函数UDF相关\ndate: 2018年08月06日 22时15分52秒\ntags: [Hive]\ncategories: 大数据\ntoc: true\n---\n\n[TOC]\n\n# UDF开发及使用\n\n1. 打成jar包上传到服务器，将jar包添加到hive的classpath\n\n```sql\n或者 hive>add JAR /home/hadoop/udf.jar;\n```\n\n1. 创建临时函数与开发好的java class关联\n\n```\nHive>create temporary function runTime as 'me.yao.bigdata.udf.RunTime';\n```\n\n即可在hql中使用自定义的函数time() \n\nSelect time(name),age from t_test;\n\n> add jar只在一次会话中生效\n\n<!-- more -->\n\n\n\n# transform案例:可以不需要上传jar包\n\n## 1、加载数据\n\n先加载rating.json([链接](https://pan.baidu.com/s/1kJnjv-en3R3HoFB8vhM9AA))文件到hive的一个原始表 rat_json\n\n```sql\ncreate table rat_json(line string) row format delimited;\nload data local inpath '/home/bigdata/apps/hive/hivedata/rating.json' into table rat_json;\n```\n\n## 2、解析字段\n\n需要解析json数据成四个字段，插入一张新的表 t_rating\n\n```sql\ncreate table t_rating as\nselect get_json_object(line,'$.movie') as movieid,get_json_object(line,'$.rate')as rate,get_json_object(line,'$.timeStamp')as timestring,get_json_object(line,'$.uid')as uid from rat_json;\n\n\n```\n\n或者\n\n```sql\ninsert overwrite table t_rating\nselect get_json_object(line,'$.movie') as movieid,get_json_object(line,'$.rate')as rate,get_json_object(line,'$.timeStamp')as timestring,get_json_object(line,'$.uid')as uid from rat_json;\n```\n\n## 3、转换weekday\n\n使用transform+python的方式去转换unixtime为weekday\n\n先编辑一个python脚本文件\n\n**cd /usr/hive/hivedata/**\n\n**vim weekday_mapper.py**\n\n```python\n#!/bin/python\n\nimport sys\n\nimport datetime\n\nfor line in sys.stdin:\n\n  line = line.strip()\n\n  movieid, rating, unixtime,userid = line.split('\\t')\n\n  weekday = datetime.datetime.fromtimestamp(float(unixtime)).isoweekday()\n\n  print '\\t'.join([movieid, rating, str(weekday),userid])\n```\n\n## 将文件加入classpath\n\n保存文件\n\n然后，将文件加入hive的classpath：\n\n```sql\nhive>add FILE /usr/hive/hivedata/weekday_mapper.py;\n```\n\n## 再创建表\n\n```sql\ncreate TABLE u_data_new as\nSELECT\n  TRANSFORM (movieid, rate, timestring,uid)\n  USING 'python weekday_mapper.py'\n  AS (movieid, rate, weekday,uid)\nFROM t_rating;\n```\n\n## 查询表\n\n```sql\nselect distinct(weekday) from u_data_new limit 10;\n```\n\n","slug":"Hive自定义函数流程","published":1,"updated":"2018-08-13T03:19:44.441Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloj0lll001mykpbgj0uwm5h"},{"title":"Json与Scala类型的相互转换处理","date":"2018-08-10T17:19:05.443Z","toc":true,"_content":"\n\n\n\n[TOC]\n\n![](https://ws1.sinaimg.cn/large/006tNbRwgy1fu5817otq1j31kw0mojzv.jpg)\n\n在开发过程中时常会有对json数据的一些处理，现做一些记录\n\n<!-- more -->\n\n```scala\nimport com.alibaba.fastjson.{JSON, JSONArray, JSONObject}\nimport com.fasterxml.jackson.databind.ObjectMapper\nimport com.fasterxml.jackson.module.scala.DefaultScalaModule\nimport net.minidev.json.parser.JSONParser\nimport scala.collection.JavaConversions.mapAsScalaMap\nimport scala.collection.mutable\nimport java.util\n\n/**\n  * json utils\n  */\nobject JsonUtils {\n\n\n  val mapper: ObjectMapper = new ObjectMapper()\n\n  def toJsonString(T: Object): String = {\n    mapper.registerModule(DefaultScalaModule)\n    mapper.writeValueAsString(T)\n  }\n\n  def getArrayFromJson(jsonStr: String) = {\n    JSON.parseArray(jsonStr)\n  }\n  def getObjectFromJson(jsonStr: String): JSONObject = {\n    JSON.parseObject(jsonStr)\n  }\n  /**\n    * 配合getObjectFromJson 使用把 JSONObject 变为 map\n    * @param jsonObj\n    * @return\n    */\n  def jsonObj2Map(jsonObj:JSONObject): mutable.Map[String, String] = {\n    var map = mutable.Map[String, String]()\n    val itr: util.Iterator[String] = jsonObj.keySet().iterator()\n    while (itr.hasNext) {\n      val key = itr.next()\n      map += ((key, jsonObj.getString(key)))\n    }\n    map\n  }\n  /**\n    * json 字符串转成 Map\n    * #############有些情况下转换会有问题###############\n    * @param json\n    * @return\n    */\n  def json2Map(json: String): mutable.HashMap[String,String] ={\n    val map : mutable.HashMap[String,String]= mutable.HashMap()\n    val jsonParser =new JSONParser()\n    //将string转化为jsonObject\n    val jsonObj: JSONObject = jsonParser.parse(json).asInstanceOf[JSONObject]\n\n    //获取所有键\n    val jsonKey = jsonObj.keySet()\n\n    val iter = jsonKey.iterator()\n\n    while (iter.hasNext){\n      val field = iter.next()\n      val value = jsonObj.get(field).toString\n\n      if(value.startsWith(\"{\")&&value.endsWith(\"}\")){\n        val value = mapAsScalaMap(jsonObj.get(field).asInstanceOf[util.HashMap[String, String]])\n        map.put(field,value.toString())\n      }else{\n        map.put(field,value)\n      }\n    }\n    map\n  }\n  /**\n    * map 转换成 json 字符串\n    * @param map\n    * @return\n    */\n  def map2Json(map : mutable.Map[String,String]): String = {\n    import net.minidev.json.{JSONObject}\n    import scala.collection.JavaConversions.mutableMapAsJavaMap\n    val jsonString = JSONObject.toJSONString(map)\n    jsonString\n  }\n}\n```\n\n# 测试实例\n\n\n\n```scala\ndef main(args: Array[String]) {\n\n      val json = \"[{\\\"batchid\\\":305322456,\\\"amount\\\":20.0,\\\"count\\\":20},{\\\"batchid\\\":305322488,\\\"amount\\\":\\\"10.0\\\",\\\"count\\\":\\\"10\\\"}]\"\n      val array: JSONArray = JsonUtils.getArrayFromJson(json)\n      println(array)\n      array.toArray().foreach(json=>{\n        println(json)\n        val jobj = json.asInstanceOf[JSONObject]\n        println(jobj.get(\"batchid\"))\n      })\n\n      val jsonStr = \"{\\\"batchid\\\":119,\\\"amount\\\":200.0,\\\"count\\\":200}\"\n      val jsonObj: JSONObject = JsonUtils.getObjectFromJson(jsonStr)\n      println(jsonObj)\n\n      val jsonObj2: JSONObject = JsonUtils.getObjectFromJson(\"{'name':'Wang','age':18,'tag1':[{'tn1':'100','tn2':'101','ts':'ts01'},{'tn1':'100','tn2':'101','ts':'ts02'},{'tn1':'100','tn2':'101','ts':'ts03'}]}\")\n      println(jsonObj2)\n}\n```\n\n","source":"_posts/Json与Scala类型的一些互相转换处理.md","raw":"---\ntitle: Json与Scala类型的相互转换处理\ndate: 2018年08月06日 22时15分52秒\ntags: [Json,Scala]\ncategories: 大数据\ntoc: true\n---\n\n\n\n\n[TOC]\n\n![](https://ws1.sinaimg.cn/large/006tNbRwgy1fu5817otq1j31kw0mojzv.jpg)\n\n在开发过程中时常会有对json数据的一些处理，现做一些记录\n\n<!-- more -->\n\n```scala\nimport com.alibaba.fastjson.{JSON, JSONArray, JSONObject}\nimport com.fasterxml.jackson.databind.ObjectMapper\nimport com.fasterxml.jackson.module.scala.DefaultScalaModule\nimport net.minidev.json.parser.JSONParser\nimport scala.collection.JavaConversions.mapAsScalaMap\nimport scala.collection.mutable\nimport java.util\n\n/**\n  * json utils\n  */\nobject JsonUtils {\n\n\n  val mapper: ObjectMapper = new ObjectMapper()\n\n  def toJsonString(T: Object): String = {\n    mapper.registerModule(DefaultScalaModule)\n    mapper.writeValueAsString(T)\n  }\n\n  def getArrayFromJson(jsonStr: String) = {\n    JSON.parseArray(jsonStr)\n  }\n  def getObjectFromJson(jsonStr: String): JSONObject = {\n    JSON.parseObject(jsonStr)\n  }\n  /**\n    * 配合getObjectFromJson 使用把 JSONObject 变为 map\n    * @param jsonObj\n    * @return\n    */\n  def jsonObj2Map(jsonObj:JSONObject): mutable.Map[String, String] = {\n    var map = mutable.Map[String, String]()\n    val itr: util.Iterator[String] = jsonObj.keySet().iterator()\n    while (itr.hasNext) {\n      val key = itr.next()\n      map += ((key, jsonObj.getString(key)))\n    }\n    map\n  }\n  /**\n    * json 字符串转成 Map\n    * #############有些情况下转换会有问题###############\n    * @param json\n    * @return\n    */\n  def json2Map(json: String): mutable.HashMap[String,String] ={\n    val map : mutable.HashMap[String,String]= mutable.HashMap()\n    val jsonParser =new JSONParser()\n    //将string转化为jsonObject\n    val jsonObj: JSONObject = jsonParser.parse(json).asInstanceOf[JSONObject]\n\n    //获取所有键\n    val jsonKey = jsonObj.keySet()\n\n    val iter = jsonKey.iterator()\n\n    while (iter.hasNext){\n      val field = iter.next()\n      val value = jsonObj.get(field).toString\n\n      if(value.startsWith(\"{\")&&value.endsWith(\"}\")){\n        val value = mapAsScalaMap(jsonObj.get(field).asInstanceOf[util.HashMap[String, String]])\n        map.put(field,value.toString())\n      }else{\n        map.put(field,value)\n      }\n    }\n    map\n  }\n  /**\n    * map 转换成 json 字符串\n    * @param map\n    * @return\n    */\n  def map2Json(map : mutable.Map[String,String]): String = {\n    import net.minidev.json.{JSONObject}\n    import scala.collection.JavaConversions.mutableMapAsJavaMap\n    val jsonString = JSONObject.toJSONString(map)\n    jsonString\n  }\n}\n```\n\n# 测试实例\n\n\n\n```scala\ndef main(args: Array[String]) {\n\n      val json = \"[{\\\"batchid\\\":305322456,\\\"amount\\\":20.0,\\\"count\\\":20},{\\\"batchid\\\":305322488,\\\"amount\\\":\\\"10.0\\\",\\\"count\\\":\\\"10\\\"}]\"\n      val array: JSONArray = JsonUtils.getArrayFromJson(json)\n      println(array)\n      array.toArray().foreach(json=>{\n        println(json)\n        val jobj = json.asInstanceOf[JSONObject]\n        println(jobj.get(\"batchid\"))\n      })\n\n      val jsonStr = \"{\\\"batchid\\\":119,\\\"amount\\\":200.0,\\\"count\\\":200}\"\n      val jsonObj: JSONObject = JsonUtils.getObjectFromJson(jsonStr)\n      println(jsonObj)\n\n      val jsonObj2: JSONObject = JsonUtils.getObjectFromJson(\"{'name':'Wang','age':18,'tag1':[{'tn1':'100','tn2':'101','ts':'ts01'},{'tn1':'100','tn2':'101','ts':'ts02'},{'tn1':'100','tn2':'101','ts':'ts03'}]}\")\n      println(jsonObj2)\n}\n```\n\n","slug":"Json与Scala类型的一些互相转换处理","published":1,"updated":"2018-08-10T19:39:06.343Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloj0lln001pykpb3pl3jqux"},{"title":"Kafka初步总结","date":"2018-08-13T06:50:40.913Z","toc":true,"_content":"\n[TOC]\n\n>  Kafka是一个分布式消息队列：生产者、消费者的功能。它提供了类似于JMS的特性，但是在设计实现上完全不同，此外它并不是JMS规范的实现。\n>  Kafka对消息保存时根据Topic进行归类，发送消息者称为Producer,消息接受者称为Consumer,此外kafka集群有多个kafka实例组成，每个实例(server)成为broker。\n>  无论是kafka集群，还是producer和consumer都依赖于zookeeper集群保存一些meta信息，来保证系统可用性\n>\n\n### JMS的基础\n\nJMS是什么：JMS是Java提供的一套技术规范\n\nJMS干什么用：用来异构系统 集成通信，缓解系统瓶颈，提高系统的伸缩性增强系统用户体验，使得系统模块化和组件化变得可行并更加灵活\n\n通过什么方式：生产消费者模式（生产者、服务器、消费者）\n\n![](https://ws2.sinaimg.cn/large/006tNbRwgy1fu895melcpj30zd0ckdgd.jpg)\n\njdk，kafka，activemq……\n\n<!-- more -->\n\n### JMS消息传输模型\n\n点对点模式**（一对一，消费者主动拉取数据，消息收到后消息清除）**\n\n点对点模型通常是一个基于拉取或者轮询的消息传送模型，这种模型从队列中请求信息，而不是将消息推送到客户端。这个模型的特点是发送到队列的消息被**一个且只有一个接收者接收处理**，即使有多个消息监听者也是如此。\n\n发布/订阅模式**（一对多，数据生产后，推送给所有订阅者）**\n\n发布订阅模型则是一个基于推送的消息传送模型。发布订阅模型可以有多种不同的订阅者，临时订阅者只在主动监听主题时才接收消息，而持久订阅者则监听主题的所有消息，**即时当前订阅者不可用，处于离线状态**。\n\n![](https://ws2.sinaimg.cn/large/0069RVTdgy1fu894keo4oj310n0hd0tv.jpg)\n\nqueue.put（object）  数据生产\n\nqueue.take(object)    数据消费\n\n**kafka是采用的类jms模式，与类jms模式区别是**： \n\njms两种模式：1，推送的话可以多个，2拉取的话只能一个消费者，因为消费完，消息数据就会不存在了 kafka解决了这种弊端，拉取模式下也可以多个消费者，因为消息可以持久化到硬盘，就算消费了也是存在的。Kafka中ack机制是为了保证消息完整被处理 \n\n\n\n# kafka是什么\n\n    类JMS消息队列，结合JMS中的两种模式，可以有多个消费者主动拉取数据，在JMS中只有点对点模式才有消费者主动拉取数据。\n    kafka是一个生产-消费模型。\n    Producer：生产者，只负责数据生产，生产者的代码可以集成到任务系统中。 \n              数据的分发策略由producer决定，默认是defaultPartition  Utils.abs(key.hashCode) % numPartitions\n    Broker：当前服务器上的Kafka进程,俗称拉皮条。只管数据存储，不管是谁生产，不管是谁消费。\n            在集群中每个broker都有一个唯一brokerid，不得重复。\n    Topic:目标发送的目的地，这是一个逻辑上的概念，落到磁盘上是一个partition的目录。partition的目录中有多个segment组合(index,log)\n            一个Topic对应多个partition[0,1,2,3]，一个partition对应多个segment组合。一个segment有默认的大小是1G。\n            每个partition可以设置多个副本(replication-factor 1),会从所有的副本中选取一个leader出来。所有读写操作都是通过leader来进行的。\n            特别强调，和mysql中主从有区别，mysql做主从是为了读写分离，在kafka中读写操作都是leader。\n    ConsumerGroup：数据消费者组，ConsumerGroup可以有多个，每个ConsumerGroup消费的数据都是一样的。\n                   可以把多个consumer线程划分为一个组，组里面所有成员共同消费一个topic的数据，组员之间不能重复消费。\n                   \n\n## Kafka核心组件\nTopic ：消息根据Topic进行归类\nProducer：发送消息者\nConsumer：消息接受者\nbroker：每个kafka实例(server)\nZookeeper：依赖集群保存meta信息。\n\n![](https://ws3.sinaimg.cn/large/006tNbRwgy1fu89ajoxc5j30mf0fnt9d.jpg)\n\n\n\n## 为什么需要消息队列\n\n消息系统的核心作用就是三点：解耦，异步和并行\n\n以用户注册的案列来说明消息系统的作用\n\n\n\n## 消息队列和rpc调用区别\n\n​    消息队列并不关心是哪个消费者消费了数据，发布成功后就不必管消息队列的内容是否被消费，但是rpc调用的话，必须要给调用的系统返回一个状态码\n\n以下为针对Kafka的一些总结\n\n\n# kafka生产数据时的分组策略\n    默认是defaultPartition  Utils.abs(key.hashCode) % numPartitions\n    上文中的key是producer在发送数据时传入的，produer.send(KeyedMessage(topic,myPartitionKey,messageContent))\n\n# kafka如何保证数据的完全生产\n    ack机制：broker表示发来的数据已确认接收无误，表示数据已经保存到磁盘。\n    0：不等待broker返回确认消息\n    1：等待topic中某个partition leader保存成功的状态反馈\n    -1：等待topic中某个partition 所有副本都保存成功的状态反馈\n    \n# broker如何保存数据\n    在理论环境下，broker按照顺序读写的机制，可以每秒保存600M的数据。主要通过pagecache机制，尽可能的利用当前物理机器上的空闲内存来做缓存。\n    当前topic所属的broker，必定有一个该topic的partition，partition是一个磁盘目录。partition的目录中有多个segment组合(index,log)\n\n# partition如何分布在不同的broker上\n\n\n```java\n int i = 0\n    list{kafka01,kafka02,kafka03}\n    \n    for(int i=0;i<5;i++){\n        brIndex = i%broker;\n        hostName = list.get(brIndex)\n    }\n```\n\n\n    \n# consumerGroup的组员和partition之间如何做负载均衡\n    最好是一一对应，一个partition对应一个consumer。\n    如果consumer的数量过多，必然有空闲的consumer。\n    \n    算法：\n        假如topic1,具有如下partitions: P0,P1,P2,P3\n        加入group中,有如下consumer: C1,C2\n        首先根据partition索引号对partitions排序: P0,P1,P2,P3\n        根据consumer.id排序: C0,C1\n        计算倍数: M = [P0,P1,P2,P3].size / [C0,C1].size,本例值M=2(向上取整)\n        然后依次分配partitions: C0 = [P0,P1],C1=[P2,P3],即Ci = [P(i * M),P((i + 1) * M -1)]\n\n# 如何保证kafka消费者消费数据是全局有序的\n    如果要全局有序的，必须保证生产有序，存储有序，消费有序。\n    由于生产可以做集群，存储可以分片，消费可以设置为一个consumerGroup，要保证全局有序，就需要保证每个环节都有序。\n    只有一个可能，就是一个生产者，一个partition，一个消费者。这种场景和大数据应用场景相悖。\n    1.生产者是集群模式--》全局序号管理器\n    2.broker断只设置一个partion-》kafka的高并发下的负载均衡\n    3.消费者如果是一个组，如何保障消息有序？消费来一个线程（自定义一个数据结构来排序）\n    \n\n\n\n不被完整处理，会造成结果？ \n是否开启ack-fail机制需要根据**业务场景来** 在大数据操作**点击流数据**基本上是不开启的，点击流日志中一条pv，uv数据丢失不会造成什么影响。","source":"_posts/Kafka小知识点.md","raw":"---\ntitle: Kafka初步总结\ndate: 2018年08月06日 22时15分52秒\ntags: [Kafka]\ncategories: 总结\ntoc: true\n---\n\n[TOC]\n\n>  Kafka是一个分布式消息队列：生产者、消费者的功能。它提供了类似于JMS的特性，但是在设计实现上完全不同，此外它并不是JMS规范的实现。\n>  Kafka对消息保存时根据Topic进行归类，发送消息者称为Producer,消息接受者称为Consumer,此外kafka集群有多个kafka实例组成，每个实例(server)成为broker。\n>  无论是kafka集群，还是producer和consumer都依赖于zookeeper集群保存一些meta信息，来保证系统可用性\n>\n\n### JMS的基础\n\nJMS是什么：JMS是Java提供的一套技术规范\n\nJMS干什么用：用来异构系统 集成通信，缓解系统瓶颈，提高系统的伸缩性增强系统用户体验，使得系统模块化和组件化变得可行并更加灵活\n\n通过什么方式：生产消费者模式（生产者、服务器、消费者）\n\n![](https://ws2.sinaimg.cn/large/006tNbRwgy1fu895melcpj30zd0ckdgd.jpg)\n\njdk，kafka，activemq……\n\n<!-- more -->\n\n### JMS消息传输模型\n\n点对点模式**（一对一，消费者主动拉取数据，消息收到后消息清除）**\n\n点对点模型通常是一个基于拉取或者轮询的消息传送模型，这种模型从队列中请求信息，而不是将消息推送到客户端。这个模型的特点是发送到队列的消息被**一个且只有一个接收者接收处理**，即使有多个消息监听者也是如此。\n\n发布/订阅模式**（一对多，数据生产后，推送给所有订阅者）**\n\n发布订阅模型则是一个基于推送的消息传送模型。发布订阅模型可以有多种不同的订阅者，临时订阅者只在主动监听主题时才接收消息，而持久订阅者则监听主题的所有消息，**即时当前订阅者不可用，处于离线状态**。\n\n![](https://ws2.sinaimg.cn/large/0069RVTdgy1fu894keo4oj310n0hd0tv.jpg)\n\nqueue.put（object）  数据生产\n\nqueue.take(object)    数据消费\n\n**kafka是采用的类jms模式，与类jms模式区别是**： \n\njms两种模式：1，推送的话可以多个，2拉取的话只能一个消费者，因为消费完，消息数据就会不存在了 kafka解决了这种弊端，拉取模式下也可以多个消费者，因为消息可以持久化到硬盘，就算消费了也是存在的。Kafka中ack机制是为了保证消息完整被处理 \n\n\n\n# kafka是什么\n\n    类JMS消息队列，结合JMS中的两种模式，可以有多个消费者主动拉取数据，在JMS中只有点对点模式才有消费者主动拉取数据。\n    kafka是一个生产-消费模型。\n    Producer：生产者，只负责数据生产，生产者的代码可以集成到任务系统中。 \n              数据的分发策略由producer决定，默认是defaultPartition  Utils.abs(key.hashCode) % numPartitions\n    Broker：当前服务器上的Kafka进程,俗称拉皮条。只管数据存储，不管是谁生产，不管是谁消费。\n            在集群中每个broker都有一个唯一brokerid，不得重复。\n    Topic:目标发送的目的地，这是一个逻辑上的概念，落到磁盘上是一个partition的目录。partition的目录中有多个segment组合(index,log)\n            一个Topic对应多个partition[0,1,2,3]，一个partition对应多个segment组合。一个segment有默认的大小是1G。\n            每个partition可以设置多个副本(replication-factor 1),会从所有的副本中选取一个leader出来。所有读写操作都是通过leader来进行的。\n            特别强调，和mysql中主从有区别，mysql做主从是为了读写分离，在kafka中读写操作都是leader。\n    ConsumerGroup：数据消费者组，ConsumerGroup可以有多个，每个ConsumerGroup消费的数据都是一样的。\n                   可以把多个consumer线程划分为一个组，组里面所有成员共同消费一个topic的数据，组员之间不能重复消费。\n                   \n\n## Kafka核心组件\nTopic ：消息根据Topic进行归类\nProducer：发送消息者\nConsumer：消息接受者\nbroker：每个kafka实例(server)\nZookeeper：依赖集群保存meta信息。\n\n![](https://ws3.sinaimg.cn/large/006tNbRwgy1fu89ajoxc5j30mf0fnt9d.jpg)\n\n\n\n## 为什么需要消息队列\n\n消息系统的核心作用就是三点：解耦，异步和并行\n\n以用户注册的案列来说明消息系统的作用\n\n\n\n## 消息队列和rpc调用区别\n\n​    消息队列并不关心是哪个消费者消费了数据，发布成功后就不必管消息队列的内容是否被消费，但是rpc调用的话，必须要给调用的系统返回一个状态码\n\n以下为针对Kafka的一些总结\n\n\n# kafka生产数据时的分组策略\n    默认是defaultPartition  Utils.abs(key.hashCode) % numPartitions\n    上文中的key是producer在发送数据时传入的，produer.send(KeyedMessage(topic,myPartitionKey,messageContent))\n\n# kafka如何保证数据的完全生产\n    ack机制：broker表示发来的数据已确认接收无误，表示数据已经保存到磁盘。\n    0：不等待broker返回确认消息\n    1：等待topic中某个partition leader保存成功的状态反馈\n    -1：等待topic中某个partition 所有副本都保存成功的状态反馈\n    \n# broker如何保存数据\n    在理论环境下，broker按照顺序读写的机制，可以每秒保存600M的数据。主要通过pagecache机制，尽可能的利用当前物理机器上的空闲内存来做缓存。\n    当前topic所属的broker，必定有一个该topic的partition，partition是一个磁盘目录。partition的目录中有多个segment组合(index,log)\n\n# partition如何分布在不同的broker上\n\n\n```java\n int i = 0\n    list{kafka01,kafka02,kafka03}\n    \n    for(int i=0;i<5;i++){\n        brIndex = i%broker;\n        hostName = list.get(brIndex)\n    }\n```\n\n\n    \n# consumerGroup的组员和partition之间如何做负载均衡\n    最好是一一对应，一个partition对应一个consumer。\n    如果consumer的数量过多，必然有空闲的consumer。\n    \n    算法：\n        假如topic1,具有如下partitions: P0,P1,P2,P3\n        加入group中,有如下consumer: C1,C2\n        首先根据partition索引号对partitions排序: P0,P1,P2,P3\n        根据consumer.id排序: C0,C1\n        计算倍数: M = [P0,P1,P2,P3].size / [C0,C1].size,本例值M=2(向上取整)\n        然后依次分配partitions: C0 = [P0,P1],C1=[P2,P3],即Ci = [P(i * M),P((i + 1) * M -1)]\n\n# 如何保证kafka消费者消费数据是全局有序的\n    如果要全局有序的，必须保证生产有序，存储有序，消费有序。\n    由于生产可以做集群，存储可以分片，消费可以设置为一个consumerGroup，要保证全局有序，就需要保证每个环节都有序。\n    只有一个可能，就是一个生产者，一个partition，一个消费者。这种场景和大数据应用场景相悖。\n    1.生产者是集群模式--》全局序号管理器\n    2.broker断只设置一个partion-》kafka的高并发下的负载均衡\n    3.消费者如果是一个组，如何保障消息有序？消费来一个线程（自定义一个数据结构来排序）\n    \n\n\n\n不被完整处理，会造成结果？ \n是否开启ack-fail机制需要根据**业务场景来** 在大数据操作**点击流数据**基本上是不开启的，点击流日志中一条pv，uv数据丢失不会造成什么影响。","slug":"Kafka小知识点","published":1,"updated":"2018-08-15T03:54:57.767Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloj0llp001sykpb2l9tgd2j"},{"title":"Kafka深入解析","date":"2018-08-14T07:43:27.968Z","toc":true,"_content":"\n[TOC]\n\n# Kafka结构\n\n- **Producer** ：消息生产者，就是向kafka broker发消息的客户端。\n\n\n- \n  **Consumer** ：消息消费者，向kafka broker取消息的客户端\n\n- **Topic** ：可以理解为一个队列\n\n  <!-- more -->\n\n- **Consumer Group （CG**）： （消费组）这是kafka用来实现一个topic消息的广播（发给所有的consumer）和单播（发给任意一个consumer）的手段。\n\n  一个topic可以有多个CG。topic的消息会复制（不是真的复制，是概念上的）到所有的CG，*<u>但每个partion只会把消息发给该CG中的一个consumer</u>*。如果需要实现广播，<u>只要每个consumer有一个独立的CG就可以了</u>（即是需要消费消息的消费者，属于不同的消费组）。要实现单播只要所有的consumer在同一个CG（即是需要消费消息的消费者，属于同一个消费组）。用CG还可以将consumer进行自由的分组而不需要多次发送消息到不同的topic。\n\n- **Broker** ：一台kafka服务器就是一个broker。一个集群由多个broker组成。一个broker可以容纳多个topic。\n\n  broker的作用就是帮你把消息从发送端传送到接收端\n\n- **Partition**：为了实现扩展性，一个非常大的topic可以分布到多个broker（即服务器）上，一个topic可以分为多个partition，每个partition是一个有序的队列。partition中的每条消息都会被分配一个有序的id（offset）。kafka只保证按一个partition中的顺序将消息发给consumer，不保证一个topic的整体（多个partition间）的顺序。\n\n- **Offset**：kafka的存储文件都是按照offset.kafka来命名，用offset做名字的好处是方便查找。例如你想找位于2049的位置，只要找到2048.kafka的文件即可。当然the first offset就是00000000000.kafka\n\n\n\n# Consumer与topic关系\n\n本质上kafka只支持Topic；\n\n- 每个group中可以有多个consumer，每个consumer属于一个consumer group；\n\n  通常情况下，一个group中会包含多个consumer，这样不仅可以提高topic中消息的并发消费能力，而且还能提高\"故障容错\"性，如果group中的某个consumer失效那么其消费的partitions将会有其他consumer自动接管。\n\n- 对于Topic中的一条特定的消息，只会被订阅此Topic的每个group中的其中一个consumer消费，此消息不会发送给一个group的多个consumer；\n\n- 那么一个group中所有的consumer将会交错的消费整个Topic，每个group中consumer消息消费互相独立，我们可以认为一个group是一个\"订阅\"者。\n\n- 在kafka中,一个partition中的消息只会被group中的一个consumer消费(同一时刻)；\n\n  一个Topic中的每个partions，只会被一个\"订阅者\"中的一个consumer消费，不过一个consumer可以同时消费多个partitions中的消息。\n\n- kafka的设计原理决定,对于一个topic，同一个group中不能有多于partitions个数的consumer同时消费，否则将意味着某些consumer将无法得到消息。\n\n- kafka只能保证一个partition中的消息被某个consumer消费时是顺序的；事实上，从Topic角度来说,当有多个partitions时,消息仍不是全局有序的。\n\n\n\n# Kafka消息的分发\n\nProducer客户端负责消息的分发\n\n- kafka集群中的任何一个broker都可以向producer提供metadata信息,这些metadata中包含\"集群中存活的servers列表\"/\"partitions leader列表\"等信息；\n- 当producer获取到metadata信息之后, producer将会和Topic下所有partition leader保持socket连接；\n- 消息由producer直接通过socket发送到broker，中间不会经过任何\"路由层\"，事实上，消息被路由到哪个partition上由producer客户端决定；\n\n比如可以采用\"random\"\"key-hash\"\"轮询\"等,如果一个topic中有多个partitions,那么在producer端实现\"消息均衡分发\"是必要的。\n\n\n\n在producer端的配置文件中,开发者可以指定partition路由的方式。\n\n\n**Producer消息发送的应答机制**\n设置发送数据是否需要服务端的反馈,有三个值0,1,-1\n  0: producer不会等待broker发送ack \n  1: 当leader接收到消息之后发送ack \n  -1: 当所有的follower都同步消息成功后发送ack\n\n**request.required.acks=0**\n\n# Consumer的负载均衡\n\n当一个group中,有consumer加入或者离开时,会触发partitions均衡.均衡的最终目的,是提升topic的并发消费能力，步骤如下：\n\n1. 假如topic1,具有如下partitions: P0,P1,P2,P3\n2. 加入group中,有如下consumer: C1,C2\n3. 首先根据partition索引号对partitions排序: P0,P1,P2,P3\n4. 根据consumer.id排序: C0,C1\n5. 计算倍数: M = [P0,P1,P2,P3].size / [C0,C1].size,本例值M=2(向上取整)\n6. 然后依次分配partitions: C0 = [P0,P1],C1=[P2,P3],即Ci = [P(i * M),P((i + 1) * M -1)]\n\n![](https://ws3.sinaimg.cn/large/0069RVTdly1fu9a7zzwdrj31540lvjtv.jpg)\n\n\n\n# Kafka文件存储机制\n\n### Kafka文件存储基本结构\n\n在Kafka文件存储中，同一个topic下有多个不同partition，每个partition为一个目录，partiton命名规则为topic名称+有序序号，第一个partiton序号从0开始，序号最大值为partitions数量减1。\n\n![](https://ws4.sinaimg.cn/large/0069RVTdly1fu9abi7beaj312e04agng.jpg)\n\n每个partion(目录)相当于一个巨型文件被平均分配到多个大小相等segment(段)数据文件中。**但每个段****segmentfile****消息数量不一定相等**，这种特性方便oldsegment file快速被删除。默认保留7天的数据。\n\n![](https://ws2.sinaimg.cn/large/0069RVTdly1fu9ajs8d4dj30rs0dgwj3.jpg)\n\n每个partiton只需要支持顺序读写就行了，segment文件生命周期由服务端配置参数决定。（什么时候创建，什么时候删除）\n\n![](https://ws1.sinaimg.cn/large/0069RVTdly1fu9ajsxr9bj30tt0ektai.jpg)\n\n### Kafka Partition Segment\n\nSegment file组成：由2大部分组成，分别为index file和data file，此2个文件一一对应，成对出现，后缀\".index\"和“.log”分别表示为segment索引文件、数据文件。\n\n![](https://ws4.sinaimg.cn/large/0069RVTdly1fu9ai5p7amj30nv0f0gre.jpg)\n\nl Segment文件命名规则：partion全局的第一个segment从0开始，后续每个segment文件名为上一个segment文件最后一条消息的offset值。数值最大为64位long大小，19位数字字符长度，没有数字用0填充。\n\nl 索引文件存储大量元数据，数据文件存储大量消息，索引文件中元数据指向对应数据文件中message的物理偏移地址。\n\n![](https://ws2.sinaimg.cn/large/0069RVTdly1fu9ai52pxmj30sx0hetdm.jpg)\n\n3，497：当前log文件中的第几条信息，存放在磁盘上的那个地方\n\n \n\n上述图中索引文件存储大量元数据，数据文件存储大量消息，索引文件中元数据指向对应数据文件中message的物理偏移地址。\n\n其中以索引文件中元数据3,497为例，依次在数据文件中表示第3个message(在全局partiton表示第368772个message)、以及该消息的物理偏移地址为497。\n\n \n\nl segment data file由许多message组成， qq物理结构如下：\n\n| **关键字******         | **解释说明******                             |\n| ------------------- | ---------------------------------------- |\n| 8  byte offset      | 在parition(分区)内的每条消息都有一个有序的id号，这个id号被称为偏移(offset),它可以唯一确定每条消息在parition(分区)内的位置。即offset表示partiion的第多少message |\n| 4 byte message size | message大小                                |\n| 4 byte CRC32        | 用crc32校验message                          |\n| 1 byte “magic\"      | 表示本次发布Kafka服务程序协议版本号                     |\n| 1 byte “attributes\" | 表示为独立版本、或标识压缩类型、或编码类型。                   |\n| 4 byte key length   | 表示key的长度,当key为-1时，K byte key字段不填         |\n| K byte key          | 可选                                       |\n| value bytes payload | 表示实际消息数据。                                |\n\n kafka查找message，先查找segment file \n\n00000000000000000000.index表示最开始的文件，起始偏移量(offset)为0\n\n00000000000000368769.index的消息量起始偏移量为368770= 368769 + 1\n\n00000000000000737337.index的起始偏移量为737338=737337+ 1\n\n其他后续文件依次类推。\n\n以起始偏移量命名并排序这些文件，只要根据offset**二分查找**文件列表，就可以快速定位到具体文件。当offset=368776时定位到00000000000000368769.index和对应log文件。\n\n再通过segment file查找message      \n\n当offset=368776时，依次定位到00000000000000368769.index的元数据物理位置和00000000000000368769.log的物理偏移地址\n\n然后再通过00000000000000368769.log顺序查找直到offset=368776为止。","source":"_posts/Kafka深入解析.md","raw":"---\ntitle: Kafka深入解析\ndate: 2018年08月06日 22时15分52秒\ntags: [Kafka,原理]\ncategories: 组件\ntoc: true\n---\n\n[TOC]\n\n# Kafka结构\n\n- **Producer** ：消息生产者，就是向kafka broker发消息的客户端。\n\n\n- \n  **Consumer** ：消息消费者，向kafka broker取消息的客户端\n\n- **Topic** ：可以理解为一个队列\n\n  <!-- more -->\n\n- **Consumer Group （CG**）： （消费组）这是kafka用来实现一个topic消息的广播（发给所有的consumer）和单播（发给任意一个consumer）的手段。\n\n  一个topic可以有多个CG。topic的消息会复制（不是真的复制，是概念上的）到所有的CG，*<u>但每个partion只会把消息发给该CG中的一个consumer</u>*。如果需要实现广播，<u>只要每个consumer有一个独立的CG就可以了</u>（即是需要消费消息的消费者，属于不同的消费组）。要实现单播只要所有的consumer在同一个CG（即是需要消费消息的消费者，属于同一个消费组）。用CG还可以将consumer进行自由的分组而不需要多次发送消息到不同的topic。\n\n- **Broker** ：一台kafka服务器就是一个broker。一个集群由多个broker组成。一个broker可以容纳多个topic。\n\n  broker的作用就是帮你把消息从发送端传送到接收端\n\n- **Partition**：为了实现扩展性，一个非常大的topic可以分布到多个broker（即服务器）上，一个topic可以分为多个partition，每个partition是一个有序的队列。partition中的每条消息都会被分配一个有序的id（offset）。kafka只保证按一个partition中的顺序将消息发给consumer，不保证一个topic的整体（多个partition间）的顺序。\n\n- **Offset**：kafka的存储文件都是按照offset.kafka来命名，用offset做名字的好处是方便查找。例如你想找位于2049的位置，只要找到2048.kafka的文件即可。当然the first offset就是00000000000.kafka\n\n\n\n# Consumer与topic关系\n\n本质上kafka只支持Topic；\n\n- 每个group中可以有多个consumer，每个consumer属于一个consumer group；\n\n  通常情况下，一个group中会包含多个consumer，这样不仅可以提高topic中消息的并发消费能力，而且还能提高\"故障容错\"性，如果group中的某个consumer失效那么其消费的partitions将会有其他consumer自动接管。\n\n- 对于Topic中的一条特定的消息，只会被订阅此Topic的每个group中的其中一个consumer消费，此消息不会发送给一个group的多个consumer；\n\n- 那么一个group中所有的consumer将会交错的消费整个Topic，每个group中consumer消息消费互相独立，我们可以认为一个group是一个\"订阅\"者。\n\n- 在kafka中,一个partition中的消息只会被group中的一个consumer消费(同一时刻)；\n\n  一个Topic中的每个partions，只会被一个\"订阅者\"中的一个consumer消费，不过一个consumer可以同时消费多个partitions中的消息。\n\n- kafka的设计原理决定,对于一个topic，同一个group中不能有多于partitions个数的consumer同时消费，否则将意味着某些consumer将无法得到消息。\n\n- kafka只能保证一个partition中的消息被某个consumer消费时是顺序的；事实上，从Topic角度来说,当有多个partitions时,消息仍不是全局有序的。\n\n\n\n# Kafka消息的分发\n\nProducer客户端负责消息的分发\n\n- kafka集群中的任何一个broker都可以向producer提供metadata信息,这些metadata中包含\"集群中存活的servers列表\"/\"partitions leader列表\"等信息；\n- 当producer获取到metadata信息之后, producer将会和Topic下所有partition leader保持socket连接；\n- 消息由producer直接通过socket发送到broker，中间不会经过任何\"路由层\"，事实上，消息被路由到哪个partition上由producer客户端决定；\n\n比如可以采用\"random\"\"key-hash\"\"轮询\"等,如果一个topic中有多个partitions,那么在producer端实现\"消息均衡分发\"是必要的。\n\n\n\n在producer端的配置文件中,开发者可以指定partition路由的方式。\n\n\n**Producer消息发送的应答机制**\n设置发送数据是否需要服务端的反馈,有三个值0,1,-1\n  0: producer不会等待broker发送ack \n  1: 当leader接收到消息之后发送ack \n  -1: 当所有的follower都同步消息成功后发送ack\n\n**request.required.acks=0**\n\n# Consumer的负载均衡\n\n当一个group中,有consumer加入或者离开时,会触发partitions均衡.均衡的最终目的,是提升topic的并发消费能力，步骤如下：\n\n1. 假如topic1,具有如下partitions: P0,P1,P2,P3\n2. 加入group中,有如下consumer: C1,C2\n3. 首先根据partition索引号对partitions排序: P0,P1,P2,P3\n4. 根据consumer.id排序: C0,C1\n5. 计算倍数: M = [P0,P1,P2,P3].size / [C0,C1].size,本例值M=2(向上取整)\n6. 然后依次分配partitions: C0 = [P0,P1],C1=[P2,P3],即Ci = [P(i * M),P((i + 1) * M -1)]\n\n![](https://ws3.sinaimg.cn/large/0069RVTdly1fu9a7zzwdrj31540lvjtv.jpg)\n\n\n\n# Kafka文件存储机制\n\n### Kafka文件存储基本结构\n\n在Kafka文件存储中，同一个topic下有多个不同partition，每个partition为一个目录，partiton命名规则为topic名称+有序序号，第一个partiton序号从0开始，序号最大值为partitions数量减1。\n\n![](https://ws4.sinaimg.cn/large/0069RVTdly1fu9abi7beaj312e04agng.jpg)\n\n每个partion(目录)相当于一个巨型文件被平均分配到多个大小相等segment(段)数据文件中。**但每个段****segmentfile****消息数量不一定相等**，这种特性方便oldsegment file快速被删除。默认保留7天的数据。\n\n![](https://ws2.sinaimg.cn/large/0069RVTdly1fu9ajs8d4dj30rs0dgwj3.jpg)\n\n每个partiton只需要支持顺序读写就行了，segment文件生命周期由服务端配置参数决定。（什么时候创建，什么时候删除）\n\n![](https://ws1.sinaimg.cn/large/0069RVTdly1fu9ajsxr9bj30tt0ektai.jpg)\n\n### Kafka Partition Segment\n\nSegment file组成：由2大部分组成，分别为index file和data file，此2个文件一一对应，成对出现，后缀\".index\"和“.log”分别表示为segment索引文件、数据文件。\n\n![](https://ws4.sinaimg.cn/large/0069RVTdly1fu9ai5p7amj30nv0f0gre.jpg)\n\nl Segment文件命名规则：partion全局的第一个segment从0开始，后续每个segment文件名为上一个segment文件最后一条消息的offset值。数值最大为64位long大小，19位数字字符长度，没有数字用0填充。\n\nl 索引文件存储大量元数据，数据文件存储大量消息，索引文件中元数据指向对应数据文件中message的物理偏移地址。\n\n![](https://ws2.sinaimg.cn/large/0069RVTdly1fu9ai52pxmj30sx0hetdm.jpg)\n\n3，497：当前log文件中的第几条信息，存放在磁盘上的那个地方\n\n \n\n上述图中索引文件存储大量元数据，数据文件存储大量消息，索引文件中元数据指向对应数据文件中message的物理偏移地址。\n\n其中以索引文件中元数据3,497为例，依次在数据文件中表示第3个message(在全局partiton表示第368772个message)、以及该消息的物理偏移地址为497。\n\n \n\nl segment data file由许多message组成， qq物理结构如下：\n\n| **关键字******         | **解释说明******                             |\n| ------------------- | ---------------------------------------- |\n| 8  byte offset      | 在parition(分区)内的每条消息都有一个有序的id号，这个id号被称为偏移(offset),它可以唯一确定每条消息在parition(分区)内的位置。即offset表示partiion的第多少message |\n| 4 byte message size | message大小                                |\n| 4 byte CRC32        | 用crc32校验message                          |\n| 1 byte “magic\"      | 表示本次发布Kafka服务程序协议版本号                     |\n| 1 byte “attributes\" | 表示为独立版本、或标识压缩类型、或编码类型。                   |\n| 4 byte key length   | 表示key的长度,当key为-1时，K byte key字段不填         |\n| K byte key          | 可选                                       |\n| value bytes payload | 表示实际消息数据。                                |\n\n kafka查找message，先查找segment file \n\n00000000000000000000.index表示最开始的文件，起始偏移量(offset)为0\n\n00000000000000368769.index的消息量起始偏移量为368770= 368769 + 1\n\n00000000000000737337.index的起始偏移量为737338=737337+ 1\n\n其他后续文件依次类推。\n\n以起始偏移量命名并排序这些文件，只要根据offset**二分查找**文件列表，就可以快速定位到具体文件。当offset=368776时定位到00000000000000368769.index和对应log文件。\n\n再通过segment file查找message      \n\n当offset=368776时，依次定位到00000000000000368769.index的元数据物理位置和00000000000000368769.log的物理偏移地址\n\n然后再通过00000000000000368769.log顺序查找直到offset=368776为止。","slug":"Kafka深入解析","published":1,"updated":"2018-08-14T08:30:28.045Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloj0llq001wykpbumswwezx"},{"title":"Kafka读写数据","date":"2018-08-14T11:47:22.892Z","toc":true,"_content":"\n[TOC]\n\n首先kafka依赖于操作系统的pageCache机制，尽可能的把空闲的内存作为一个磁盘，只有发生缺页的才会放在磁盘中\n\n<!-- more -->\n\n那么落在磁盘上的话，还有就是采用的是sendfile机制：主要思想就是在内核中进行拷贝，再写socket流，传统io是先将数据读到内核在写到用户区，在写到内核，再是socket流，这样就算磁盘的话，也是相当快的","source":"_posts/Kafka读取数据性能.md","raw":"---\ntitle: Kafka读写数据\ndate: 2018年08月06日 22时15分52秒\ntags: [Kafka,原理]\ncategories: 组件\ntoc: true\n---\n\n[TOC]\n\n首先kafka依赖于操作系统的pageCache机制，尽可能的把空闲的内存作为一个磁盘，只有发生缺页的才会放在磁盘中\n\n<!-- more -->\n\n那么落在磁盘上的话，还有就是采用的是sendfile机制：主要思想就是在内核中进行拷贝，再写socket流，传统io是先将数据读到内核在写到用户区，在写到内核，再是socket流，这样就算磁盘的话，也是相当快的","slug":"Kafka读取数据性能","published":1,"updated":"2018-08-15T07:23:24.298Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloj0llr0020ykpbdxy460wh"},{"title":"Kafka集群配置及配置文件","date":"2018-08-13T06:54:35.320Z","toc":true,"_content":"\n[TOC]\n\n\n\n\n\n# Kafka集群部署\n\nkafka默认推荐的是2.11开头的，如果系统中没有其他软件依赖于Scala的话，就使用2.11版本的 \nscala是依赖于zookeeper的，所以需要给zookeeper配置地址\n\n<!-- more -->\n\n\n\n# 1、下载安装包\n\n<http://kafka.apache.org/downloads.html> \n在linux中使用wget命令下载安装包 \nwget <http://mirrors.hust.edu.cn/apache/kafka/0.8.2.2/kafka_2.11-0.8.2.2.tgz>\n\n# 2、解压安装包\n\n```\ntar -zxvf kafka_2.11-0.8.2.2.tgz -C /home/bigdata/apps/kafka/\ncd /home/bigdata/apps/kafka/\nln -s kafka_2.11-0.8.2.2 kafka\n\n```\n\n# 3、修改配置文件\n\n配置文件有4个点\n\nhostname应该保持一致\n\n```\nbroker.id =0\n#每一个broker在集群中的唯一表示，要求是正数。当该服务器的IP地址发生改变时，broker.id没有变化，则不会影响consumers的消息情况\n  log.dirs=/home/bigdata/logs/kafka-logs\n#kafka数据的存放地址，多个地址的话用逗号分割 /data/kafka-logs-1，/data/kafka-logs-2\n  port =9092\n#broker server服务端口\n  message.max.bytes =6525000\n#表示消息体的最大大小，单位是字节\n  num.network.threads =3\n#broker处理消息的最大线程数，一般情况下不需要去修改 配置了三台服务器，所以选择三个\n  #num.io.threads =8\n#broker处理磁盘IO的线程数，数值应该大于你的硬盘数\n  #background.threads =4\n#一些后台任务处理的线程数，例如过期消息文件的删除等，一般情况下不需要去做修改\n  queued.max.requests =500\n#等待IO线程处理的请求队列最大数，若是等待IO的请求超过这个数值，那么会停止接受外部消息，应该是一种自我保护机制。\n#broker的主机地址，若是设置了，那么会绑定到这个地址上，若是没有，会绑定到所有的接口上，并将其中之一发送到ZK，一般不设置\n  socket.send.buffer.bytes=102400\n#socket的发送缓冲区，socket的调优参数SO_SNDBUFF\n  socket.receive.buffer.bytes =102400\n#socket的接受缓冲区，socket的调优参数SO_RCVBUFF\n  socket.request.max.bytes =104857600\n#socket请求的最大数值，防止serverOOM，message.max.bytes必然要小于socket.request.max.bytes，会被topic创建时的指定参数覆盖\n   #log.segment.bytes =1024*1024*1024\n#topic的分区是以一堆segment文件存储的，这个控制每个segment的大小，会被topic创建时的指定参数覆盖\n  log.roll.hours =168\n  zookeeper.connect = bigdata1:2181,bigdata2:2181,bigdata3:2181\n#zookeeper集群的地址，可以是多个，多个之间用逗号分割 hostname1:port1,hostname2:port2,hostname3:port3\n  zookeeper.session.timeout.ms=6000\n#ZooKeeper的最大超时时间，就是心跳的间隔，若是没有反映，那么认为已经死了，不易过大\n  zookeeper.connection.timeout.ms =6000\n#ZooKeeper的连接超时时间\n  zookeeper.sync.time.ms =2000\n#host.name=bigdata1\n #broker的主机地址，若是设置了，那么会绑定到这个地址上，若是没有，会绑定到所有的接口上，并将其中之一发送到ZK，一般不设置,hostname为主机\n \n# 这个是轻量的配置文件\n#broker的全局唯一编号，不能重复\nbroker.id=0\n#用来监听连接的端口，producer或consumer将在此端口建立连接\nport=9092\n#处理网络请求的线程数量，集群中有几个节点就设置几个\nnum.network.threads=3\n#用来处理磁盘io的线程数量\nnum.io.threads=8\n#发送套接字的缓冲区大小\nsocket.send.buffer.bytes=102400\n#接受套接字的缓冲区大小\nsocket.receive.buffer.bytes=102400\n#请求套接字的缓冲区大小\nsocket.request.max.bytes=104857600\n#kafka运行日志存放的路径\nlog.dirs=/home/hadoop/logs/kafka\n#topic在当前broker上的分片个数\nnum.partitions=2\n#用来恢复和清理data下数据的线程数量\nnum.recovery.threads.per.data.dir=1\n#segment文件保留的最长时间。超时将会被删除\nlog.retention.hours=168\n#滚动删除生成心得segment文件的最大时间\nlog.roll.hour=168\n\n```\n\n `------------------`\n\n```\nip（重要），如果不改，则客户端会抛出：producer connection to localhost:9092 unsuccessful错误，\nadvertised.host.name=192.168.11.11\n\n```\n\n\\```\n\n```\ncp  /home/bigdata/apps/kafka/config/server.properties /home/bigdata/apps/kafka/config/server.properties.bak\nvi  /home/bigdata/apps/kafka/config/server.properties\n\n```\n\n# 4、分发安装包\n\n```\nscp -r /home/bigdata/apps/kafka/ bigdata2:/home/bigdata/apps/\n\n```\n\n然后分别在各机器上创建软连\n\n```\ncd /home/bigdata/apps/kafka\nln -s kafka_2.11-0.8.2.2 kafka\n\n```\n\n# 5、再次修改配置文件（重要）\n\n```\n依次修改各服务器上配置文件的的broker.id，分别是0,1,2不得重复。\n```\n\n# 需要配置kafka的环境变量\n\n# 6、启动集群\n\n**依次在各节点上启动kafka** \n后台启动 `nohup最后加一个&` \n\n```bash\nKAFKA_HOME/bin/kafka-server-start.sh  KAFKA_HOME/config/server.properties &\n```\n\n\n\n# 配置文件及注释\n\n```\nbroker.id=0\n#当前机器在集群中的唯一标识，和zookeeper的myid性质一样\nport=9092\n#当前kafka对外提供服务的端口默认是9092\nhost.name=192.168.11.11\nadvertised.host.name=192.168.11.11\n#这个参数默认是关闭的，在0.8.1有个bug，DNS解析问题，失败率的问题。\nnum.network.threads=3\n#这个是borker进行网络处理的线程数\nnum.io.threads=8\n#这个是borker进行I/O处理的线程数\nlog.dirs=/home/bigdata/apps/kafka/kafkalogs/\n#消息存放的目录，这个目录可以配置为“，”逗号分割的表达式，上面的num.io.threads要大于这个目录的个数这个目录，如果配置多个目录，新创建的topic他把消息持久化的地方是，当前以逗号分割的目录中，那个分区数最少就放那一个\nsocket.send.buffer.bytes=102400\n#发送缓冲区buffer大小，数据不是一下子就发送的，先回存储到缓冲区了到达一定的大小后在发送，能提高性能\nsocket.receive.buffer.bytes=102400\n#kafka接收缓冲区大小，当数据到达一定大小后在序列化到磁盘\nsocket.request.max.bytes=104857600\n#这个参数是向kafka请求消息或者向kafka发送消息的请请求的最大数，这个值不能超过java的堆栈大小\nnum.partitions=1\n#默认的分区数，一个topic默认1个分区数\nlog.retention.hours=168\n#默认消息的最大持久化时间，168小时，7天\n\n\nmessage.max.bytes=5242880\n#消息保存的最大值5M\ndefault.replication.factor=2\n#kafka保存消息的副本数，如果一个副本失效了，另一个还可以继续提供服务\nreplica.fetch.max.bytes=5242880\n#取消息的最大直接数\nlog.segment.bytes=1073741824\n#这个参数是：因为kafka的消息是以追加的形式落地到文件，当超过这个值的时候，kafka会新起一个文件\nlog.retention.check.interval.ms=300000\n#每隔300000毫秒去检查上面配置的log失效时间（log.retention.hours=168 ），到目录查看是否有过期的消息如果有，删除\nlog.cleaner.enable=false\n#是否启用log压缩，一般不用启用，启用的话可以提高性能\nzookeeper.connect=192.168.11.11:2181,192.168.11.12:2181,192.168.11.13:2181\n#设置zookeeper的连接端口\n```\n\n# 常用\n\n```\nbroker.id =0\n#每一个broker在集群中的唯一表示，要求是正数。当该服务器的IP地址发生改变时，broker.id没有变化，则不会影响consumers的消息情况\nlog.dirs=/data/kafka-logs\n#kafka数据的存放地址，多个地址的话用逗号分割 /data/kafka-logs-1，/data/kafka-logs-2\nport =9092\n#broker server服务端口\nmessage.max.bytes =6525000\n#表示消息体的最大大小，单位是字节\nnum.network.threads =3\n#broker处理消息的最大线程数，一般情况下不需要去修改 配置了三台服务器，所以选择三个\nnum.io.threads =8\n#broker处理磁盘IO的线程数，数值应该大于你的硬盘数\nbackground.threads =4\n#一些后台任务处理的线程数，例如过期消息文件的删除等，一般情况下不需要去做修改\nqueued.max.requests =500\n#等待IO线程处理的请求队列最大数，若是等待IO的请求超过这个数值，那么会停止接受外部消息，应该是一种自我保护机制。\nsocket.send.buffer.bytes=100*1024\n#socket的发送缓冲区，socket的调优参数SO_SNDBUFF\nsocket.receive.buffer.bytes =100*1024\n#socket的接受缓冲区，socket的调优参数SO_RCVBUFF\nsocket.request.max.bytes =100*1024*1024\n#socket请求的最大数值，防止serverOOM，message.max.bytes必然要小于socket.request.max.bytes，会被topic创建时的指定参数覆盖\nlog.segment.bytes =1024*1024*1024\n#topic的分区是以一堆segment文件存储的，这个控制每个segment的大小，会被topic创建时的指定参数覆盖\nlog.roll.hours =24*7\n\n```\n\n# 详解\n\n```\nbroker.id =0\n#每一个broker在集群中的唯一表示，要求是正数。当该服务器的IP地址发生改变时，broker.id没有变化，则不会影响consumers的消息情况\nlog.dirs=/data/kafka-logs\n#kafka数据的存放地址，多个地址的话用逗号分割 /data/kafka-logs-1，/data/kafka-logs-2\nport =9092\n#broker server服务端口\nmessage.max.bytes =6525000\n#表示消息体的最大大小，单位是字节\nnum.network.threads =4\n#broker处理消息的最大线程数，一般情况下不需要去修改\nnum.io.threads =8\n#broker处理磁盘IO的线程数，数值应该大于你的硬盘数\nbackground.threads =4\n#一些后台任务处理的线程数，例如过期消息文件的删除等，一般情况下不需要去做修改\nqueued.max.requests =500\n#等待IO线程处理的请求队列最大数，若是等待IO的请求超过这个数值，那么会停止接受外部消息，应该是一种自我保护机制。\nhost.name\n#broker的主机地址，若是设置了，那么会绑定到这个地址上，若是没有，会绑定到所有的接口上，并将其中之一发送到ZK，一般不设置\nsocket.send.buffer.bytes=100*1024\n#socket的发送缓冲区，socket的调优参数SO_SNDBUFF\nsocket.receive.buffer.bytes =100*1024\n#socket的接受缓冲区，socket的调优参数SO_RCVBUFF\nsocket.request.max.bytes =100*1024*1024\n#socket请求的最大数值，防止serverOOM，message.max.bytes必然要小于socket.request.max.bytes，会被topic创建时的指定参数覆盖\nlog.segment.bytes =1024*1024*1024\n#topic的分区是以一堆segment文件存储的，这个控制每个segment的大小，会被topic创建时的指定参数覆盖\nlog.roll.hours =24*7\n#这个参数会在日志segment没有达到log.segment.bytes设置的大小，也会强制新建一个segment会被 topic创建时的指定参数覆盖\nlog.cleanup.policy = delete\n#日志清理策略选择有：delete和compact主要针对过期数据的处理，或是日志文件达到限制的额度，会被 topic创建时的指定参数覆盖\nlog.retention.minutes=60*24 # 一天后删除\n#数据存储的最大时间超过这个时间会根据log.cleanup.policy设置的策略处理数据，也就是消费端能够多久去消费数据\n#log.retention.bytes和log.retention.minutes任意一个达到要求，都会执行删除，会被topic创建时的指定参数覆盖\nlog.retention.bytes=-1\n#topic每个分区的最大文件大小，一个topic的大小限制 = 分区数*log.retention.bytes。-1没有大小限log.retention.bytes和log.retention.minutes任意一个达到要求，都会执行删除，会被topic创建时的指定参数覆盖\nlog.retention.check.interval.ms=5minutes\n#文件大小检查的周期时间，是否处罚 log.cleanup.policy中设置的策略\nlog.cleaner.enable=false\n#是否开启日志压缩\nlog.cleaner.threads = 2\n#日志压缩运行的线程数\nlog.cleaner.io.max.bytes.per.second=None\n#日志压缩时候处理的最大大小\nlog.cleaner.dedupe.buffer.size=500*1024*1024\n#日志压缩去重时候的缓存空间，在空间允许的情况下，越大越好\nlog.cleaner.io.buffer.size=512*1024\n#日志清理时候用到的IO块大小一般不需要修改\nlog.cleaner.io.buffer.load.factor =0.9\n#日志清理中hash表的扩大因子一般不需要修改\nlog.cleaner.backoff.ms =15000\n#检查是否处罚日志清理的间隔\nlog.cleaner.min.cleanable.ratio=0.5\n#日志清理的频率控制，越大意味着更高效的清理，同时会存在一些空间上的浪费，会被topic创建时的指定参数覆盖\nlog.cleaner.delete.retention.ms =1day\n#对于压缩的日志保留的最长时间，也是客户端消费消息的最长时间，同log.retention.minutes的区别在于一个控制未压缩数据，一个控制压缩后的数据。会被topic创建时的指定参数覆盖\nlog.index.size.max.bytes =10*1024*1024\n#对于segment日志的索引文件大小限制，会被topic创建时的指定参数覆盖\nlog.index.interval.bytes =4096\n#当执行一个fetch操作后，需要一定的空间来扫描最近的offset大小，设置越大，代表扫描速度越快，但是也更好内存，一般情况下不需要搭理这个参数\nlog.flush.interval.messages=None\n#log文件”sync”到磁盘之前累积的消息条数,因为磁盘IO操作是一个慢操作,但又是一个”数据可靠性\"的必要手段,所以此参数的设置,需要在\"数据可靠性\"与\"性能\"之间做必要的权衡.如果此值过大,将会导致每次\"fsync\"的时间较长(IO阻塞),如果此值过小,将会导致\"fsync\"的次数较多,这也意味着整体的client请求有一定的延迟.物理server故障,将会导致没有fsync的消息丢失.\nlog.flush.scheduler.interval.ms =3000\n#检查是否需要固化到硬盘的时间间隔\nlog.flush.interval.ms = None\n#仅仅通过interval来控制消息的磁盘写入时机,是不足的.此参数用于控制\"fsync\"的时间间隔,如果消息量始终没有达到阀值,但是离上一次磁盘同步的时间间隔达到阀值,也将触发.\nlog.delete.delay.ms =60000\n#文件在索引中清除后保留的时间一般不需要去修改\nlog.flush.offset.checkpoint.interval.ms =60000\n#控制上次固化硬盘的时间点，以便于数据恢复一般不需要去修改\nauto.create.topics.enable =true\n#是否允许自动创建topic，若是false，就需要通过命令创建topic\ndefault.replication.factor =1\n#是否允许自动创建topic，若是false，就需要通过命令创建topic\nnum.partitions =1\n#每个topic的分区个数，若是在topic创建时候没有指定的话会被topic创建时的指定参数覆盖\n\n\n##这是轻量级的配置文件\nbroker.id=0\n#当前机器在集群中的唯一标识，和zookeeper的myid性质一样\nport=9092\n#当前kafka对外提供服务的端口默认是9092\nhost.name=192.168.11.11\n#这个参数默认是关闭的，在0.8.1有个bug，DNS解析问题，失败率的问题。\nnum.network.threads=3\n#这个是borker进行网络处理的线程数\nnum.io.threads=8\n#这个是borker进行I/O处理的线程数\nlog.dirs=/home/hadoop/logs/kafka-logs \n#消息存放的目录，这个目录可以配置为“，”逗号分割的表达式，上面的num.io.threads要大于这个目录的个数这个目录，如果配置多个目录，新创建的topic他把消息持久化的地方是，当前以逗号分割的目录中，那个分区数最少就放那一个\nsocket.send.buffer.bytes=102400\n#发送缓冲区buffer大小，数据不是一下子就发送的，先回存储到缓冲区了到达一定的大小后在发送，能提高性能\nsocket.receive.buffer.bytes=102400\n#kafka接收缓冲区大小，当数据到达一定大小后在序列化到磁盘\nsocket.request.max.bytes=104857600\n#这个参数是向kafka请求消息或者向kafka发送消息的请请求的最大数，这个值不能超过java的堆栈大小\nnum.partitions=1\n#默认的分区数，一个topic默认1个分区数\nlog.retention.hours=168\n#默认消息的最大持久化时间，168小时，7天\nmessage.max.byte=5242880\n#消息保存的最大值5M\ndefault.replication.factor=2\n#kafka保存消息的副本数，如果一个副本失效了，另一个还可以继续提供服务\nreplica.fetch.max.bytes=5242880\n#取消息的最大直接数\nlog.segment.bytes=1073741824\n#这个参数是：因为kafka的消息是以追加的形式落地到文件，当超过这个值的时候，kafka会新起一个文件\nlog.retention.check.interval.ms=300000\n#每隔300000毫秒去检查上面配置的log失效时间（log.retention.hours=168 ），到目录查看是否有过期的消息如果有，删除\nlog.cleaner.enable=false\n#是否启用log压缩，一般不用启用，启用的话可以提高性能\nzookeeper.connect=192.168.11.11:2181,192.168.11.12:2181,192.168.11.13:2181\n#设置zookeeper的连接端口\n\n```\n\n# 以下是kafka中Leader,replicas配置参数\n\n```\ncontroller.socket.timeout.ms =30000\n#partition leader与replicas之间通讯时,socket的超时时间\ncontroller.message.queue.size=10\n#partition leader与replicas数据同步时,消息的队列尺寸\nreplica.lag.time.max.ms =10000\n#replicas响应partition leader的最长等待时间，若是超过这个时间，就将replicas列入ISR(in-sync replicas)，并认为它是死的，不会再加入管理中\nreplica.lag.max.messages =4000\n#如果follower落后与leader太多,将会认为此follower[或者说partition relicas]已经失效\n###通常,在follower与leader通讯时,因为网络延迟或者链接断开,总会导致replicas中消息同步滞后\n##如果消息之后太多,leader将认为此follower网络延迟较大或者消息吞吐能力有限,将会把此replicas迁移\n##到其他follower中.\n##在broker数量较少,或者网络不足的环境中,建议提高此值.\nreplica.socket.timeout.ms=30*1000\n#follower与leader之间的socket超时时间\nreplica.socket.receive.buffer.bytes=64*1024\n#leader复制时候的socket缓存大小\nreplica.fetch.max.bytes =1024*1024\n#replicas每次获取数据的最大大小\nreplica.fetch.wait.max.ms =500\n#replicas同leader之间通信的最大等待时间，失败了会重试\nreplica.fetch.min.bytes =1\n#fetch的最小数据尺寸,如果leader中尚未同步的数据不足此值,将会阻塞,直到满足条件\nnum.replica.fetchers=1\n#leader进行复制的线程数，增大这个数值会增加follower的IO\nreplica.high.watermark.checkpoint.interval.ms =5000\n#每个replica检查是否将最高水位进行固化的频率\ncontrolled.shutdown.enable =false\n#是否允许控制器关闭broker ,若是设置为true,会关闭所有在这个broker上的leader，并转移到其他broker\ncontrolled.shutdown.max.retries =3\n#控制器关闭的尝试次数\ncontrolled.shutdown.retry.backoff.ms =5000\n#每次关闭尝试的时间间隔\nleader.imbalance.per.broker.percentage =10\n#leader的不平衡比例，若是超过这个数值，会对分区进行重新的平衡\nleader.imbalance.check.interval.seconds =300\n#检查leader是否不平衡的时间间隔\noffset.metadata.max.bytes\n#客户端保留offset信息的最大空间大小\n\n```\n\n# kafka中zookeeper参数配置\n\n```\nzookeeper.connect = bigdata1:2181,bigdata2:2181,bigdata3:2181\n#zookeeper集群的地址，可以是多个，多个之间用逗号分割 hostname1:port1,hostname2:port2,hostname3:port3\nzookeeper.session.timeout.ms=6000\n#ZooKeeper的最大超时时间，就是心跳的间隔，若是没有反映，那么认为已经死了，不易过大\nzookeeper.connection.timeout.ms =6000\n#ZooKeeper的连接超时时间\nzookeeper.sync.time.ms =2000\n```","source":"_posts/Kafka集群配置及配置文件.md","raw":"---\ntitle: Kafka集群配置及配置文件\ndate: 2018年08月06日 22时15分52秒\ntags: [Kafka,大数据]\ncategories: 安装部署\ntoc: true\n---\n\n[TOC]\n\n\n\n\n\n# Kafka集群部署\n\nkafka默认推荐的是2.11开头的，如果系统中没有其他软件依赖于Scala的话，就使用2.11版本的 \nscala是依赖于zookeeper的，所以需要给zookeeper配置地址\n\n<!-- more -->\n\n\n\n# 1、下载安装包\n\n<http://kafka.apache.org/downloads.html> \n在linux中使用wget命令下载安装包 \nwget <http://mirrors.hust.edu.cn/apache/kafka/0.8.2.2/kafka_2.11-0.8.2.2.tgz>\n\n# 2、解压安装包\n\n```\ntar -zxvf kafka_2.11-0.8.2.2.tgz -C /home/bigdata/apps/kafka/\ncd /home/bigdata/apps/kafka/\nln -s kafka_2.11-0.8.2.2 kafka\n\n```\n\n# 3、修改配置文件\n\n配置文件有4个点\n\nhostname应该保持一致\n\n```\nbroker.id =0\n#每一个broker在集群中的唯一表示，要求是正数。当该服务器的IP地址发生改变时，broker.id没有变化，则不会影响consumers的消息情况\n  log.dirs=/home/bigdata/logs/kafka-logs\n#kafka数据的存放地址，多个地址的话用逗号分割 /data/kafka-logs-1，/data/kafka-logs-2\n  port =9092\n#broker server服务端口\n  message.max.bytes =6525000\n#表示消息体的最大大小，单位是字节\n  num.network.threads =3\n#broker处理消息的最大线程数，一般情况下不需要去修改 配置了三台服务器，所以选择三个\n  #num.io.threads =8\n#broker处理磁盘IO的线程数，数值应该大于你的硬盘数\n  #background.threads =4\n#一些后台任务处理的线程数，例如过期消息文件的删除等，一般情况下不需要去做修改\n  queued.max.requests =500\n#等待IO线程处理的请求队列最大数，若是等待IO的请求超过这个数值，那么会停止接受外部消息，应该是一种自我保护机制。\n#broker的主机地址，若是设置了，那么会绑定到这个地址上，若是没有，会绑定到所有的接口上，并将其中之一发送到ZK，一般不设置\n  socket.send.buffer.bytes=102400\n#socket的发送缓冲区，socket的调优参数SO_SNDBUFF\n  socket.receive.buffer.bytes =102400\n#socket的接受缓冲区，socket的调优参数SO_RCVBUFF\n  socket.request.max.bytes =104857600\n#socket请求的最大数值，防止serverOOM，message.max.bytes必然要小于socket.request.max.bytes，会被topic创建时的指定参数覆盖\n   #log.segment.bytes =1024*1024*1024\n#topic的分区是以一堆segment文件存储的，这个控制每个segment的大小，会被topic创建时的指定参数覆盖\n  log.roll.hours =168\n  zookeeper.connect = bigdata1:2181,bigdata2:2181,bigdata3:2181\n#zookeeper集群的地址，可以是多个，多个之间用逗号分割 hostname1:port1,hostname2:port2,hostname3:port3\n  zookeeper.session.timeout.ms=6000\n#ZooKeeper的最大超时时间，就是心跳的间隔，若是没有反映，那么认为已经死了，不易过大\n  zookeeper.connection.timeout.ms =6000\n#ZooKeeper的连接超时时间\n  zookeeper.sync.time.ms =2000\n#host.name=bigdata1\n #broker的主机地址，若是设置了，那么会绑定到这个地址上，若是没有，会绑定到所有的接口上，并将其中之一发送到ZK，一般不设置,hostname为主机\n \n# 这个是轻量的配置文件\n#broker的全局唯一编号，不能重复\nbroker.id=0\n#用来监听连接的端口，producer或consumer将在此端口建立连接\nport=9092\n#处理网络请求的线程数量，集群中有几个节点就设置几个\nnum.network.threads=3\n#用来处理磁盘io的线程数量\nnum.io.threads=8\n#发送套接字的缓冲区大小\nsocket.send.buffer.bytes=102400\n#接受套接字的缓冲区大小\nsocket.receive.buffer.bytes=102400\n#请求套接字的缓冲区大小\nsocket.request.max.bytes=104857600\n#kafka运行日志存放的路径\nlog.dirs=/home/hadoop/logs/kafka\n#topic在当前broker上的分片个数\nnum.partitions=2\n#用来恢复和清理data下数据的线程数量\nnum.recovery.threads.per.data.dir=1\n#segment文件保留的最长时间。超时将会被删除\nlog.retention.hours=168\n#滚动删除生成心得segment文件的最大时间\nlog.roll.hour=168\n\n```\n\n `------------------`\n\n```\nip（重要），如果不改，则客户端会抛出：producer connection to localhost:9092 unsuccessful错误，\nadvertised.host.name=192.168.11.11\n\n```\n\n\\```\n\n```\ncp  /home/bigdata/apps/kafka/config/server.properties /home/bigdata/apps/kafka/config/server.properties.bak\nvi  /home/bigdata/apps/kafka/config/server.properties\n\n```\n\n# 4、分发安装包\n\n```\nscp -r /home/bigdata/apps/kafka/ bigdata2:/home/bigdata/apps/\n\n```\n\n然后分别在各机器上创建软连\n\n```\ncd /home/bigdata/apps/kafka\nln -s kafka_2.11-0.8.2.2 kafka\n\n```\n\n# 5、再次修改配置文件（重要）\n\n```\n依次修改各服务器上配置文件的的broker.id，分别是0,1,2不得重复。\n```\n\n# 需要配置kafka的环境变量\n\n# 6、启动集群\n\n**依次在各节点上启动kafka** \n后台启动 `nohup最后加一个&` \n\n```bash\nKAFKA_HOME/bin/kafka-server-start.sh  KAFKA_HOME/config/server.properties &\n```\n\n\n\n# 配置文件及注释\n\n```\nbroker.id=0\n#当前机器在集群中的唯一标识，和zookeeper的myid性质一样\nport=9092\n#当前kafka对外提供服务的端口默认是9092\nhost.name=192.168.11.11\nadvertised.host.name=192.168.11.11\n#这个参数默认是关闭的，在0.8.1有个bug，DNS解析问题，失败率的问题。\nnum.network.threads=3\n#这个是borker进行网络处理的线程数\nnum.io.threads=8\n#这个是borker进行I/O处理的线程数\nlog.dirs=/home/bigdata/apps/kafka/kafkalogs/\n#消息存放的目录，这个目录可以配置为“，”逗号分割的表达式，上面的num.io.threads要大于这个目录的个数这个目录，如果配置多个目录，新创建的topic他把消息持久化的地方是，当前以逗号分割的目录中，那个分区数最少就放那一个\nsocket.send.buffer.bytes=102400\n#发送缓冲区buffer大小，数据不是一下子就发送的，先回存储到缓冲区了到达一定的大小后在发送，能提高性能\nsocket.receive.buffer.bytes=102400\n#kafka接收缓冲区大小，当数据到达一定大小后在序列化到磁盘\nsocket.request.max.bytes=104857600\n#这个参数是向kafka请求消息或者向kafka发送消息的请请求的最大数，这个值不能超过java的堆栈大小\nnum.partitions=1\n#默认的分区数，一个topic默认1个分区数\nlog.retention.hours=168\n#默认消息的最大持久化时间，168小时，7天\n\n\nmessage.max.bytes=5242880\n#消息保存的最大值5M\ndefault.replication.factor=2\n#kafka保存消息的副本数，如果一个副本失效了，另一个还可以继续提供服务\nreplica.fetch.max.bytes=5242880\n#取消息的最大直接数\nlog.segment.bytes=1073741824\n#这个参数是：因为kafka的消息是以追加的形式落地到文件，当超过这个值的时候，kafka会新起一个文件\nlog.retention.check.interval.ms=300000\n#每隔300000毫秒去检查上面配置的log失效时间（log.retention.hours=168 ），到目录查看是否有过期的消息如果有，删除\nlog.cleaner.enable=false\n#是否启用log压缩，一般不用启用，启用的话可以提高性能\nzookeeper.connect=192.168.11.11:2181,192.168.11.12:2181,192.168.11.13:2181\n#设置zookeeper的连接端口\n```\n\n# 常用\n\n```\nbroker.id =0\n#每一个broker在集群中的唯一表示，要求是正数。当该服务器的IP地址发生改变时，broker.id没有变化，则不会影响consumers的消息情况\nlog.dirs=/data/kafka-logs\n#kafka数据的存放地址，多个地址的话用逗号分割 /data/kafka-logs-1，/data/kafka-logs-2\nport =9092\n#broker server服务端口\nmessage.max.bytes =6525000\n#表示消息体的最大大小，单位是字节\nnum.network.threads =3\n#broker处理消息的最大线程数，一般情况下不需要去修改 配置了三台服务器，所以选择三个\nnum.io.threads =8\n#broker处理磁盘IO的线程数，数值应该大于你的硬盘数\nbackground.threads =4\n#一些后台任务处理的线程数，例如过期消息文件的删除等，一般情况下不需要去做修改\nqueued.max.requests =500\n#等待IO线程处理的请求队列最大数，若是等待IO的请求超过这个数值，那么会停止接受外部消息，应该是一种自我保护机制。\nsocket.send.buffer.bytes=100*1024\n#socket的发送缓冲区，socket的调优参数SO_SNDBUFF\nsocket.receive.buffer.bytes =100*1024\n#socket的接受缓冲区，socket的调优参数SO_RCVBUFF\nsocket.request.max.bytes =100*1024*1024\n#socket请求的最大数值，防止serverOOM，message.max.bytes必然要小于socket.request.max.bytes，会被topic创建时的指定参数覆盖\nlog.segment.bytes =1024*1024*1024\n#topic的分区是以一堆segment文件存储的，这个控制每个segment的大小，会被topic创建时的指定参数覆盖\nlog.roll.hours =24*7\n\n```\n\n# 详解\n\n```\nbroker.id =0\n#每一个broker在集群中的唯一表示，要求是正数。当该服务器的IP地址发生改变时，broker.id没有变化，则不会影响consumers的消息情况\nlog.dirs=/data/kafka-logs\n#kafka数据的存放地址，多个地址的话用逗号分割 /data/kafka-logs-1，/data/kafka-logs-2\nport =9092\n#broker server服务端口\nmessage.max.bytes =6525000\n#表示消息体的最大大小，单位是字节\nnum.network.threads =4\n#broker处理消息的最大线程数，一般情况下不需要去修改\nnum.io.threads =8\n#broker处理磁盘IO的线程数，数值应该大于你的硬盘数\nbackground.threads =4\n#一些后台任务处理的线程数，例如过期消息文件的删除等，一般情况下不需要去做修改\nqueued.max.requests =500\n#等待IO线程处理的请求队列最大数，若是等待IO的请求超过这个数值，那么会停止接受外部消息，应该是一种自我保护机制。\nhost.name\n#broker的主机地址，若是设置了，那么会绑定到这个地址上，若是没有，会绑定到所有的接口上，并将其中之一发送到ZK，一般不设置\nsocket.send.buffer.bytes=100*1024\n#socket的发送缓冲区，socket的调优参数SO_SNDBUFF\nsocket.receive.buffer.bytes =100*1024\n#socket的接受缓冲区，socket的调优参数SO_RCVBUFF\nsocket.request.max.bytes =100*1024*1024\n#socket请求的最大数值，防止serverOOM，message.max.bytes必然要小于socket.request.max.bytes，会被topic创建时的指定参数覆盖\nlog.segment.bytes =1024*1024*1024\n#topic的分区是以一堆segment文件存储的，这个控制每个segment的大小，会被topic创建时的指定参数覆盖\nlog.roll.hours =24*7\n#这个参数会在日志segment没有达到log.segment.bytes设置的大小，也会强制新建一个segment会被 topic创建时的指定参数覆盖\nlog.cleanup.policy = delete\n#日志清理策略选择有：delete和compact主要针对过期数据的处理，或是日志文件达到限制的额度，会被 topic创建时的指定参数覆盖\nlog.retention.minutes=60*24 # 一天后删除\n#数据存储的最大时间超过这个时间会根据log.cleanup.policy设置的策略处理数据，也就是消费端能够多久去消费数据\n#log.retention.bytes和log.retention.minutes任意一个达到要求，都会执行删除，会被topic创建时的指定参数覆盖\nlog.retention.bytes=-1\n#topic每个分区的最大文件大小，一个topic的大小限制 = 分区数*log.retention.bytes。-1没有大小限log.retention.bytes和log.retention.minutes任意一个达到要求，都会执行删除，会被topic创建时的指定参数覆盖\nlog.retention.check.interval.ms=5minutes\n#文件大小检查的周期时间，是否处罚 log.cleanup.policy中设置的策略\nlog.cleaner.enable=false\n#是否开启日志压缩\nlog.cleaner.threads = 2\n#日志压缩运行的线程数\nlog.cleaner.io.max.bytes.per.second=None\n#日志压缩时候处理的最大大小\nlog.cleaner.dedupe.buffer.size=500*1024*1024\n#日志压缩去重时候的缓存空间，在空间允许的情况下，越大越好\nlog.cleaner.io.buffer.size=512*1024\n#日志清理时候用到的IO块大小一般不需要修改\nlog.cleaner.io.buffer.load.factor =0.9\n#日志清理中hash表的扩大因子一般不需要修改\nlog.cleaner.backoff.ms =15000\n#检查是否处罚日志清理的间隔\nlog.cleaner.min.cleanable.ratio=0.5\n#日志清理的频率控制，越大意味着更高效的清理，同时会存在一些空间上的浪费，会被topic创建时的指定参数覆盖\nlog.cleaner.delete.retention.ms =1day\n#对于压缩的日志保留的最长时间，也是客户端消费消息的最长时间，同log.retention.minutes的区别在于一个控制未压缩数据，一个控制压缩后的数据。会被topic创建时的指定参数覆盖\nlog.index.size.max.bytes =10*1024*1024\n#对于segment日志的索引文件大小限制，会被topic创建时的指定参数覆盖\nlog.index.interval.bytes =4096\n#当执行一个fetch操作后，需要一定的空间来扫描最近的offset大小，设置越大，代表扫描速度越快，但是也更好内存，一般情况下不需要搭理这个参数\nlog.flush.interval.messages=None\n#log文件”sync”到磁盘之前累积的消息条数,因为磁盘IO操作是一个慢操作,但又是一个”数据可靠性\"的必要手段,所以此参数的设置,需要在\"数据可靠性\"与\"性能\"之间做必要的权衡.如果此值过大,将会导致每次\"fsync\"的时间较长(IO阻塞),如果此值过小,将会导致\"fsync\"的次数较多,这也意味着整体的client请求有一定的延迟.物理server故障,将会导致没有fsync的消息丢失.\nlog.flush.scheduler.interval.ms =3000\n#检查是否需要固化到硬盘的时间间隔\nlog.flush.interval.ms = None\n#仅仅通过interval来控制消息的磁盘写入时机,是不足的.此参数用于控制\"fsync\"的时间间隔,如果消息量始终没有达到阀值,但是离上一次磁盘同步的时间间隔达到阀值,也将触发.\nlog.delete.delay.ms =60000\n#文件在索引中清除后保留的时间一般不需要去修改\nlog.flush.offset.checkpoint.interval.ms =60000\n#控制上次固化硬盘的时间点，以便于数据恢复一般不需要去修改\nauto.create.topics.enable =true\n#是否允许自动创建topic，若是false，就需要通过命令创建topic\ndefault.replication.factor =1\n#是否允许自动创建topic，若是false，就需要通过命令创建topic\nnum.partitions =1\n#每个topic的分区个数，若是在topic创建时候没有指定的话会被topic创建时的指定参数覆盖\n\n\n##这是轻量级的配置文件\nbroker.id=0\n#当前机器在集群中的唯一标识，和zookeeper的myid性质一样\nport=9092\n#当前kafka对外提供服务的端口默认是9092\nhost.name=192.168.11.11\n#这个参数默认是关闭的，在0.8.1有个bug，DNS解析问题，失败率的问题。\nnum.network.threads=3\n#这个是borker进行网络处理的线程数\nnum.io.threads=8\n#这个是borker进行I/O处理的线程数\nlog.dirs=/home/hadoop/logs/kafka-logs \n#消息存放的目录，这个目录可以配置为“，”逗号分割的表达式，上面的num.io.threads要大于这个目录的个数这个目录，如果配置多个目录，新创建的topic他把消息持久化的地方是，当前以逗号分割的目录中，那个分区数最少就放那一个\nsocket.send.buffer.bytes=102400\n#发送缓冲区buffer大小，数据不是一下子就发送的，先回存储到缓冲区了到达一定的大小后在发送，能提高性能\nsocket.receive.buffer.bytes=102400\n#kafka接收缓冲区大小，当数据到达一定大小后在序列化到磁盘\nsocket.request.max.bytes=104857600\n#这个参数是向kafka请求消息或者向kafka发送消息的请请求的最大数，这个值不能超过java的堆栈大小\nnum.partitions=1\n#默认的分区数，一个topic默认1个分区数\nlog.retention.hours=168\n#默认消息的最大持久化时间，168小时，7天\nmessage.max.byte=5242880\n#消息保存的最大值5M\ndefault.replication.factor=2\n#kafka保存消息的副本数，如果一个副本失效了，另一个还可以继续提供服务\nreplica.fetch.max.bytes=5242880\n#取消息的最大直接数\nlog.segment.bytes=1073741824\n#这个参数是：因为kafka的消息是以追加的形式落地到文件，当超过这个值的时候，kafka会新起一个文件\nlog.retention.check.interval.ms=300000\n#每隔300000毫秒去检查上面配置的log失效时间（log.retention.hours=168 ），到目录查看是否有过期的消息如果有，删除\nlog.cleaner.enable=false\n#是否启用log压缩，一般不用启用，启用的话可以提高性能\nzookeeper.connect=192.168.11.11:2181,192.168.11.12:2181,192.168.11.13:2181\n#设置zookeeper的连接端口\n\n```\n\n# 以下是kafka中Leader,replicas配置参数\n\n```\ncontroller.socket.timeout.ms =30000\n#partition leader与replicas之间通讯时,socket的超时时间\ncontroller.message.queue.size=10\n#partition leader与replicas数据同步时,消息的队列尺寸\nreplica.lag.time.max.ms =10000\n#replicas响应partition leader的最长等待时间，若是超过这个时间，就将replicas列入ISR(in-sync replicas)，并认为它是死的，不会再加入管理中\nreplica.lag.max.messages =4000\n#如果follower落后与leader太多,将会认为此follower[或者说partition relicas]已经失效\n###通常,在follower与leader通讯时,因为网络延迟或者链接断开,总会导致replicas中消息同步滞后\n##如果消息之后太多,leader将认为此follower网络延迟较大或者消息吞吐能力有限,将会把此replicas迁移\n##到其他follower中.\n##在broker数量较少,或者网络不足的环境中,建议提高此值.\nreplica.socket.timeout.ms=30*1000\n#follower与leader之间的socket超时时间\nreplica.socket.receive.buffer.bytes=64*1024\n#leader复制时候的socket缓存大小\nreplica.fetch.max.bytes =1024*1024\n#replicas每次获取数据的最大大小\nreplica.fetch.wait.max.ms =500\n#replicas同leader之间通信的最大等待时间，失败了会重试\nreplica.fetch.min.bytes =1\n#fetch的最小数据尺寸,如果leader中尚未同步的数据不足此值,将会阻塞,直到满足条件\nnum.replica.fetchers=1\n#leader进行复制的线程数，增大这个数值会增加follower的IO\nreplica.high.watermark.checkpoint.interval.ms =5000\n#每个replica检查是否将最高水位进行固化的频率\ncontrolled.shutdown.enable =false\n#是否允许控制器关闭broker ,若是设置为true,会关闭所有在这个broker上的leader，并转移到其他broker\ncontrolled.shutdown.max.retries =3\n#控制器关闭的尝试次数\ncontrolled.shutdown.retry.backoff.ms =5000\n#每次关闭尝试的时间间隔\nleader.imbalance.per.broker.percentage =10\n#leader的不平衡比例，若是超过这个数值，会对分区进行重新的平衡\nleader.imbalance.check.interval.seconds =300\n#检查leader是否不平衡的时间间隔\noffset.metadata.max.bytes\n#客户端保留offset信息的最大空间大小\n\n```\n\n# kafka中zookeeper参数配置\n\n```\nzookeeper.connect = bigdata1:2181,bigdata2:2181,bigdata3:2181\n#zookeeper集群的地址，可以是多个，多个之间用逗号分割 hostname1:port1,hostname2:port2,hostname3:port3\nzookeeper.session.timeout.ms=6000\n#ZooKeeper的最大超时时间，就是心跳的间隔，若是没有反映，那么认为已经死了，不易过大\nzookeeper.connection.timeout.ms =6000\n#ZooKeeper的连接超时时间\nzookeeper.sync.time.ms =2000\n```","slug":"Kafka集群配置及配置文件","published":1,"updated":"2018-08-13T07:21:34.526Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloj0lls0023ykpby6ypiqxr"},{"title":"linux命令","date":"2018-05-10T07:37:28.983Z","toc":true,"_content":"\n\n简单linux命令\n\n`nohup   & ` \n后台运行\n\n<!-- more -->\n\n## 文件查找\n`find / -type f -size +10G`\n在Linux下如何让文件让按大小单位为M,G等易读格式，S size大小排序。  `ls -lhS`\n`du -h * | sort -n `  \n当然您也可以结合管道文件夹内最大的几个文件  ` du -h * | sort -n|head`\n动态显示机器各端口的链接情况`while :; do netstat -apn | grep \":80\" | wc -l; sleep 1; done`\n## sed\n更改第一行 `sed -i '1s/.*//'`     sed -i '1s/.*/想更改的内容/'\n\n```bash\nssh root@slave01 \"sed -i '6c advertised.host.name=slave01 ' $KAFKA_HOME/config/server.properties\"\n```\n\n删除第一行`sed -i '1d'  `     sed -i '1d' 文件名\n插入第一行 `sed -i '1i\\' `       sed -i ‘1i\\内容‘ 文件名\n\n## cpu\n`cat /proc/cpuinfo | grep processor | wc -l`\n`lscpu`\n\n## sz rz与服务器交互上传下载文件\n\n`sudo yum install lrzsz -y`\n\n## 挂载\n\n `sshfs  root@192.168.73.12:/home/ /csdn/win10/`\n\n即：sshfs 用户名@远程主机IP:远程主机路径 本地挂载点\nsshfs  root@master:/usr/hadoop  /usr/hive/hadoop\n\n## 查看端口是否被监听\n\n也可验证对应端口程序是否启动\n`netstat -nl|grep 10000`\n\n\n\n# 虚拟机共享文件夹\n\n在virtualbox中设置共享文件夹的share名称对应mac的目录\n虚拟机中的目录\nsudo mount -t vboxsf vagrant /Users/yaosong","source":"_posts/Linux命令积累.md","raw":"---\ntitle:  linux命令\ndate: 2018年08月11日 02时55分44秒\ntags:  [linux,开发]\ncategories: Linux\ntoc: true\n---\n\n\n简单linux命令\n\n`nohup   & ` \n后台运行\n\n<!-- more -->\n\n## 文件查找\n`find / -type f -size +10G`\n在Linux下如何让文件让按大小单位为M,G等易读格式，S size大小排序。  `ls -lhS`\n`du -h * | sort -n `  \n当然您也可以结合管道文件夹内最大的几个文件  ` du -h * | sort -n|head`\n动态显示机器各端口的链接情况`while :; do netstat -apn | grep \":80\" | wc -l; sleep 1; done`\n## sed\n更改第一行 `sed -i '1s/.*//'`     sed -i '1s/.*/想更改的内容/'\n\n```bash\nssh root@slave01 \"sed -i '6c advertised.host.name=slave01 ' $KAFKA_HOME/config/server.properties\"\n```\n\n删除第一行`sed -i '1d'  `     sed -i '1d' 文件名\n插入第一行 `sed -i '1i\\' `       sed -i ‘1i\\内容‘ 文件名\n\n## cpu\n`cat /proc/cpuinfo | grep processor | wc -l`\n`lscpu`\n\n## sz rz与服务器交互上传下载文件\n\n`sudo yum install lrzsz -y`\n\n## 挂载\n\n `sshfs  root@192.168.73.12:/home/ /csdn/win10/`\n\n即：sshfs 用户名@远程主机IP:远程主机路径 本地挂载点\nsshfs  root@master:/usr/hadoop  /usr/hive/hadoop\n\n## 查看端口是否被监听\n\n也可验证对应端口程序是否启动\n`netstat -nl|grep 10000`\n\n\n\n# 虚拟机共享文件夹\n\n在virtualbox中设置共享文件夹的share名称对应mac的目录\n虚拟机中的目录\nsudo mount -t vboxsf vagrant /Users/yaosong","slug":"Linux命令积累","published":1,"updated":"2018-08-24T02:14:22.229Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloj0llt0027ykpbiyqr5rra"},{"title":"Linux安装mysql","date":"2018-07-24T15:42:18.647Z","toc":true,"_content":"\n![](https://ws1.sinaimg.cn/large/006tNbRwgy1fu550945khj318w0n4wgq.jpg)\n\n在linux yum安装mysql\n\n<!--more -->\n\n```Bash\nyum install -y mysql-server\nchkconfig --add mysqld\nchkconfig mysqld on\nchkconfig --list mysqld\nservice mysqld start\nmysql -u root -p\nEnter password:           //默认密码为空，输入后回车即可\nset password for root@localhost=password('root'); 　　密码设置为root\nset password for root@=password('root');\n默认情况下Mysql只允许本地登录，所以只需配置root@localhost就好\n设置所有ip访问密码为root\nset password for root@%=password('root'); 　　　　　　密码设置为root （其实这一步可以不配）\n设置master访问密码为root\nset password for root@master=password('root'); 　　密码设置为root （其实这一步可以不配）\n查询密码\nselect user,host,password from mysql.user;  　　查看密码是否设置成功\n设置所有ip可以通过root访问\nGRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'root' WITH GRANT OPTION;\nGRANT ALL PRIVILEGES ON *.* TO 'hive'@'%' IDENTIFIED BY 'hive' WITH GRANT OPTION;\n\n\n```\n\n","source":"_posts/Linux安装mysql.md","raw":"---\ntitle:  Linux安装mysql\ndate: 2018年06月21日 22时15分52秒\ntags:  [Linux,Mysql]\ncategories: 安装部署\ntoc: true\n---\n\n![](https://ws1.sinaimg.cn/large/006tNbRwgy1fu550945khj318w0n4wgq.jpg)\n\n在linux yum安装mysql\n\n<!--more -->\n\n```Bash\nyum install -y mysql-server\nchkconfig --add mysqld\nchkconfig mysqld on\nchkconfig --list mysqld\nservice mysqld start\nmysql -u root -p\nEnter password:           //默认密码为空，输入后回车即可\nset password for root@localhost=password('root'); 　　密码设置为root\nset password for root@=password('root');\n默认情况下Mysql只允许本地登录，所以只需配置root@localhost就好\n设置所有ip访问密码为root\nset password for root@%=password('root'); 　　　　　　密码设置为root （其实这一步可以不配）\n设置master访问密码为root\nset password for root@master=password('root'); 　　密码设置为root （其实这一步可以不配）\n查询密码\nselect user,host,password from mysql.user;  　　查看密码是否设置成功\n设置所有ip可以通过root访问\nGRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'root' WITH GRANT OPTION;\nGRANT ALL PRIVILEGES ON *.* TO 'hive'@'%' IDENTIFIED BY 'hive' WITH GRANT OPTION;\n\n\n```\n\n","slug":"Linux安装mysql","published":1,"updated":"2018-08-10T17:52:56.914Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloj0llu002aykpb69h6jg13"},{"title":"MapReduce中Shuffle中的机制","date":"2018-08-20T02:12:26.791Z","toc":true,"_content":"\n[TOC]\n\n官方的shuffle流程\n\n![](https://ws2.sinaimg.cn/large/006tNbRwgy1fuhbmle6ksj30ff07dglu.jpg)\n\n# shuffle原理\n\n提到MapReduce，就不得不提一下shuffle。\n\nMapReduce 框架的核心步骤主要分两部分：Map 和Reduce，一个是独立并发，一个是汇聚。当你向MapReduce 框架提交一个计算作业时，它会首先把计算作业拆分成若干个Map 任务，然后分配到不同的节点上去执行，每一个Map 任务处理输入数据中的一部分，当Map 任务完成后，它会生成一些中间文件，这些中间文件将会作为Reduce 任务的输入数据。Reduce 任务的主要目标就是把前面若干个Map 的输出汇总到一起并输出。\n\n<!-- more -->\n\n 我们知道每个reduce task输入的key都是按照key排序的。但是每个map的输出只是简单的key-value而非key-valuelist，所以shuffle的工作就是将map输出转化为reducer的输入的过程。Shuffle过程是指map产生输出结果开始，包括系统执行分区partition，排序sort，聚合Combiner（如有）以及传送map的输出到Reducer作为输入的过程。\n\n## shuffle过程分析\n\n![](https://ws2.sinaimg.cn/large/006tNbRwgy1fuhbuwapflj30zc0j4mxv.jpg)\n\n\n\n\n\n## map端\n\n1. 从map段开始分析，当Map开始产生输出的时候，并不是简单吧数据写到磁盘，因为频繁的操作会导致性能严重下降，首先将数据写入到一个环形缓冲区（每个maptask都会有一个环形缓冲区，默认100M，可以通过io.sort.mb属性来设置具体的大小）并做一些预排序，以提升效率，当缓冲区中的数据量达到一个特定的阀值(io.sort.mb * io.sort.spill.percent，其中io.sort.spill.percent 默认是0.80，即默认为 80MB），溢写线程启动。\n\n2. 系统将会启动一个后台线程把缓冲区中的内容spill 到磁盘。即会锁定这80MB的内存，执行溢写过程。Map task的输出结果还可以往剩下的20MB内存中写，互不影响。在spill过程中，Map的输出将会继续写入到缓冲区，但如果缓冲区已经满了，Map就会被阻塞直到spill完成。spill线程在把缓冲区的数据写到磁盘前，会对他\n\n   进行一个**二次排序**，**首先根据数据所属的partition排序（快速排序），然后每个partition中再按Key排序**。输出包括一个**索引文件和数据文件**。\n\n3. 如果设定了Combiner，将在排序输出的基础上进行。Combiner就是一个Mini Reducer，它在执行Map任务的节点本身运行，先对Map的输出作一次简单的Reduce，有些数据可能像这样：`“a”/1， “a”/1， “a”/1，`会合并成 `“a”/3`，使得更少的数据会被写入磁盘和传送到Reducer。\n\n4. Spill文件保存在由mapred.local.dir指定的目录中，Map任务结束后删除。每当内存中的数据达到spill阀值的时候，都会产生一个新的spill文件，所以在Map任务写完他的最后一个输出记录的时候，可能会有多个spill文件，在Map任务完成前，所有的spill文件将会被归并排序为一个索引文件和数据文件。这是一个多路归并过程，最大归并路数由io.sort.factor 控制(默认是10)。比如：“a”从某个map task读取过来时值是7，从另外一个map 读取时值是6，因为它们有相同的key，所以得merge成group。什么是group。对于“a”就是像这样的：{“a”, [7, 6, 2, …]}，数组中的值就是从不同溢写文件中读取出来的，然后再把这些值加起来。请注意，因为merge是将多个溢写文件合并到一个文件，所以可能也有相同的key存在。如果设定了Combiner，会使用combiner来合并相同key，这是map端的结果。\n\n\n\n## map端与reduce端的交互\n\nReduce是怎么知道从哪些TaskTrackers中获取Map的输出呢？当Map任务完成之后，会通知他们的父TaskTracker，告知状态更新，然后TaskTracker再转告JobTracker，这些通知信息是通过心跳通信机制传输的，因此针对以一个特定的作业，jobtracker知道Map输出与tasktrackers的映射关系。Reducer中有一个线程会间歇的向JobTracker询问Map输出的地址，直到把所有的数据都取到。在Reducer取走了Map输出之后，TaskTracker不会立即删除这些数据，因为Reducer可能会失败，他们会在整个作业完成之后，JobTracker告知他们要删除的时候才去删除\n\n\n\nmap端的所有工作结束后，最终生成的这个文件也存放在TaskTracker够得着的某个本地目录内。每个reduce task不断地通过RPC从JobTracker那里获取map task是否完成的信息，如果reduce task得到通知，获知某台TaskTracker上的map task执行完成，Shuffle的后半段过程开始启动。\n简单地说，reduce task在执行之前的工作就是不断地拉取当前job里每个map task的最终结果，然后对从不同地方拉取过来的数据不断地做merge，也最终形成一个文件作为reduce task的输入文件。\n\n\n\n\n\n## reduce端过程\n\n![](https://ws1.sinaimg.cn/large/006tNbRwgy1fuhbdybylfj30z40hyq3f.jpg)\n\n1. Copy过程，简单地拉取数据。Reduce进程启动一些数据copy线程(Fetcher)，通过HTTP方式请求map task所在的TaskTracker获取map task的输出文件。因为map task早已结束，这些文件就归TaskTracker管理在本地磁盘中。\n2. Merge阶段。这里的merge如map端的merge动作，只是数组中存放的是不同map端copy来的数值。Copy过来的数据会先放入内存缓冲区中，这里的缓冲区大小要比map端的更为灵活，它基于JVM的heap size设置，因为Shuffle阶段Reducer不运行，所以应该把绝大部分的内存都给Shuffle用。这里需要强调的是，merge有三种形式：1)内存到内存 （默认不启用） 2)内存到磁盘  3)磁盘到磁盘。当内存中的数据量到达一定阈值，就启动内存到磁盘的merge，这个过程中如果你设置有Combiner，也是会启用的，然后在磁盘中生成了众多的溢写文件。第二种merge方式一直在运行，直到没有map端的数据时才结束，然后启动第三种磁盘到磁盘的merge方式生成最终的那个文件。\n3. Reducer的输入文件。不断地merge后，最后会生成一个文件。这个文件可能存在于磁盘上，也可能存在于内存中。就读取速度来说对于内存中，直接作为Reducer的输入，但默认情况下，这个文件是存放于磁盘中的。当Reducer的输入文件已定，整个Shuffle才最终结束。然后就是Reducer执行，一般是把结果放到HDFS上。\n\n\n\n\n\n## Speculative Execution\n\n是指当一个job的所有task都在running的时候，当某个task的进度比平均进度慢时才会启动一个和当前Task一模一样的任务，当其中一个task完成之后另外一个会被中止，所以Speculative Task不是重复Task而是对Task执行时候的一种优化策略\n\n\n\n\n\n# 任务分片与hdfs文件大小及文件块之间的关系\n\n在上面mapReduce中可以看到，任务的执行是基于hdfs文件的，任务分片和文件大小，文件块大小都有一定的联系。\n\n任务切片：将任务划分成切片**，一个切片交给一个task实例**处理，只是一个逻辑的偏移量划分而已\n\n1.在map task执行时，它的输入数据来源于HDFS的block，当然在MapReduce概念中，map task只读取split。Split与block的对应关系可能是多对一，默认是一对一。\n\n采用的算法是：\n\n**分片大小范围可以在 mapred-site.xml 中设置，mapred.min.split.size mapred.max.split.size，**minSplitSize 大小默认为 1B，**maxSplitSize 大小默认为 Long.MAX_VALUE = 9223372036854775807**\n\n```java\nminiSize = 1\nmaxSize = Long.MAXVALUE\nsplitSize = Math.max(miniSize,Math.min(maxSize,blockSize))\n```\n\n默认情况下，任务分片的大小为hdfs的blocksize 也就是块大小\n\n**所以在我们没有设置分片的范围的时候，分片大小是由 block 块大小决定的，和它的大小一样。比如把一个 258MB 的文件上传到 HDFS 上，假设 block 块大小是 128MB，那么它就会被分成三个 block 块，与之对应产生三个 split**，所以最终会产生三个 map task。我又发现了另一个问题，第三个 block 块里存的文件大小只有 2MB，而它的 block 块大小是 128MB，那它实际占用 Linux file system 的多大空间？**\n\n**答案是实际的文件大小，而非一个块的大小**\n\n\n\n切片的流程\n\n1. 遍历输入目录下的文件，得到文件集合 list\n\n2. 遍历文件集合list，循环操作集合下的文件\n\n   获取文件的blocksize 文件块，获取文件的长度，得到切片信息（split[文件路径,切片编号,偏移量范围]）,将各切片对象放入到一个splitList里面\n\n\n3. 遍历完成后，将切片信息splitList序列化到一个split描述文件中\n\n   ![](https://ws1.sinaimg.cn/large/006tNbRwgy1fufyt54ouvj30cq03c0so.jpg)\n\n\n\n\n\n默认情况下，默认的TextInputFormat对任务切片是按文件规划切片，不管文件多小，都会是一个单独的切片，这样如果有大量小文件，就会产生大量的maptask，处理效率极其低下\n\n\n\n对于以上原理，如果读取的是很多小文件，会产生大量的小切片，造成大量的maptask运行，对应的解决方法：\n\n1. 将小文件合并之后再上传到hdfs\n2. 如果小文件已经上传了，可以写MapReduce程序将小文件合并\n3. 可以用另一种InputFormat：CombineInputFormat(它可以将多个文件划分到一个切片中)\n\n\n\n\n\n","source":"_posts/MapReduce中Shuffle中的机制.md","raw":"---\ntitle: MapReduce中Shuffle中的机制\ndate: 2018年08月06日 22时15分52秒\ntags: [Hadoop,原理]\ncategories: 大数据\ntoc: true\n---\n\n[TOC]\n\n官方的shuffle流程\n\n![](https://ws2.sinaimg.cn/large/006tNbRwgy1fuhbmle6ksj30ff07dglu.jpg)\n\n# shuffle原理\n\n提到MapReduce，就不得不提一下shuffle。\n\nMapReduce 框架的核心步骤主要分两部分：Map 和Reduce，一个是独立并发，一个是汇聚。当你向MapReduce 框架提交一个计算作业时，它会首先把计算作业拆分成若干个Map 任务，然后分配到不同的节点上去执行，每一个Map 任务处理输入数据中的一部分，当Map 任务完成后，它会生成一些中间文件，这些中间文件将会作为Reduce 任务的输入数据。Reduce 任务的主要目标就是把前面若干个Map 的输出汇总到一起并输出。\n\n<!-- more -->\n\n 我们知道每个reduce task输入的key都是按照key排序的。但是每个map的输出只是简单的key-value而非key-valuelist，所以shuffle的工作就是将map输出转化为reducer的输入的过程。Shuffle过程是指map产生输出结果开始，包括系统执行分区partition，排序sort，聚合Combiner（如有）以及传送map的输出到Reducer作为输入的过程。\n\n## shuffle过程分析\n\n![](https://ws2.sinaimg.cn/large/006tNbRwgy1fuhbuwapflj30zc0j4mxv.jpg)\n\n\n\n\n\n## map端\n\n1. 从map段开始分析，当Map开始产生输出的时候，并不是简单吧数据写到磁盘，因为频繁的操作会导致性能严重下降，首先将数据写入到一个环形缓冲区（每个maptask都会有一个环形缓冲区，默认100M，可以通过io.sort.mb属性来设置具体的大小）并做一些预排序，以提升效率，当缓冲区中的数据量达到一个特定的阀值(io.sort.mb * io.sort.spill.percent，其中io.sort.spill.percent 默认是0.80，即默认为 80MB），溢写线程启动。\n\n2. 系统将会启动一个后台线程把缓冲区中的内容spill 到磁盘。即会锁定这80MB的内存，执行溢写过程。Map task的输出结果还可以往剩下的20MB内存中写，互不影响。在spill过程中，Map的输出将会继续写入到缓冲区，但如果缓冲区已经满了，Map就会被阻塞直到spill完成。spill线程在把缓冲区的数据写到磁盘前，会对他\n\n   进行一个**二次排序**，**首先根据数据所属的partition排序（快速排序），然后每个partition中再按Key排序**。输出包括一个**索引文件和数据文件**。\n\n3. 如果设定了Combiner，将在排序输出的基础上进行。Combiner就是一个Mini Reducer，它在执行Map任务的节点本身运行，先对Map的输出作一次简单的Reduce，有些数据可能像这样：`“a”/1， “a”/1， “a”/1，`会合并成 `“a”/3`，使得更少的数据会被写入磁盘和传送到Reducer。\n\n4. Spill文件保存在由mapred.local.dir指定的目录中，Map任务结束后删除。每当内存中的数据达到spill阀值的时候，都会产生一个新的spill文件，所以在Map任务写完他的最后一个输出记录的时候，可能会有多个spill文件，在Map任务完成前，所有的spill文件将会被归并排序为一个索引文件和数据文件。这是一个多路归并过程，最大归并路数由io.sort.factor 控制(默认是10)。比如：“a”从某个map task读取过来时值是7，从另外一个map 读取时值是6，因为它们有相同的key，所以得merge成group。什么是group。对于“a”就是像这样的：{“a”, [7, 6, 2, …]}，数组中的值就是从不同溢写文件中读取出来的，然后再把这些值加起来。请注意，因为merge是将多个溢写文件合并到一个文件，所以可能也有相同的key存在。如果设定了Combiner，会使用combiner来合并相同key，这是map端的结果。\n\n\n\n## map端与reduce端的交互\n\nReduce是怎么知道从哪些TaskTrackers中获取Map的输出呢？当Map任务完成之后，会通知他们的父TaskTracker，告知状态更新，然后TaskTracker再转告JobTracker，这些通知信息是通过心跳通信机制传输的，因此针对以一个特定的作业，jobtracker知道Map输出与tasktrackers的映射关系。Reducer中有一个线程会间歇的向JobTracker询问Map输出的地址，直到把所有的数据都取到。在Reducer取走了Map输出之后，TaskTracker不会立即删除这些数据，因为Reducer可能会失败，他们会在整个作业完成之后，JobTracker告知他们要删除的时候才去删除\n\n\n\nmap端的所有工作结束后，最终生成的这个文件也存放在TaskTracker够得着的某个本地目录内。每个reduce task不断地通过RPC从JobTracker那里获取map task是否完成的信息，如果reduce task得到通知，获知某台TaskTracker上的map task执行完成，Shuffle的后半段过程开始启动。\n简单地说，reduce task在执行之前的工作就是不断地拉取当前job里每个map task的最终结果，然后对从不同地方拉取过来的数据不断地做merge，也最终形成一个文件作为reduce task的输入文件。\n\n\n\n\n\n## reduce端过程\n\n![](https://ws1.sinaimg.cn/large/006tNbRwgy1fuhbdybylfj30z40hyq3f.jpg)\n\n1. Copy过程，简单地拉取数据。Reduce进程启动一些数据copy线程(Fetcher)，通过HTTP方式请求map task所在的TaskTracker获取map task的输出文件。因为map task早已结束，这些文件就归TaskTracker管理在本地磁盘中。\n2. Merge阶段。这里的merge如map端的merge动作，只是数组中存放的是不同map端copy来的数值。Copy过来的数据会先放入内存缓冲区中，这里的缓冲区大小要比map端的更为灵活，它基于JVM的heap size设置，因为Shuffle阶段Reducer不运行，所以应该把绝大部分的内存都给Shuffle用。这里需要强调的是，merge有三种形式：1)内存到内存 （默认不启用） 2)内存到磁盘  3)磁盘到磁盘。当内存中的数据量到达一定阈值，就启动内存到磁盘的merge，这个过程中如果你设置有Combiner，也是会启用的，然后在磁盘中生成了众多的溢写文件。第二种merge方式一直在运行，直到没有map端的数据时才结束，然后启动第三种磁盘到磁盘的merge方式生成最终的那个文件。\n3. Reducer的输入文件。不断地merge后，最后会生成一个文件。这个文件可能存在于磁盘上，也可能存在于内存中。就读取速度来说对于内存中，直接作为Reducer的输入，但默认情况下，这个文件是存放于磁盘中的。当Reducer的输入文件已定，整个Shuffle才最终结束。然后就是Reducer执行，一般是把结果放到HDFS上。\n\n\n\n\n\n## Speculative Execution\n\n是指当一个job的所有task都在running的时候，当某个task的进度比平均进度慢时才会启动一个和当前Task一模一样的任务，当其中一个task完成之后另外一个会被中止，所以Speculative Task不是重复Task而是对Task执行时候的一种优化策略\n\n\n\n\n\n# 任务分片与hdfs文件大小及文件块之间的关系\n\n在上面mapReduce中可以看到，任务的执行是基于hdfs文件的，任务分片和文件大小，文件块大小都有一定的联系。\n\n任务切片：将任务划分成切片**，一个切片交给一个task实例**处理，只是一个逻辑的偏移量划分而已\n\n1.在map task执行时，它的输入数据来源于HDFS的block，当然在MapReduce概念中，map task只读取split。Split与block的对应关系可能是多对一，默认是一对一。\n\n采用的算法是：\n\n**分片大小范围可以在 mapred-site.xml 中设置，mapred.min.split.size mapred.max.split.size，**minSplitSize 大小默认为 1B，**maxSplitSize 大小默认为 Long.MAX_VALUE = 9223372036854775807**\n\n```java\nminiSize = 1\nmaxSize = Long.MAXVALUE\nsplitSize = Math.max(miniSize,Math.min(maxSize,blockSize))\n```\n\n默认情况下，任务分片的大小为hdfs的blocksize 也就是块大小\n\n**所以在我们没有设置分片的范围的时候，分片大小是由 block 块大小决定的，和它的大小一样。比如把一个 258MB 的文件上传到 HDFS 上，假设 block 块大小是 128MB，那么它就会被分成三个 block 块，与之对应产生三个 split**，所以最终会产生三个 map task。我又发现了另一个问题，第三个 block 块里存的文件大小只有 2MB，而它的 block 块大小是 128MB，那它实际占用 Linux file system 的多大空间？**\n\n**答案是实际的文件大小，而非一个块的大小**\n\n\n\n切片的流程\n\n1. 遍历输入目录下的文件，得到文件集合 list\n\n2. 遍历文件集合list，循环操作集合下的文件\n\n   获取文件的blocksize 文件块，获取文件的长度，得到切片信息（split[文件路径,切片编号,偏移量范围]）,将各切片对象放入到一个splitList里面\n\n\n3. 遍历完成后，将切片信息splitList序列化到一个split描述文件中\n\n   ![](https://ws1.sinaimg.cn/large/006tNbRwgy1fufyt54ouvj30cq03c0so.jpg)\n\n\n\n\n\n默认情况下，默认的TextInputFormat对任务切片是按文件规划切片，不管文件多小，都会是一个单独的切片，这样如果有大量小文件，就会产生大量的maptask，处理效率极其低下\n\n\n\n对于以上原理，如果读取的是很多小文件，会产生大量的小切片，造成大量的maptask运行，对应的解决方法：\n\n1. 将小文件合并之后再上传到hdfs\n2. 如果小文件已经上传了，可以写MapReduce程序将小文件合并\n3. 可以用另一种InputFormat：CombineInputFormat(它可以将多个文件划分到一个切片中)\n\n\n\n\n\n","slug":"MapReduce中Shuffle中的机制","published":1,"updated":"2018-08-21T10:06:40.273Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloj0llw002dykpbzwg3lzuf"},{"title":"MyBatis相关注解","date":"2018-05-17T12:09:55.000Z","toc":true,"top":true,"_content":"![](https://ws4.sinaimg.cn/large/006tNbRwgy1fu551ai6pij30mm064q3r.jpg)\n\n现接触MyBatic记录一些注解\n<!--more-->\n自动生成主键  \n\n        可以使用 @Options 注解的 userGeneratedKeys 和 keyProperty 属性让数据库产生 auto_increment（自增长）列的值，然后将生成的值设置到输入参数对象的属性中。 \n```java\n@Insert(\"insert into students(name,sex,age)  values(#{name},#{sex},#{age}\")  \n@Options(useGeneratedKeys = true, keyProperty =\"userId\")  \nint insertUser(User user);   \n```\n将自增的Id存入到userId属性中","source":"_posts/MyBatis注解.md","raw":"---\ntitle: MyBatis相关注解\ndate: 2018-05-17 20:09:55\ntags: [Java,SSH]\ncategories: 框架\ntoc: true\ntop: true\n---\n![](https://ws4.sinaimg.cn/large/006tNbRwgy1fu551ai6pij30mm064q3r.jpg)\n\n现接触MyBatic记录一些注解\n<!--more-->\n自动生成主键  \n\n        可以使用 @Options 注解的 userGeneratedKeys 和 keyProperty 属性让数据库产生 auto_increment（自增长）列的值，然后将生成的值设置到输入参数对象的属性中。 \n```java\n@Insert(\"insert into students(name,sex,age)  values(#{name},#{sex},#{age}\")  \n@Options(useGeneratedKeys = true, keyProperty =\"userId\")  \nint insertUser(User user);   \n```\n将自增的Id存入到userId属性中","slug":"MyBatis注解","published":1,"updated":"2018-08-10T17:52:53.516Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloj0lly002hykpb28n299vd"},{"title":"Scala基本使用-杂记","date":"2018-08-15T15:52:20.469Z","toc":true,"_content":"\n[TOC]\n\n![](https://ws4.sinaimg.cn/large/006tNbRwgy1fukx028pz0j313t0op400.jpg)\n\nVar和val\n\nvar 修饰的变量可改变，val 修饰的变量不可改变；但真的如此吗？事实上，var 修饰的对象引用可以改变，val 修饰的则不可改变，但对象的状态却是可以改变的。\n\n## 定义方法\n```scala\ndef m1(x:Int,y:Int):Int=x*y\n```\n\n<!-- more -->\n\n## 函数的定义=>\n\n```scala\nval func:Int =>String={x=x.toString}\n也可以写成\nval func1=(x:Int)=>x.toString\n```\n\n\n## 函数和方法的区别\n```scala\n定义一个方法\ndef m2(f:(Int,Int)=>Int) =f(2,6)\n定义一个函数\nval f2 =(x:Int,y:Int) =>x-y\n调用\nf2(m2)\n```\n\n\n## 神奇的下划线\n将方法转换成函数\n\n```scala\ndef m2(x:Int,y:Int):Int = x+y\nval f2(a:Int,y:Int)=>x+y\nval f2 = m2 _\n```\n\n\n\n\n# 数组、映射、元组、集合\n## 数组\n```scala\nval arr = new Array[Int](10) //创建数组，无值\nval arr1 = Array(1,2,3,4,5)  //直接实例化\nfor(e<- arr) **yield** e*2; 用yield关键字可以生成一个新的数组 生成的类型和循环的类型是一样的\n```\n\n\n## map方法\nmap方法是将每一个元素拿来操作\narr.map(_*2) map方法更好用  map是排序？\n\n```scala\nval a = Array(1,2,3,4,5)\na.map((x:Int)=>x*10)//匿名函数\n```\n\n\n由于知道a中的数据类型 可以将Int省略\na.map(x=>x*10) \n还可以用_占位符，进行进一步的省略\na.map(_ * 10)\n\n\n所有偶数取出来然后再乘以10\n```scala\narr.filter((x:Int)=>x%2==0)\narr.filter(x=>x%2 == 0)\narr.filter(_%2==0)\narr.filter(_%2==0).map(_*10)\nval p =  println _\n```\n\n\n\n可以将方法转换成函数用利用 _\n### trait 关键字\n## 数组的常用函数\n在超类\nTraversableLike中定义了这些函数\n```scala\nval arr = Array(1,2,3,4,5,6)\narr.sum 总数\narr.sorted 排序\narr.sorted.reverse 逆序\narr.sortBy(x=>x)按照本身来排序\narr.sortWith(_>_)从大到小排序 < 从小到大排序\narr.sortWith((x,y))\n## \n```\n\n映射 类比java中的map\n```scala\nval m = Map(\"a\"->1,\"b\"->2)\nm(\"a\") 取值 \n```\n\n\n里边的值不能更改\n如果是mulitble的包就可以更改了\n```scala\nm.getOrElse(\"c\",0) 找c 如果没有c就创建0\n```\n\n\n### apply方法\n##  元组\n\nval t = (1,\"spark\",2.0); 值类型都不一定\n\nm.+=((\"c\",1))  与 m+=(\"m\"->1) 写法相同\nval t,(x,y,z) = (\"a\",1,2.0) \nt是变量，x y z 是键 对应三个值，取值的时候 直接用x就可以取值\n\n### 将对偶的转成映射\n```scala\nval arr  = Array((\"a\",1),(\"b\",2))\narr.toMap 就可以转成映射\n```\n\n\n### 拉链操作\n```scala\nval a = Array(\"a\",\"b\",\"c\")\nval b = Array(1,2,3);\na.zip(b) \n```\n\n\n将其拉在一起变成数组，元素为元组\n# 集合\n序列Seq,集Set,映射Map\n集合分为可变和不可变的 mutable 和 immutable\n注意和val的对比\n将0插入来lst前面生成一个新的集合\n\n```scala\nval lst2 = 1 :: lst1; \nval lst3 = lst1.::(0)\nval lst4 = 0 +: lst1\nval lst5 = lst1.+:(0)\n```\n\n\n将一个元素添加到lst后面产生一个新的集合\n\n```scala\nval lst6 = lst1:+3\nval lst0 = List(4,5,6)\n```\n\n\n将2个list合并成一个新的List\n\n```scala\nval lst7 = lst1 ++ lst0\n```\n\n\n将lst0插入到lst前面生成一个新的集合\n\n```scala\nval lst8 = lst1 ++: lst0\n```\n\n\n\n## foreach\nforeach是将其值取出来，不会新生成一个集合\nmap将值取出来会新生成一个集合\n## Map\nMap本身不支持排序\n但是有toList方法 无括号，可以支持排序\n## List\n```scala\nval list = List(1,2,3,4,5,6);\n```\n\n\nlist.par转成并行化集合\nlist.par.reduce(_+_) 将其放在多个reduce中执行，数据量大的时候将会变得很快\nreduce不是并行集合的话，就是调用的底层\nreduceLeft(不能并行了)\n## fold可以指定初始值\n```scala\nlist.par.fold(0)(_+_)\n```\n\n\n## aggregate 聚合\n需要传两个函数，第一个函数是对元素进行操作，第二函数是对局部操作的结果进行操作\n\n```scala\nList（List(1,7,9,8),List(0,1,2,3)）\nlist.aggregate(0)(_+_.sum,_+_)\n```\n\n\n\nunion 并集，intersect交集，diff差集\n\n\n## flatten 将数据压缩\n```scala\nList（List(1,7,9,8),List(0,1,2,3)）\nlistAll.flatten\nList(1,7,9,8,0,1,2,3) 产生新的集合\n```\n\n\n\n# 对象\n\n主构造器里面的所有方法都会被执行\n## 单例对象\n所有的object都是一个单例（把class替换成object）\n不要new，直接等于类名就是调用的一个**单例对象**\n\n```scala\nobject Dog{\n  def main(){\n  val d = Dog\n  }\n}\n```\n\n\n## 伴生对象\n就是对象名和类名一样，并且在一个scala文件中\n可以和类**互相访问私有属性**\nscala中返回的就是unit就是返回的一个括号\n### apply方法\n```scala\nObject Dog{\n def apply():Unit = {\n  print ();\n }\n def apply(name:String):Unit = {\n  print(name)\n }\n def main(){\n //会调用第一个无参数的apply方法\n val d1 = Dog()\n //会调用第有参数的apply方法\n val d2 = Dog(\"haha\");\n }\n}\n```\n\n## 应用程序对象\n没有什么实际作用\n## 构造函数\n用this关键字定义辅助构造器\n```scala\ndef this(name:String,age:Int,gender:String){\n//每个服务构造器必须以主构造器或者其他的辅助构造器的调用开始\n//主构造器就是类名上直接填写参数\n}\n```\n\n函数与方法的互换， 神奇的下划线\n要想传到map里面，必须得是函数\n\n```scala\ndef  fangfa方法\nval  func 函数\nval arr = Array(1,2,3,4,5,6)\narr.map(func(5))\narr.map(func())\nval m = fangfa _  方法func转成函数\nfangfa()  也可以转函数\n\ndef m(x:Int) = (y:int)=>x*y\n```\n\n\n\n## 柯里化的两种表达方式\n柯里化是主要是通过类型类匹配的\n\n```scala\ndef m1(x:Int) = (y:Int)=>x*y\ndef m2(x:Int)(y:Int)=>x*y\n```\n\n\n柯里化会先执行一部分，返回一个函数\n```scala\n def multi= (x:Int) =>{\n    x*x\n  }\n\n  def main(args: Array[String]): Unit = {\n    val arr = Array(1,2,3,5,4)\n    val a1 = multi(10)\n    println(s\"平方式：${a1}\")\n    //按照规则 map只能参数只能是函数，multi是一个方法，但是在柯里化的时候，会先返回一个中间结果是函数\n    val a2 = arr.map(multi)\n  }\n\n```\n## 继承 代理 装饰 之间的区别\n继承是类的增强\n\n代理是对实例，方法的增强\n\n装饰也是对方法的增强\n\nimplicit def 隐式的，隐式转化的包在predef中\n# 泛型\n\n```scala\n<? extends clazz> 传入的数据是clazz的子类   \n<? super clazz> 传入的数据是clazz的父类   \n```\n\n\n\n## > < >= <=\n\n以上操作符，在scala中都是方法\n\n\n\n\n\n### 视图定界 view bound <%\n\nscala泛型\n\n```scala\nclass Person[T] { \ndef chooser[T <: Comparable[T]](firit: T, second: T): T = { \n\tfirst \n\t} \n} \n```\n\n\n隐式转换：我自己的隐式上下文\n\n```scala\nobject MyPredef{ \nimplicit 函数 \nimplicit 值 \n} \n```\n\n\nviewbound要求传入一个隐式转换函数\n\n```scala\nclass Chooser[T <% Ordered[T]] { \ndef bigger(first: T, second: T) : T = { \n\tif(first > second) first else second \n\t} \n} \n\n\nclass Chooser[T] { \ndef bigger(first: T, second: T)(implicit ord: T => Ordered[T]) : T = { \n\tif(first > second) first else second \n\t} \n} \n```\n\n\ncontextbound要求传入一个隐式转换值\n\n```scala\nclass Chooser[T: Ordering] { \ndef bigger(first: T, second: T) : T = { \nval ord = implicitly[Ordering[T]] \nif(ord.gt(first, second)) first else second \n} \n} \nclass Chooser[T] { \ndef bigger(first: T, second: T)(implicit ord : Ordering[T]) : T = { \nif(ord.gt(first, second)) first else second \n} \n} \n```\n\n\n[+T] \n[-T]\n\n相当于传入了一个隐式转换的函数\n一定要传入一个隐式转换函数\n\n```scala\nclass Chooser [t <% Order[T]]{\n  def choose(first T,second T) :T ={\n  //val ord = implicitly[Ordering[T]]\n  // if(ord.gt(first,second))) first else second;\n   if(first.compare(second) > 0) first else second;\n  }\n}\n```\n\n```scala\nimplict object girlOrdering extends Ordering[girl]{\noverride def compare(x:girl,y:girl):Int = {\n\n}\n}\n\n== 和这个实现的效果是一样的,只是取了一个名字\nimplicit val girlOrder = new Ordering[Girl]{\n\n}\n\n```\n\n\n\n\n### 上下文定界 : content bound\n相当于传入了一个隐式转换的值\n\n关于实体类Predef的关系","source":"_posts/Scala基本使用.md","raw":"---\ntitle: Scala基本使用-杂记\ndate: 2018年08月06日 22时15分52秒\ntags: [Scala]\ncategories: 语言\ntoc: true\n---\n\n[TOC]\n\n![](https://ws4.sinaimg.cn/large/006tNbRwgy1fukx028pz0j313t0op400.jpg)\n\nVar和val\n\nvar 修饰的变量可改变，val 修饰的变量不可改变；但真的如此吗？事实上，var 修饰的对象引用可以改变，val 修饰的则不可改变，但对象的状态却是可以改变的。\n\n## 定义方法\n```scala\ndef m1(x:Int,y:Int):Int=x*y\n```\n\n<!-- more -->\n\n## 函数的定义=>\n\n```scala\nval func:Int =>String={x=x.toString}\n也可以写成\nval func1=(x:Int)=>x.toString\n```\n\n\n## 函数和方法的区别\n```scala\n定义一个方法\ndef m2(f:(Int,Int)=>Int) =f(2,6)\n定义一个函数\nval f2 =(x:Int,y:Int) =>x-y\n调用\nf2(m2)\n```\n\n\n## 神奇的下划线\n将方法转换成函数\n\n```scala\ndef m2(x:Int,y:Int):Int = x+y\nval f2(a:Int,y:Int)=>x+y\nval f2 = m2 _\n```\n\n\n\n\n# 数组、映射、元组、集合\n## 数组\n```scala\nval arr = new Array[Int](10) //创建数组，无值\nval arr1 = Array(1,2,3,4,5)  //直接实例化\nfor(e<- arr) **yield** e*2; 用yield关键字可以生成一个新的数组 生成的类型和循环的类型是一样的\n```\n\n\n## map方法\nmap方法是将每一个元素拿来操作\narr.map(_*2) map方法更好用  map是排序？\n\n```scala\nval a = Array(1,2,3,4,5)\na.map((x:Int)=>x*10)//匿名函数\n```\n\n\n由于知道a中的数据类型 可以将Int省略\na.map(x=>x*10) \n还可以用_占位符，进行进一步的省略\na.map(_ * 10)\n\n\n所有偶数取出来然后再乘以10\n```scala\narr.filter((x:Int)=>x%2==0)\narr.filter(x=>x%2 == 0)\narr.filter(_%2==0)\narr.filter(_%2==0).map(_*10)\nval p =  println _\n```\n\n\n\n可以将方法转换成函数用利用 _\n### trait 关键字\n## 数组的常用函数\n在超类\nTraversableLike中定义了这些函数\n```scala\nval arr = Array(1,2,3,4,5,6)\narr.sum 总数\narr.sorted 排序\narr.sorted.reverse 逆序\narr.sortBy(x=>x)按照本身来排序\narr.sortWith(_>_)从大到小排序 < 从小到大排序\narr.sortWith((x,y))\n## \n```\n\n映射 类比java中的map\n```scala\nval m = Map(\"a\"->1,\"b\"->2)\nm(\"a\") 取值 \n```\n\n\n里边的值不能更改\n如果是mulitble的包就可以更改了\n```scala\nm.getOrElse(\"c\",0) 找c 如果没有c就创建0\n```\n\n\n### apply方法\n##  元组\n\nval t = (1,\"spark\",2.0); 值类型都不一定\n\nm.+=((\"c\",1))  与 m+=(\"m\"->1) 写法相同\nval t,(x,y,z) = (\"a\",1,2.0) \nt是变量，x y z 是键 对应三个值，取值的时候 直接用x就可以取值\n\n### 将对偶的转成映射\n```scala\nval arr  = Array((\"a\",1),(\"b\",2))\narr.toMap 就可以转成映射\n```\n\n\n### 拉链操作\n```scala\nval a = Array(\"a\",\"b\",\"c\")\nval b = Array(1,2,3);\na.zip(b) \n```\n\n\n将其拉在一起变成数组，元素为元组\n# 集合\n序列Seq,集Set,映射Map\n集合分为可变和不可变的 mutable 和 immutable\n注意和val的对比\n将0插入来lst前面生成一个新的集合\n\n```scala\nval lst2 = 1 :: lst1; \nval lst3 = lst1.::(0)\nval lst4 = 0 +: lst1\nval lst5 = lst1.+:(0)\n```\n\n\n将一个元素添加到lst后面产生一个新的集合\n\n```scala\nval lst6 = lst1:+3\nval lst0 = List(4,5,6)\n```\n\n\n将2个list合并成一个新的List\n\n```scala\nval lst7 = lst1 ++ lst0\n```\n\n\n将lst0插入到lst前面生成一个新的集合\n\n```scala\nval lst8 = lst1 ++: lst0\n```\n\n\n\n## foreach\nforeach是将其值取出来，不会新生成一个集合\nmap将值取出来会新生成一个集合\n## Map\nMap本身不支持排序\n但是有toList方法 无括号，可以支持排序\n## List\n```scala\nval list = List(1,2,3,4,5,6);\n```\n\n\nlist.par转成并行化集合\nlist.par.reduce(_+_) 将其放在多个reduce中执行，数据量大的时候将会变得很快\nreduce不是并行集合的话，就是调用的底层\nreduceLeft(不能并行了)\n## fold可以指定初始值\n```scala\nlist.par.fold(0)(_+_)\n```\n\n\n## aggregate 聚合\n需要传两个函数，第一个函数是对元素进行操作，第二函数是对局部操作的结果进行操作\n\n```scala\nList（List(1,7,9,8),List(0,1,2,3)）\nlist.aggregate(0)(_+_.sum,_+_)\n```\n\n\n\nunion 并集，intersect交集，diff差集\n\n\n## flatten 将数据压缩\n```scala\nList（List(1,7,9,8),List(0,1,2,3)）\nlistAll.flatten\nList(1,7,9,8,0,1,2,3) 产生新的集合\n```\n\n\n\n# 对象\n\n主构造器里面的所有方法都会被执行\n## 单例对象\n所有的object都是一个单例（把class替换成object）\n不要new，直接等于类名就是调用的一个**单例对象**\n\n```scala\nobject Dog{\n  def main(){\n  val d = Dog\n  }\n}\n```\n\n\n## 伴生对象\n就是对象名和类名一样，并且在一个scala文件中\n可以和类**互相访问私有属性**\nscala中返回的就是unit就是返回的一个括号\n### apply方法\n```scala\nObject Dog{\n def apply():Unit = {\n  print ();\n }\n def apply(name:String):Unit = {\n  print(name)\n }\n def main(){\n //会调用第一个无参数的apply方法\n val d1 = Dog()\n //会调用第有参数的apply方法\n val d2 = Dog(\"haha\");\n }\n}\n```\n\n## 应用程序对象\n没有什么实际作用\n## 构造函数\n用this关键字定义辅助构造器\n```scala\ndef this(name:String,age:Int,gender:String){\n//每个服务构造器必须以主构造器或者其他的辅助构造器的调用开始\n//主构造器就是类名上直接填写参数\n}\n```\n\n函数与方法的互换， 神奇的下划线\n要想传到map里面，必须得是函数\n\n```scala\ndef  fangfa方法\nval  func 函数\nval arr = Array(1,2,3,4,5,6)\narr.map(func(5))\narr.map(func())\nval m = fangfa _  方法func转成函数\nfangfa()  也可以转函数\n\ndef m(x:Int) = (y:int)=>x*y\n```\n\n\n\n## 柯里化的两种表达方式\n柯里化是主要是通过类型类匹配的\n\n```scala\ndef m1(x:Int) = (y:Int)=>x*y\ndef m2(x:Int)(y:Int)=>x*y\n```\n\n\n柯里化会先执行一部分，返回一个函数\n```scala\n def multi= (x:Int) =>{\n    x*x\n  }\n\n  def main(args: Array[String]): Unit = {\n    val arr = Array(1,2,3,5,4)\n    val a1 = multi(10)\n    println(s\"平方式：${a1}\")\n    //按照规则 map只能参数只能是函数，multi是一个方法，但是在柯里化的时候，会先返回一个中间结果是函数\n    val a2 = arr.map(multi)\n  }\n\n```\n## 继承 代理 装饰 之间的区别\n继承是类的增强\n\n代理是对实例，方法的增强\n\n装饰也是对方法的增强\n\nimplicit def 隐式的，隐式转化的包在predef中\n# 泛型\n\n```scala\n<? extends clazz> 传入的数据是clazz的子类   \n<? super clazz> 传入的数据是clazz的父类   \n```\n\n\n\n## > < >= <=\n\n以上操作符，在scala中都是方法\n\n\n\n\n\n### 视图定界 view bound <%\n\nscala泛型\n\n```scala\nclass Person[T] { \ndef chooser[T <: Comparable[T]](firit: T, second: T): T = { \n\tfirst \n\t} \n} \n```\n\n\n隐式转换：我自己的隐式上下文\n\n```scala\nobject MyPredef{ \nimplicit 函数 \nimplicit 值 \n} \n```\n\n\nviewbound要求传入一个隐式转换函数\n\n```scala\nclass Chooser[T <% Ordered[T]] { \ndef bigger(first: T, second: T) : T = { \n\tif(first > second) first else second \n\t} \n} \n\n\nclass Chooser[T] { \ndef bigger(first: T, second: T)(implicit ord: T => Ordered[T]) : T = { \n\tif(first > second) first else second \n\t} \n} \n```\n\n\ncontextbound要求传入一个隐式转换值\n\n```scala\nclass Chooser[T: Ordering] { \ndef bigger(first: T, second: T) : T = { \nval ord = implicitly[Ordering[T]] \nif(ord.gt(first, second)) first else second \n} \n} \nclass Chooser[T] { \ndef bigger(first: T, second: T)(implicit ord : Ordering[T]) : T = { \nif(ord.gt(first, second)) first else second \n} \n} \n```\n\n\n[+T] \n[-T]\n\n相当于传入了一个隐式转换的函数\n一定要传入一个隐式转换函数\n\n```scala\nclass Chooser [t <% Order[T]]{\n  def choose(first T,second T) :T ={\n  //val ord = implicitly[Ordering[T]]\n  // if(ord.gt(first,second))) first else second;\n   if(first.compare(second) > 0) first else second;\n  }\n}\n```\n\n```scala\nimplict object girlOrdering extends Ordering[girl]{\noverride def compare(x:girl,y:girl):Int = {\n\n}\n}\n\n== 和这个实现的效果是一样的,只是取了一个名字\nimplicit val girlOrder = new Ordering[Girl]{\n\n}\n\n```\n\n\n\n\n### 上下文定界 : content bound\n相当于传入了一个隐式转换的值\n\n关于实体类Predef的关系","slug":"Scala基本使用","published":1,"updated":"2018-08-24T09:24:13.619Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloj0llz002lykpblkrgfwsr"},{"title":"Spark-On-Yarn模式","date":"2018-08-15T17:58:01.513Z","toc":true,"_content":"\n[TOC]\n\n# SparkOnYarn\n\n# 两种模式区别\n\n## cluster模式：\n\nDriver程序在YARN中运行，应用的运行结果不能在客户端显示，所以最好运行那些将结果最终保存在外部存储介质（如HDFS、Redis、Mysql）而非stdout输出的应用程序，客户端的终端显示的仅是作为YARN的job的简单运行状况。\n\n```bash\n./bin/spark-submit --class org.apache.spark.examples.SparkPi \\\n--master yarn \\\n--deploy-mode cluster \\\n--driver-memory 1g \\\n--executor-memory 1g \\\n--executor-cores 2 \\\n--queue default \\\nlib/spark-examples*.jar \\\n10\n\n./bin/spark-submit --class cn.itcast.spark.day1.WordCount \\\n--master yarn \\\n--deploy-mode cluster \\\n--driver-memory 1g \\\n--executor-memory 1g \\\n--executor-cores 2 \\\n--queue default \\\n/home/bigdata/hello-spark-1.0.jar \\\nhdfs://master:9000/wc hdfs://master:9000/out-yarn-1\n\n```\n\n<!-- more --> \n\n## client模式：\n\nDriver运行在Client上，应用程序运行结果会在客户端显示，所有适合运行结果有输出的应用程序（如spark-shell）\n\n```bash\nclient模式\n./bin/spark-submit --class org.apache.spark.examples.SparkPi \\\n--master yarn \\\n--deploy-mode client \\\n--driver-memory 1g \\\n--executor-memory 1g \\\n--executor-cores 2 \\\n--queue default \\\nlib/spark-examples*.jar \\\n10\n\nspark-shell必须使用client模式\n./bin/spark-shell --master yarn --deploy-mode client\n\n```\n\n\n\n# 原理\n\n## cluster模式：\n\n![](https://ws3.sinaimg.cn/large/006tNbRwgy1fuaxd9man3j31020o60w1.jpg)\n\nSpark Driver首先作为一个ApplicationMaster在YARN集群中启动，客户端提交给ResourceManager的每一个job都会在集群的NodeManager节点上分配一个唯一的ApplicationMaster，由该ApplicationMaster管理全生命周期的应用。具体过程：\n\n1. 由client向ResourceManager提交请求，并上传jar到HDFS上\n  这期间包括四个步骤：\n  a).连接到RM\n  b).从RM的ASM（ApplicationsManager ）中获得metric、queue和resource等信息。\n  c). upload app jar and spark-assembly jar\n  d).设置运行环境和container上下文（launch-container.sh等脚本)\n\n2. ResouceManager向NodeManager申请资源，创建Spark ApplicationMaster（每个SparkContext都有一个ApplicationMaster）\n3. NodeManager启动ApplicationMaster，并向ResourceManager AsM注册\n4. ApplicationMaster从HDFS中找到jar文件，启动SparkContext、DAGscheduler和YARN Cluster Scheduler\n5. ResourceManager向ResourceManager AsM注册申请container资源\n6. ResourceManager通知NodeManager分配Container，这时可以收到来自ASM关于container的报告。（每个container对应一个executor）\n7. Spark ApplicationMaster直接和container（executor）进行交互，完成这个分布式任务。\n\n## client模式\n\n![](https://ws2.sinaimg.cn/large/006tNbRwgy1fuaxdd9n3tj310c0jbq5y.jpg)\n\n在client模式下，Driver运行在Client上，通过ApplicationMaster向RM获取资源。本地Driver负责与所有的executor container进行交互，并将最后的结果汇总。结束掉终端，相当于kill掉这个spark应用。一般来说，如果运行的结果仅仅返回到terminal上时需要配置这个。\n\n客户端的Driver将应用提交给Yarn后，Yarn会先后启动ApplicationMaster和executor，另外ApplicationMaster和executor都 是装载在container里运行，container默认的内存是1G，ApplicationMaster分配的内存是driver- memory，executor分配的内存是executor-memory。同时，因为Driver在客户端，所以程序的运行结果可以在客户端显 示，Driver以进程名为SparkSubmit的形式存在。","source":"_posts/Spark-On-yarn.md","raw":"---\ntitle: Spark-On-Yarn模式\ndate: 2018年08月06日 22时15分52秒\ntags: [Spark,使用]\ncategories: 大数据\ntoc: true\n---\n\n[TOC]\n\n# SparkOnYarn\n\n# 两种模式区别\n\n## cluster模式：\n\nDriver程序在YARN中运行，应用的运行结果不能在客户端显示，所以最好运行那些将结果最终保存在外部存储介质（如HDFS、Redis、Mysql）而非stdout输出的应用程序，客户端的终端显示的仅是作为YARN的job的简单运行状况。\n\n```bash\n./bin/spark-submit --class org.apache.spark.examples.SparkPi \\\n--master yarn \\\n--deploy-mode cluster \\\n--driver-memory 1g \\\n--executor-memory 1g \\\n--executor-cores 2 \\\n--queue default \\\nlib/spark-examples*.jar \\\n10\n\n./bin/spark-submit --class cn.itcast.spark.day1.WordCount \\\n--master yarn \\\n--deploy-mode cluster \\\n--driver-memory 1g \\\n--executor-memory 1g \\\n--executor-cores 2 \\\n--queue default \\\n/home/bigdata/hello-spark-1.0.jar \\\nhdfs://master:9000/wc hdfs://master:9000/out-yarn-1\n\n```\n\n<!-- more --> \n\n## client模式：\n\nDriver运行在Client上，应用程序运行结果会在客户端显示，所有适合运行结果有输出的应用程序（如spark-shell）\n\n```bash\nclient模式\n./bin/spark-submit --class org.apache.spark.examples.SparkPi \\\n--master yarn \\\n--deploy-mode client \\\n--driver-memory 1g \\\n--executor-memory 1g \\\n--executor-cores 2 \\\n--queue default \\\nlib/spark-examples*.jar \\\n10\n\nspark-shell必须使用client模式\n./bin/spark-shell --master yarn --deploy-mode client\n\n```\n\n\n\n# 原理\n\n## cluster模式：\n\n![](https://ws3.sinaimg.cn/large/006tNbRwgy1fuaxd9man3j31020o60w1.jpg)\n\nSpark Driver首先作为一个ApplicationMaster在YARN集群中启动，客户端提交给ResourceManager的每一个job都会在集群的NodeManager节点上分配一个唯一的ApplicationMaster，由该ApplicationMaster管理全生命周期的应用。具体过程：\n\n1. 由client向ResourceManager提交请求，并上传jar到HDFS上\n  这期间包括四个步骤：\n  a).连接到RM\n  b).从RM的ASM（ApplicationsManager ）中获得metric、queue和resource等信息。\n  c). upload app jar and spark-assembly jar\n  d).设置运行环境和container上下文（launch-container.sh等脚本)\n\n2. ResouceManager向NodeManager申请资源，创建Spark ApplicationMaster（每个SparkContext都有一个ApplicationMaster）\n3. NodeManager启动ApplicationMaster，并向ResourceManager AsM注册\n4. ApplicationMaster从HDFS中找到jar文件，启动SparkContext、DAGscheduler和YARN Cluster Scheduler\n5. ResourceManager向ResourceManager AsM注册申请container资源\n6. ResourceManager通知NodeManager分配Container，这时可以收到来自ASM关于container的报告。（每个container对应一个executor）\n7. Spark ApplicationMaster直接和container（executor）进行交互，完成这个分布式任务。\n\n## client模式\n\n![](https://ws2.sinaimg.cn/large/006tNbRwgy1fuaxdd9n3tj310c0jbq5y.jpg)\n\n在client模式下，Driver运行在Client上，通过ApplicationMaster向RM获取资源。本地Driver负责与所有的executor container进行交互，并将最后的结果汇总。结束掉终端，相当于kill掉这个spark应用。一般来说，如果运行的结果仅仅返回到terminal上时需要配置这个。\n\n客户端的Driver将应用提交给Yarn后，Yarn会先后启动ApplicationMaster和executor，另外ApplicationMaster和executor都 是装载在container里运行，container默认的内存是1G，ApplicationMaster分配的内存是driver- memory，executor分配的内存是executor-memory。同时，因为Driver在客户端，所以程序的运行结果可以在客户端显 示，Driver以进程名为SparkSubmit的形式存在。","slug":"Spark-On-yarn","published":1,"updated":"2018-08-17T02:19:27.066Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloj0lm1002pykpbnmn5vwe8"},{"title":"Spark-on-Yarn源码解析(一)Yarn任务解析","date":"2018-09-04T07:44:58.661Z","toc":true,"_content":"\n[TOC]\n\nspark-on-yarn系列\n[Spark-on-Yarn 源码解析 (一)Yarn 任务解析](http://www.gangtieguo.cn/2018/09/04/Spark-on-Yarn源码解析(一)Yarn任务解析/)\n[Spark-on-Yarn 源码解析 (二)Spark-Submit 解析](http://www.gangtieguo.cn/2018/09/04/Spark-on-Yarn源码解析(二)Spark-Submit解析/)\n[Spark-on-Yarn 源码解析 (三)client 做的事情](http://www.gangtieguo.cn/2018/09/04/Spark-on-Yarn源码解析(三)client做的事情/)\n[Spark-on-Yarn 源码解析 (四)Spark 业务代码的执行及其任务分配调度 stage 划分](http://www.gangtieguo.cn/2018/09/04/Spark-on-Yarn源码解析(四)Spark业务代码的执行及其任务分配调度stage划分/)\n\n了解spark-on-yarn,首先我们了解一下yarn提交的流程，俗话说，欲练此功，错了，我们还是先看吧\n\n# yarn任务的提交\nYARN 的基本架构和工作流程\n\n![](http://pebgsxjpj.bkt.clouddn.com/15358192541466.jpg)\n\nYARN 的基本架构如上图所示，由三大功能模块组成，分别是 1) RM (ResourceManager) 2) NM (Node Manager) 3) AM(Application Master)\n<!--more-->\n作业提交\n1. 用户通过 Client 向 ResourceManager 提交 Application， ResourceManager 根据用户请求分配合适的 Container, 然后在指定的 NodeManager 上运行 Container 以启动 ApplicationMaster\n2. ApplicationMaster 启动完成后，向 ResourceManager 注册自己\n3. 对于用户的 Task，ApplicationMaster 需要首先跟 ResourceManager 进行协商以获取运行用户 Task 所需要的 Container，在获取成功后，ApplicationMaster 将任务发送给指定的 NodeManager\n4. NodeManager 启动相应的 Container，并运行用户 Task\n\n\n<!--more-->\n\n# Spark-On-Yarn的流程提交\n\n在 **yarn-cluster 模式下，Spark driver 运行在 application master 进程中**，这个进程被集群中的 YARN 所管理，客户端会在初始化应用程序 之后关闭。在 yarn-client 模式下，driver 运行在客户端进程中，application master 仅仅用来向 YARN 请求资源\n\n\n\n![](https://ws3.sinaimg.cn/large/006tNbRwgy1fuaxd9man3j31020o60w1.jpg)\n\nSpark Driver首先作为一个ApplicationMaster在YARN集群中启动，客户端提交给ResourceManager的时候，每一个job都会在集群的NodeManager节点上分配一个唯一的ApplicationMaster，由该ApplicationMaster管理全生命周期的应用。具体过程：\n\n1. 由client向ResourceManager提交请求，并上传jar到HDFS上\n   这期间包括四个步骤：\n   a).连接到RM\n   b).从RM的ASM（ApplicationsManager ）中获得metric、queue和resource等信息。\n   c). upload app jar and spark-assembly jar\n   d).设置运行环境和container上下文（launch-container.sh等脚本)\n2. ResouceManager向NodeManager申请资源，创建Spark ApplicationMaster（每个SparkContext都有一个ApplicationMaster）\n3. NodeManager启动ApplicationMaster，并向ResourceManager AsM注册\n4. ApplicationMaster从HDFS中找到jar文件，启动SparkContext、DAGscheduler和YARN Cluster Scheduler\n5. ResourceManager向ResourceManager AsM注册申请container资源\n6. ResourceManager通知NodeManager分配Container，这时可以收到来自ASM关于container的报告。（每个container对应一个executor）\n7. Spark ApplicationMaster直接和container（executor）进行交互，完成这个分布式任务。\n\n\n\n# ApplicationMaster和Driver的区别\n\n首先区分下 AppMaster 和 Driver，任何一个 yarn 上运行的任务都必须有一个 AppMaster，而任何一个 Spark 任务都会有一个 Driver，Driver 就是运行 SparkContext(它会构建 TaskScheduler 和 DAGScheduler) 的进程，当然在 Driver 上你也可以做很多非 Spark 的事情，这些事情只会在 Driver 上面执行，而由 SparkContext 上牵引出来的代码则会由 DAGScheduler 分析，并形成 Job 和 Stage 交由 TaskScheduler，再由 TaskScheduler 交由各 Executor 分布式执行。\n\n所以 Driver 和 AppMaster 是两个完全不同的东西，Driver 是控制 Spark 计算和任务资源的，而 AppMaster 是控制 yarn app 运行和任务资源的，只不过在 Spark on Yarn 上，这两者就出现了交叉，而在 standalone 模式下，资源则由 Driver 管理。在 Spark on Yarn 上，Driver 会和 AppMaster 通信，资源的申请由 AppMaster 来完成，而任务的调度和执行则由 Driver 完成，Driver 会通过与 AppMaster 通信来让 Executor 的执行具体的任务。\n\n> [Spark on Yarn](https://www.cnblogs.com/hseagle/p/3728713.html)\n\n\n","source":"_posts/Spark-on-Yarn源码解析(一)Yarn任务解析.md","raw":"---\ntitle: Spark-on-Yarn源码解析(一)Yarn任务解析\ndate: 2018年09月04日\ntags: [Spark,原理,Yarn]\ncategories: Spark-On-Yarn\ntoc: true\n---\n\n[TOC]\n\nspark-on-yarn系列\n[Spark-on-Yarn 源码解析 (一)Yarn 任务解析](http://www.gangtieguo.cn/2018/09/04/Spark-on-Yarn源码解析(一)Yarn任务解析/)\n[Spark-on-Yarn 源码解析 (二)Spark-Submit 解析](http://www.gangtieguo.cn/2018/09/04/Spark-on-Yarn源码解析(二)Spark-Submit解析/)\n[Spark-on-Yarn 源码解析 (三)client 做的事情](http://www.gangtieguo.cn/2018/09/04/Spark-on-Yarn源码解析(三)client做的事情/)\n[Spark-on-Yarn 源码解析 (四)Spark 业务代码的执行及其任务分配调度 stage 划分](http://www.gangtieguo.cn/2018/09/04/Spark-on-Yarn源码解析(四)Spark业务代码的执行及其任务分配调度stage划分/)\n\n了解spark-on-yarn,首先我们了解一下yarn提交的流程，俗话说，欲练此功，错了，我们还是先看吧\n\n# yarn任务的提交\nYARN 的基本架构和工作流程\n\n![](http://pebgsxjpj.bkt.clouddn.com/15358192541466.jpg)\n\nYARN 的基本架构如上图所示，由三大功能模块组成，分别是 1) RM (ResourceManager) 2) NM (Node Manager) 3) AM(Application Master)\n<!--more-->\n作业提交\n1. 用户通过 Client 向 ResourceManager 提交 Application， ResourceManager 根据用户请求分配合适的 Container, 然后在指定的 NodeManager 上运行 Container 以启动 ApplicationMaster\n2. ApplicationMaster 启动完成后，向 ResourceManager 注册自己\n3. 对于用户的 Task，ApplicationMaster 需要首先跟 ResourceManager 进行协商以获取运行用户 Task 所需要的 Container，在获取成功后，ApplicationMaster 将任务发送给指定的 NodeManager\n4. NodeManager 启动相应的 Container，并运行用户 Task\n\n\n<!--more-->\n\n# Spark-On-Yarn的流程提交\n\n在 **yarn-cluster 模式下，Spark driver 运行在 application master 进程中**，这个进程被集群中的 YARN 所管理，客户端会在初始化应用程序 之后关闭。在 yarn-client 模式下，driver 运行在客户端进程中，application master 仅仅用来向 YARN 请求资源\n\n\n\n![](https://ws3.sinaimg.cn/large/006tNbRwgy1fuaxd9man3j31020o60w1.jpg)\n\nSpark Driver首先作为一个ApplicationMaster在YARN集群中启动，客户端提交给ResourceManager的时候，每一个job都会在集群的NodeManager节点上分配一个唯一的ApplicationMaster，由该ApplicationMaster管理全生命周期的应用。具体过程：\n\n1. 由client向ResourceManager提交请求，并上传jar到HDFS上\n   这期间包括四个步骤：\n   a).连接到RM\n   b).从RM的ASM（ApplicationsManager ）中获得metric、queue和resource等信息。\n   c). upload app jar and spark-assembly jar\n   d).设置运行环境和container上下文（launch-container.sh等脚本)\n2. ResouceManager向NodeManager申请资源，创建Spark ApplicationMaster（每个SparkContext都有一个ApplicationMaster）\n3. NodeManager启动ApplicationMaster，并向ResourceManager AsM注册\n4. ApplicationMaster从HDFS中找到jar文件，启动SparkContext、DAGscheduler和YARN Cluster Scheduler\n5. ResourceManager向ResourceManager AsM注册申请container资源\n6. ResourceManager通知NodeManager分配Container，这时可以收到来自ASM关于container的报告。（每个container对应一个executor）\n7. Spark ApplicationMaster直接和container（executor）进行交互，完成这个分布式任务。\n\n\n\n# ApplicationMaster和Driver的区别\n\n首先区分下 AppMaster 和 Driver，任何一个 yarn 上运行的任务都必须有一个 AppMaster，而任何一个 Spark 任务都会有一个 Driver，Driver 就是运行 SparkContext(它会构建 TaskScheduler 和 DAGScheduler) 的进程，当然在 Driver 上你也可以做很多非 Spark 的事情，这些事情只会在 Driver 上面执行，而由 SparkContext 上牵引出来的代码则会由 DAGScheduler 分析，并形成 Job 和 Stage 交由 TaskScheduler，再由 TaskScheduler 交由各 Executor 分布式执行。\n\n所以 Driver 和 AppMaster 是两个完全不同的东西，Driver 是控制 Spark 计算和任务资源的，而 AppMaster 是控制 yarn app 运行和任务资源的，只不过在 Spark on Yarn 上，这两者就出现了交叉，而在 standalone 模式下，资源则由 Driver 管理。在 Spark on Yarn 上，Driver 会和 AppMaster 通信，资源的申请由 AppMaster 来完成，而任务的调度和执行则由 Driver 完成，Driver 会通过与 AppMaster 通信来让 Executor 的执行具体的任务。\n\n> [Spark on Yarn](https://www.cnblogs.com/hseagle/p/3728713.html)\n\n\n","slug":"Spark-on-Yarn源码解析(一)Yarn任务解析","published":1,"updated":"2018-09-04T10:13:56.834Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloj0lm2002tykpb18srbtw5"},{"title":"Spark-on-Yarn源码解析(三)client做的事情","date":"2018-09-04T08:13:34.283Z","toc":true,"_content":"\n[TOC]\n\n\nspark-on-yarn系列\n\n[Spark-on-Yarn 源码解析 (一)Yarn 任务解析](http://www.gangtieguo.cn/2018/09/04/Spark-on-Yarn源码解析(一)Yarn任务解析/)\n[Spark-on-Yarn 源码解析 (二)Spark-Submit 解析](http://www.gangtieguo.cn/2018/09/04/Spark-on-Yarn源码解析(二)Spark-Submit解析/)\n[Spark-on-Yarn 源码解析 (三)client 做的事情](http://www.gangtieguo.cn/2018/09/04/Spark-on-Yarn源码解析(三)client做的事情/)\n[Spark-on-Yarn 源码解析 (四)Spark 业务代码的执行及其任务分配调度 stage 划分](http://www.gangtieguo.cn/2018/09/04/Spark-on-Yarn源码解析(四)Spark业务代码的执行及其任务分配调度stage划分/)\n\n\n\n\norg.apache.spark.deploy.yarn.Client\n\n话不多说，先上源码，当然还是简洁版本的\n\n这儿我先上一下最简洁的调用链。\n\n    Client.main()\n        ->new Client().run()\n             ->monitorApplication(submitApplication())\n                ->submitApplication()\n                    ->createContainerLaunchContext()会封装一些启动信息如我们启动的类 --class\n                        ->userClass\n                        ->amArgs\n                        ->commands\n                        ->printableCommands\n                        ->amClass applicationMaster启动的真实类\n                        \n                    ->createApplicationSubmissionContext()\n                        ->Records.newRecord(classOf[Resource])启动\n                    ->yarnClientImpl.submitApplication(appContext)                \n\n<!--more-->\n\n最终是调用的client里面main方法->run->\n\nmonitorApplication(submitApplication())\n\n    object Client extends Logging {\n      def main(argStrings: Array[String]) {\n        ... ...\n        val sparkConf = new SparkConf\n        val args = new ClientArguments(argStrings, sparkConf)\n        new Client(args, sparkConf).run()\n        ... ...\n      }\n    }\n    \n    ... ...\n    def run(): Unit = {\n        val (yarnApplicationState, finalApplicationStatus) = monitorApplication(submitApplication())\n        }\n    ... ...\n    def submitApplication(): ApplicationId = {\n        // TODO: 初始化并且启动client\n        yarnClient.init(yarnConf)\n        yarnClient.start()\n        // TODO: 准备提交请求到resouceManager\n        val newApp = yarnClient.createApplication()\n        val newAppResponse = newApp.getNewApplicationResponse()\n        val appId = newAppResponse.getApplicationId()\n        // TODO: 检查集群的内存是否满足当前的任务要求\n        verifyClusterResources(newAppResponse)\n        // TODO:  设置适当上下文环境来启动applicationMaster\n        val containerContext = createContainerLaunchContext(newAppResponse)\n        val appContext = createApplicationSubmissionContext(newApp, containerContext)\n        // TODO: 提交application\n        yarnClient.submitApplication(appContext)\n        appId\n      }\n       private def createContainerLaunchContext(newAppResponse: GetNewApplicationResponse)\n        : ContainerLaunchContext = {\n        ... ...\n              val userClass =\n          if (isClusterMode) {\n            Seq(\"--class\", YarnSparkHadoopUtil.escapeForShell(args.userClass))\n          } else {\n            Nil\n          }\n          ...\n           val amClass =\n          if (isClusterMode) {\n    Class.forName(\"org.apache.spark.deploy.yarn.ApplicationMaster\").getName\n          } else {\n    Class.forName(\"org.apache.spark.deploy.yarn.ExecutorLauncher\").getName\n          }\n              val amArgs =\n          Seq(amClass) ++ userClass ++ userJar ++ primaryPyFile ++ pyFiles ++ userArgs ++\n            Seq(\n              \"--executor-memory\", args.executorMemory.toString + \"m\",\n              \"--executor-cores\", args.executorCores.toString,\n              \"--num-executors \", args.numExecutors.toString)\n    \n        val commands = prefixEnv ++ Seq(YarnSparkHadoopUtil.expandEnvironment(Environment.JAVA_HOME) + \"/bin/java\", \"-server\"\n          ) ++\n          javaOpts ++ amArgs ++\n        ... ...\n         val printableCommands = commands.map(s => if (s == null) \"null\" else s).toList\n        amContainer.setCommands(printableCommands)\n        }\n        ... ...\n    def createApplicationSubmissionContext(\n          newApp: YarnClientApplication,\n          containerContext: ContainerLaunchContext): ApplicationSubmissionContext = {\n        val appContext = newApp.getApplicationSubmissionContext\n        appContext.setApplicationName(args.appName)\n        appContext.setQueue(args.amQueue)\n        appContext.setAMContainerSpec(containerContext)\n        appContext.setApplicationType(\"SPARK\")\n        sparkConf.getOption(\"spark.yarn.maxAppAttempts\").map(_.toInt) match {\n          case Some(v) => appContext.setMaxAppAttempts(v)\n          case None => logDebug(\"spark.yarn.maxAppAttempts is not set. \" +\n              \"Cluster's default value will be used.\")\n        }\n       \n        val capability = Records.newRecord(classOf[Resource])\n        capability.setMemory(args.amMemory + amMemoryOverhead)\n        capability.setVirtualCores(args.amCores)\n        appContext.setResource(capability)\n        appContext\n      }\n    \n    //yarnClient.submitApplication(appContext)提交的真实处  \n    @Override\n      public ApplicationId\n          submitApplication(ApplicationSubmissionContext appContext)\n              throws YarnException, IOException {\n    ...\n    //此处通过yarn的协议对applicationMaster进行提交和启动 （此处为个人理解有疑惑，如有错误，还望留言分享，会立即作出更正）\n        SubmitApplicationRequest request =\n            Records.newRecord(SubmitApplicationRequest.class);\n        request.setApplicationSubmissionContext(appContext);\n    ...\n\n此处client的事情都已经做完了，请摄影师将镜头切换到applicationMaster\n\n\n\n小细节用户业务代码信息的封装及流转\n\n我们提交的class的封装流程\n\n    \n\n    ->sublimit的prepareSubmitEnvironment中封装到childArgs中--class\n    ->传入到client的构造函数里面作为clientArgs，将其封装到userClass属性里面\n    \n    在submitApplication中createContainerLaunchContext会将其通过重新封到userClass\n        userClass->amArgs->commands->printableCommands\n        ->amContainer.setCommands(printableCommands)\n        在此，createContainerLaunchContext方法接收到amContainer赋名为containerContext传递给createApplicationSubmissionContext(..,containerContext)\n        \n    那么在createApplicationSubmissionContext中又有哪些惊天变化（其实并没有）\n    \n    appContext.setAMContainerSpec(containerContext)\n    那么appContext作为createApplicationSubmissionContext方法返回值，由appContext接收，看码\n    \n    appContext = createApplicationSubmissionContext(newApp, containerContext)\n    最后，由yarnClientImpl提交\n    yarnClient.submitApplication(appContext)\n    码又来了，最终执行的是\n    SubmitApplicationRequest request =Records.newRecord(SubmitApplicationRequest.class);\n\n启动applicationMaster\n\n对于client的封装，对于applicationMaster需要启动的信息(如资源信息)及用户提交的业务代码（wordcount的类信息）信息都已经封装到appContext，并且传递到applicationmaster，那么来看看applicationMaster的执行流程。\n\n程序调用结构\n\n    ApplicationMaster.main()\n        ->run()\n            ->runDriver()\n                ->run()\n                    ->startUserApplication()\n                        //启动userClass\n                        ->userClassLoader.loadClass(args.userClass)\n          .getMethod(\"main\", classOf[Array[String]])\n                         ->mainMethod.invoke(null, mainArgs)\n                    runAMActor()\n                    registerAM()\n                        ->yarnRmClient.register()->return new YarnAllocater(......)\n                        ->yarnAllocator.allocateResources()\n                            ->yarnAllocator.handleAllocatedContainers()\n                            //启动executor\n                            ->yarnAllocator.runAllocatedContainers(containersToUse)\n\nrunAllocatedContainers(containersToUse)是去启动 executor，最终真正执行启动Container的是在 ExecutorRunnable.run()中。\n\n创建了 NMClient 客户端调用提供的 API 最终实现在 NM 上启动 Container，具体如何启动 Container 将在后文中进行介绍。\n\n    \n\nlauncherPool线程池会将container，driver等相关信息封装成ExecutorRunnable对象，通过ExecutorRunnable启动新的container以运行executor。在此过程中，指定启动executor的类是\n\norg.apache.spark.executor.CoarseGrainedExecutorBackend。spark yarn cluster 模式下任务提交和计算流程分析\n\n程序的细节\n\n    def main(args: Array[String]) = {\n        SignalLogger.register(log)\n        val amArgs = new ApplicationMasterArguments(args)\n        SparkHadoopUtil.get.runAsSparkUser { () =>\n          master = new ApplicationMaster(amArgs, new YarnRMClient(amArgs))\n          System.exit(master.run())\n        }\n      }\n      \n      \n      ......\n      final def run(): Int = {\n      ....\n        if (isClusterMode) {\n            runDriver(securityMgr)\n          } else {\n            runExecutorLauncher(securityMgr)\n          }\n    ...\n    }\n    \n      private def runDriver(securityMgr: SecurityManager): Unit = {\n        addAmIpFilter()\n        // TODO:  启动我们自定的类，也就是启动submit里面的--class的东西\n        userClassThread = startUserApplication()\n        val sc = waitForSparkContextInitialized()\n    ...\n      actorSystem = sc.env.actorSystem\n      runAMActor(\n        sc.getConf.get(\"spark.driver.host\"),\n        sc.getConf.get(\"spark.driver.port\"),\n        isClusterMode = true)\n      registerAM(sc.ui.map(_.appUIAddress).getOrElse(\"\"), securityMgr)\n      userClassThread.join()\n        ...\n      }\n\n在ApplicationMasterArguments设置了要启动的信息\n\n    class ApplicationMasterArguments(val args: Array[String]) {\n      var userJar: String = null\n      var userClass: String = null\n      var primaryPyFile: String = null\n      var pyFiles: String = null\n      var userArgs: Seq[String] = Seq[String]()\n      var executorMemory = 1024\n      var executorCores = 1\n      var numExecutors = DEFAULT_NUMBER_EXECUTORS\n      ......\n      }\n\nstartUserApplication 主要执行了调用用户的代码，以及创建了一个 spark driver 的进程。 \n\nStart the user class, which contains the spark driver, in a separate Thread.\n\n    private def startUserApplication(): Thread = {\n      val classpath = Client.getUserClasspath(sparkConf)\n    val urls = classpath.map { entry =>\n      new URL(\"file:\" + new File(entry.getPath()).getAbsolutePath())\n    }\n    val userClassLoader =\n    ...\n    // TODO:  userClass就是submit里面的--class 提交的类\n    val mainMethod = userClassLoader.loadClass(args.userClass)\n      .getMethod(\"main\", classOf[Array[String]])\n    userThread.setContextClassLoader(userClassLoader)\n    userThread.setName(\"Driver\")\n    userThread.start()\n    userThread\n    }\n\n从userThread.setName(\"Driver\")也可以看出创建的是名为driver的进程\n\nregisterAM 向 resourceManager 中正式注册 applicationMaster。注册applicationMaster 以后，并且分配资源，这样，用户代码就可以执行了，任务切分、调度、执行。\n\n然后，用户代码中的 action 会调用 SparkContext 的 runJob，SparkContext 中有很多个 runJob，但最后都是调用 DAGScheduler 的 runJob\n\n        // registerAM\n         private def registerAM(uiAddress: String, securityMgr: SecurityManager) = {\n         .....\n        allocator = client.register(yarnConf,\n          if (sc != null) sc.getConf else sparkConf,\n          if (sc != null) sc.preferredNodeLocationData else Map(),\n          uiAddress,\n          historyAddress,\n          securityMgr)\n          //为exector分配资源\n        allocator.allocateResources()\n        reporterThread = launchReporterThread()\n        ......\n      }\n\n\n\n","source":"_posts/Spark-on-Yarn源码解析(三)client做的事情.md","raw":"---\ntitle: Spark-on-Yarn源码解析(三)client做的事情\ndate: 2018年09月04日\ntags: [Spark,原理]\ncategories: Spark-On-Yarn\ntoc: true\n---\n\n[TOC]\n\n\nspark-on-yarn系列\n\n[Spark-on-Yarn 源码解析 (一)Yarn 任务解析](http://www.gangtieguo.cn/2018/09/04/Spark-on-Yarn源码解析(一)Yarn任务解析/)\n[Spark-on-Yarn 源码解析 (二)Spark-Submit 解析](http://www.gangtieguo.cn/2018/09/04/Spark-on-Yarn源码解析(二)Spark-Submit解析/)\n[Spark-on-Yarn 源码解析 (三)client 做的事情](http://www.gangtieguo.cn/2018/09/04/Spark-on-Yarn源码解析(三)client做的事情/)\n[Spark-on-Yarn 源码解析 (四)Spark 业务代码的执行及其任务分配调度 stage 划分](http://www.gangtieguo.cn/2018/09/04/Spark-on-Yarn源码解析(四)Spark业务代码的执行及其任务分配调度stage划分/)\n\n\n\n\norg.apache.spark.deploy.yarn.Client\n\n话不多说，先上源码，当然还是简洁版本的\n\n这儿我先上一下最简洁的调用链。\n\n    Client.main()\n        ->new Client().run()\n             ->monitorApplication(submitApplication())\n                ->submitApplication()\n                    ->createContainerLaunchContext()会封装一些启动信息如我们启动的类 --class\n                        ->userClass\n                        ->amArgs\n                        ->commands\n                        ->printableCommands\n                        ->amClass applicationMaster启动的真实类\n                        \n                    ->createApplicationSubmissionContext()\n                        ->Records.newRecord(classOf[Resource])启动\n                    ->yarnClientImpl.submitApplication(appContext)                \n\n<!--more-->\n\n最终是调用的client里面main方法->run->\n\nmonitorApplication(submitApplication())\n\n    object Client extends Logging {\n      def main(argStrings: Array[String]) {\n        ... ...\n        val sparkConf = new SparkConf\n        val args = new ClientArguments(argStrings, sparkConf)\n        new Client(args, sparkConf).run()\n        ... ...\n      }\n    }\n    \n    ... ...\n    def run(): Unit = {\n        val (yarnApplicationState, finalApplicationStatus) = monitorApplication(submitApplication())\n        }\n    ... ...\n    def submitApplication(): ApplicationId = {\n        // TODO: 初始化并且启动client\n        yarnClient.init(yarnConf)\n        yarnClient.start()\n        // TODO: 准备提交请求到resouceManager\n        val newApp = yarnClient.createApplication()\n        val newAppResponse = newApp.getNewApplicationResponse()\n        val appId = newAppResponse.getApplicationId()\n        // TODO: 检查集群的内存是否满足当前的任务要求\n        verifyClusterResources(newAppResponse)\n        // TODO:  设置适当上下文环境来启动applicationMaster\n        val containerContext = createContainerLaunchContext(newAppResponse)\n        val appContext = createApplicationSubmissionContext(newApp, containerContext)\n        // TODO: 提交application\n        yarnClient.submitApplication(appContext)\n        appId\n      }\n       private def createContainerLaunchContext(newAppResponse: GetNewApplicationResponse)\n        : ContainerLaunchContext = {\n        ... ...\n              val userClass =\n          if (isClusterMode) {\n            Seq(\"--class\", YarnSparkHadoopUtil.escapeForShell(args.userClass))\n          } else {\n            Nil\n          }\n          ...\n           val amClass =\n          if (isClusterMode) {\n    Class.forName(\"org.apache.spark.deploy.yarn.ApplicationMaster\").getName\n          } else {\n    Class.forName(\"org.apache.spark.deploy.yarn.ExecutorLauncher\").getName\n          }\n              val amArgs =\n          Seq(amClass) ++ userClass ++ userJar ++ primaryPyFile ++ pyFiles ++ userArgs ++\n            Seq(\n              \"--executor-memory\", args.executorMemory.toString + \"m\",\n              \"--executor-cores\", args.executorCores.toString,\n              \"--num-executors \", args.numExecutors.toString)\n    \n        val commands = prefixEnv ++ Seq(YarnSparkHadoopUtil.expandEnvironment(Environment.JAVA_HOME) + \"/bin/java\", \"-server\"\n          ) ++\n          javaOpts ++ amArgs ++\n        ... ...\n         val printableCommands = commands.map(s => if (s == null) \"null\" else s).toList\n        amContainer.setCommands(printableCommands)\n        }\n        ... ...\n    def createApplicationSubmissionContext(\n          newApp: YarnClientApplication,\n          containerContext: ContainerLaunchContext): ApplicationSubmissionContext = {\n        val appContext = newApp.getApplicationSubmissionContext\n        appContext.setApplicationName(args.appName)\n        appContext.setQueue(args.amQueue)\n        appContext.setAMContainerSpec(containerContext)\n        appContext.setApplicationType(\"SPARK\")\n        sparkConf.getOption(\"spark.yarn.maxAppAttempts\").map(_.toInt) match {\n          case Some(v) => appContext.setMaxAppAttempts(v)\n          case None => logDebug(\"spark.yarn.maxAppAttempts is not set. \" +\n              \"Cluster's default value will be used.\")\n        }\n       \n        val capability = Records.newRecord(classOf[Resource])\n        capability.setMemory(args.amMemory + amMemoryOverhead)\n        capability.setVirtualCores(args.amCores)\n        appContext.setResource(capability)\n        appContext\n      }\n    \n    //yarnClient.submitApplication(appContext)提交的真实处  \n    @Override\n      public ApplicationId\n          submitApplication(ApplicationSubmissionContext appContext)\n              throws YarnException, IOException {\n    ...\n    //此处通过yarn的协议对applicationMaster进行提交和启动 （此处为个人理解有疑惑，如有错误，还望留言分享，会立即作出更正）\n        SubmitApplicationRequest request =\n            Records.newRecord(SubmitApplicationRequest.class);\n        request.setApplicationSubmissionContext(appContext);\n    ...\n\n此处client的事情都已经做完了，请摄影师将镜头切换到applicationMaster\n\n\n\n小细节用户业务代码信息的封装及流转\n\n我们提交的class的封装流程\n\n    \n\n    ->sublimit的prepareSubmitEnvironment中封装到childArgs中--class\n    ->传入到client的构造函数里面作为clientArgs，将其封装到userClass属性里面\n    \n    在submitApplication中createContainerLaunchContext会将其通过重新封到userClass\n        userClass->amArgs->commands->printableCommands\n        ->amContainer.setCommands(printableCommands)\n        在此，createContainerLaunchContext方法接收到amContainer赋名为containerContext传递给createApplicationSubmissionContext(..,containerContext)\n        \n    那么在createApplicationSubmissionContext中又有哪些惊天变化（其实并没有）\n    \n    appContext.setAMContainerSpec(containerContext)\n    那么appContext作为createApplicationSubmissionContext方法返回值，由appContext接收，看码\n    \n    appContext = createApplicationSubmissionContext(newApp, containerContext)\n    最后，由yarnClientImpl提交\n    yarnClient.submitApplication(appContext)\n    码又来了，最终执行的是\n    SubmitApplicationRequest request =Records.newRecord(SubmitApplicationRequest.class);\n\n启动applicationMaster\n\n对于client的封装，对于applicationMaster需要启动的信息(如资源信息)及用户提交的业务代码（wordcount的类信息）信息都已经封装到appContext，并且传递到applicationmaster，那么来看看applicationMaster的执行流程。\n\n程序调用结构\n\n    ApplicationMaster.main()\n        ->run()\n            ->runDriver()\n                ->run()\n                    ->startUserApplication()\n                        //启动userClass\n                        ->userClassLoader.loadClass(args.userClass)\n          .getMethod(\"main\", classOf[Array[String]])\n                         ->mainMethod.invoke(null, mainArgs)\n                    runAMActor()\n                    registerAM()\n                        ->yarnRmClient.register()->return new YarnAllocater(......)\n                        ->yarnAllocator.allocateResources()\n                            ->yarnAllocator.handleAllocatedContainers()\n                            //启动executor\n                            ->yarnAllocator.runAllocatedContainers(containersToUse)\n\nrunAllocatedContainers(containersToUse)是去启动 executor，最终真正执行启动Container的是在 ExecutorRunnable.run()中。\n\n创建了 NMClient 客户端调用提供的 API 最终实现在 NM 上启动 Container，具体如何启动 Container 将在后文中进行介绍。\n\n    \n\nlauncherPool线程池会将container，driver等相关信息封装成ExecutorRunnable对象，通过ExecutorRunnable启动新的container以运行executor。在此过程中，指定启动executor的类是\n\norg.apache.spark.executor.CoarseGrainedExecutorBackend。spark yarn cluster 模式下任务提交和计算流程分析\n\n程序的细节\n\n    def main(args: Array[String]) = {\n        SignalLogger.register(log)\n        val amArgs = new ApplicationMasterArguments(args)\n        SparkHadoopUtil.get.runAsSparkUser { () =>\n          master = new ApplicationMaster(amArgs, new YarnRMClient(amArgs))\n          System.exit(master.run())\n        }\n      }\n      \n      \n      ......\n      final def run(): Int = {\n      ....\n        if (isClusterMode) {\n            runDriver(securityMgr)\n          } else {\n            runExecutorLauncher(securityMgr)\n          }\n    ...\n    }\n    \n      private def runDriver(securityMgr: SecurityManager): Unit = {\n        addAmIpFilter()\n        // TODO:  启动我们自定的类，也就是启动submit里面的--class的东西\n        userClassThread = startUserApplication()\n        val sc = waitForSparkContextInitialized()\n    ...\n      actorSystem = sc.env.actorSystem\n      runAMActor(\n        sc.getConf.get(\"spark.driver.host\"),\n        sc.getConf.get(\"spark.driver.port\"),\n        isClusterMode = true)\n      registerAM(sc.ui.map(_.appUIAddress).getOrElse(\"\"), securityMgr)\n      userClassThread.join()\n        ...\n      }\n\n在ApplicationMasterArguments设置了要启动的信息\n\n    class ApplicationMasterArguments(val args: Array[String]) {\n      var userJar: String = null\n      var userClass: String = null\n      var primaryPyFile: String = null\n      var pyFiles: String = null\n      var userArgs: Seq[String] = Seq[String]()\n      var executorMemory = 1024\n      var executorCores = 1\n      var numExecutors = DEFAULT_NUMBER_EXECUTORS\n      ......\n      }\n\nstartUserApplication 主要执行了调用用户的代码，以及创建了一个 spark driver 的进程。 \n\nStart the user class, which contains the spark driver, in a separate Thread.\n\n    private def startUserApplication(): Thread = {\n      val classpath = Client.getUserClasspath(sparkConf)\n    val urls = classpath.map { entry =>\n      new URL(\"file:\" + new File(entry.getPath()).getAbsolutePath())\n    }\n    val userClassLoader =\n    ...\n    // TODO:  userClass就是submit里面的--class 提交的类\n    val mainMethod = userClassLoader.loadClass(args.userClass)\n      .getMethod(\"main\", classOf[Array[String]])\n    userThread.setContextClassLoader(userClassLoader)\n    userThread.setName(\"Driver\")\n    userThread.start()\n    userThread\n    }\n\n从userThread.setName(\"Driver\")也可以看出创建的是名为driver的进程\n\nregisterAM 向 resourceManager 中正式注册 applicationMaster。注册applicationMaster 以后，并且分配资源，这样，用户代码就可以执行了，任务切分、调度、执行。\n\n然后，用户代码中的 action 会调用 SparkContext 的 runJob，SparkContext 中有很多个 runJob，但最后都是调用 DAGScheduler 的 runJob\n\n        // registerAM\n         private def registerAM(uiAddress: String, securityMgr: SecurityManager) = {\n         .....\n        allocator = client.register(yarnConf,\n          if (sc != null) sc.getConf else sparkConf,\n          if (sc != null) sc.preferredNodeLocationData else Map(),\n          uiAddress,\n          historyAddress,\n          securityMgr)\n          //为exector分配资源\n        allocator.allocateResources()\n        reporterThread = launchReporterThread()\n        ......\n      }\n\n\n\n","slug":"Spark-on-Yarn源码解析(三)client做的事情","published":1,"updated":"2018-09-04T10:14:03.710Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloj0lm3002xykpbgp6zoc86"},{"title":"Spark-on-Yarn源码解析(二)Spark-Submit解析","date":"2018-09-04T08:03:50.700Z","toc":true,"_content":"\n[TOC]\n\nspark-on-yarn系列\n\n[Spark-on-Yarn 源码解析 (一)Yarn 任务解析](http://www.gangtieguo.cn/2018/09/04/Spark-on-Yarn源码解析(一)Yarn任务解析/)\n[Spark-on-Yarn 源码解析 (二)Spark-Submit 解析](http://www.gangtieguo.cn/2018/09/04/Spark-on-Yarn源码解析(二)Spark-Submit解析/)\n[Spark-on-Yarn 源码解析 (三)client 做的事情](http://www.gangtieguo.cn/2018/09/04/Spark-on-Yarn源码解析(三)client做的事情/)\n[Spark-on-Yarn 源码解析 (四)Spark 业务代码的执行及其任务分配调度 stage 划分](http://www.gangtieguo.cn/2018/09/04/Spark-on-Yarn源码解析(四)Spark业务代码的执行及其任务分配调度stage划分/)\n\n\n\n\n\n\n\n\n上文我们了解到了yarn的架构和执行任务的流程，接下来我们看看\n\n# spark-submit命令\n\n    $SPARK_HOME/bin/spark-submit \\\n    --master yarn \\ //提交模式 yarn\n    --deploy-mode cluster \\ //运行的模式，还有一种client模式，但大多用于调试，此处使用cluster模式\n    --class me.yao.spark.me.yao.spark.WordCount \\ //提交的任务\n    --name \"wc\" \\ //任务名字\n    --queue root.default \\ //提交的队列\n    --driver-memory 3g \\ //为driver申请的内存\n    --num-executors 1 \\ //executors的数量，可以理解为线程数，对应yarn中的Container个数\n    --executor-memory 6g \\ //为每一个executor申请的内存\n    --executor-cores 4 \\ //为每一个executor申请的core\n    --conf spark.yarn.driver.memoryOverhead=1g \\ //driver可使用的非堆内存，这些内存用于如VM，字符 串常量池以及其他额外本地开销等\n    --conf spark.yarn.executor.memoryOverhead=2g \\ //每个executor可使用的非堆内存，这些内存用于如 VM，字符串常量池以及其他额外本地开销等\n\n这是通常我们提交spark程序的submit命令，以此为切入点，对spark程序的运行流程做一个跟踪和分析。\n<!--more-->\n查看spark-submit脚本\n![](http://pebgsxjpj.bkt.clouddn.com/15359432887877.jpg)\n\n查看spark-submit脚本的信息，初步可以看到submit启动的类为org.apache.spark.deploy.SparkSubmit，更多细节其实不重要（开个开玩，极客可以求甚解）如果觉得要深究一下为什么是submit的main方法的可以参考一下spark on yarn 作业提交源码分析\n\n\n\n接下来查看该类内部的处理逻辑\n\nSparkSumbmit的类（为了简洁和文章篇幅，只保留了关键流程的信息）\n\n      def main(args: Array[String]): Unit = {\n        val appArgs = new SparkSubmitArguments(args)\n        if (appArgs.verbose) {\n          printStream.println(appArgs)\n        }\n        appArgs.action match {\n          case SparkSubmitAction.SUBMIT => submit(appArgs)\n          case SparkSubmitAction.KILL => kill(appArgs)\n          case SparkSubmitAction.REQUEST_STATUS => requestStatus(appArgs)\n        }\n      }\n    ......\n    \n      private[spark] def submit(args: SparkSubmitArguments): Unit = {\n        val (childArgs, childClasspath, sysProps, childMainClass) = \n    prepareSubmitEnvironment(args)\n    .....\n    .....\n     runMain(childArgs, childClasspath, sysProps, childMainClass, args.verbose)\n    }\n    \n     private[spark] def prepareSubmitEnvironment(args: SparkSubmitArguments)\n          : (Seq[String], Seq[String], Map[String, String], String) = {\n          ......\n          // In yarn-cluster mode, use yarn.Client as a wrapper around the user class\n        if (isYarnCluster) {\n          childMainClass = \"org.apache.spark.deploy.yarn.Client\"\n          .......\n          }\n    //在submit方法中最终调用的是\n    runMain(childArgs, childClasspath, sysProps, childMainClass, args.verbose)\n    try {\n          mainClass = Class.forName(childMainClass, true, loader)\n        } catch {\n        ......\n        System.exit(CLASS_NOT_FOUND_EXIT_STATUS)\n        }\n        // SPARK-4170\n        private def runMain(\n          childArgs: Seq[String],\n          childClasspath: Seq[String],\n          sysProps: Map[String, String],\n          childMainClass: String,\n          verbose: Boolean): Unit = {\n        ... ...\n        \n        mainClass = Class.forName(childMainClass, true, loader)\n        ... ...\n        val mainMethod = mainClass.getMethod(\"main\", new Array[String](0).getClass)\n        ... ...\n        mainMethod.invoke(null, childArgs.toArray)\n        ... ...\n        }\n\n通过上面的流程可以看到，这样一个调用链(未特殊表明类名，表明为该步上一步的同一类)，我们代码简化一下，看得舒心明了，再配上解说\n\n    submit.main()\n        ->submit()模式匹配到该方法，因为我们就是submit提交任务\n            ->prepareSubmitEnvironment()该方法中指明了要启动的类，就是大明湖畔的Client\n            ->runMain()通过上步指定的类，然后通过反射调用main方法\n\n既然我们的线路走到org.apache.spark.deploy.yarn.Client        ，那我们再去这个类一看究竟，且听下回分解\n\n","source":"_posts/Spark-on-Yarn源码解析(二)Spark-Submit解析.md","raw":"---\ntitle: Spark-on-Yarn源码解析(二)Spark-Submit解析\ndate: 2018年09月04日\ntags: [Spark,原理]\ncategories: Spark-On-Yarn\ntoc: true\n---\n\n[TOC]\n\nspark-on-yarn系列\n\n[Spark-on-Yarn 源码解析 (一)Yarn 任务解析](http://www.gangtieguo.cn/2018/09/04/Spark-on-Yarn源码解析(一)Yarn任务解析/)\n[Spark-on-Yarn 源码解析 (二)Spark-Submit 解析](http://www.gangtieguo.cn/2018/09/04/Spark-on-Yarn源码解析(二)Spark-Submit解析/)\n[Spark-on-Yarn 源码解析 (三)client 做的事情](http://www.gangtieguo.cn/2018/09/04/Spark-on-Yarn源码解析(三)client做的事情/)\n[Spark-on-Yarn 源码解析 (四)Spark 业务代码的执行及其任务分配调度 stage 划分](http://www.gangtieguo.cn/2018/09/04/Spark-on-Yarn源码解析(四)Spark业务代码的执行及其任务分配调度stage划分/)\n\n\n\n\n\n\n\n\n上文我们了解到了yarn的架构和执行任务的流程，接下来我们看看\n\n# spark-submit命令\n\n    $SPARK_HOME/bin/spark-submit \\\n    --master yarn \\ //提交模式 yarn\n    --deploy-mode cluster \\ //运行的模式，还有一种client模式，但大多用于调试，此处使用cluster模式\n    --class me.yao.spark.me.yao.spark.WordCount \\ //提交的任务\n    --name \"wc\" \\ //任务名字\n    --queue root.default \\ //提交的队列\n    --driver-memory 3g \\ //为driver申请的内存\n    --num-executors 1 \\ //executors的数量，可以理解为线程数，对应yarn中的Container个数\n    --executor-memory 6g \\ //为每一个executor申请的内存\n    --executor-cores 4 \\ //为每一个executor申请的core\n    --conf spark.yarn.driver.memoryOverhead=1g \\ //driver可使用的非堆内存，这些内存用于如VM，字符 串常量池以及其他额外本地开销等\n    --conf spark.yarn.executor.memoryOverhead=2g \\ //每个executor可使用的非堆内存，这些内存用于如 VM，字符串常量池以及其他额外本地开销等\n\n这是通常我们提交spark程序的submit命令，以此为切入点，对spark程序的运行流程做一个跟踪和分析。\n<!--more-->\n查看spark-submit脚本\n![](http://pebgsxjpj.bkt.clouddn.com/15359432887877.jpg)\n\n查看spark-submit脚本的信息，初步可以看到submit启动的类为org.apache.spark.deploy.SparkSubmit，更多细节其实不重要（开个开玩，极客可以求甚解）如果觉得要深究一下为什么是submit的main方法的可以参考一下spark on yarn 作业提交源码分析\n\n\n\n接下来查看该类内部的处理逻辑\n\nSparkSumbmit的类（为了简洁和文章篇幅，只保留了关键流程的信息）\n\n      def main(args: Array[String]): Unit = {\n        val appArgs = new SparkSubmitArguments(args)\n        if (appArgs.verbose) {\n          printStream.println(appArgs)\n        }\n        appArgs.action match {\n          case SparkSubmitAction.SUBMIT => submit(appArgs)\n          case SparkSubmitAction.KILL => kill(appArgs)\n          case SparkSubmitAction.REQUEST_STATUS => requestStatus(appArgs)\n        }\n      }\n    ......\n    \n      private[spark] def submit(args: SparkSubmitArguments): Unit = {\n        val (childArgs, childClasspath, sysProps, childMainClass) = \n    prepareSubmitEnvironment(args)\n    .....\n    .....\n     runMain(childArgs, childClasspath, sysProps, childMainClass, args.verbose)\n    }\n    \n     private[spark] def prepareSubmitEnvironment(args: SparkSubmitArguments)\n          : (Seq[String], Seq[String], Map[String, String], String) = {\n          ......\n          // In yarn-cluster mode, use yarn.Client as a wrapper around the user class\n        if (isYarnCluster) {\n          childMainClass = \"org.apache.spark.deploy.yarn.Client\"\n          .......\n          }\n    //在submit方法中最终调用的是\n    runMain(childArgs, childClasspath, sysProps, childMainClass, args.verbose)\n    try {\n          mainClass = Class.forName(childMainClass, true, loader)\n        } catch {\n        ......\n        System.exit(CLASS_NOT_FOUND_EXIT_STATUS)\n        }\n        // SPARK-4170\n        private def runMain(\n          childArgs: Seq[String],\n          childClasspath: Seq[String],\n          sysProps: Map[String, String],\n          childMainClass: String,\n          verbose: Boolean): Unit = {\n        ... ...\n        \n        mainClass = Class.forName(childMainClass, true, loader)\n        ... ...\n        val mainMethod = mainClass.getMethod(\"main\", new Array[String](0).getClass)\n        ... ...\n        mainMethod.invoke(null, childArgs.toArray)\n        ... ...\n        }\n\n通过上面的流程可以看到，这样一个调用链(未特殊表明类名，表明为该步上一步的同一类)，我们代码简化一下，看得舒心明了，再配上解说\n\n    submit.main()\n        ->submit()模式匹配到该方法，因为我们就是submit提交任务\n            ->prepareSubmitEnvironment()该方法中指明了要启动的类，就是大明湖畔的Client\n            ->runMain()通过上步指定的类，然后通过反射调用main方法\n\n既然我们的线路走到org.apache.spark.deploy.yarn.Client        ，那我们再去这个类一看究竟，且听下回分解\n\n","slug":"Spark-on-Yarn源码解析(二)Spark-Submit解析","published":1,"updated":"2018-09-04T10:13:14.301Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloj0lm50031ykpbixeqhdpc"},{"title":"Spark-on-Yarn源码解析(四)Spark业务代码的执行及其任务分配调度stage划分","date":"2018-09-04T08:16:39.931Z","toc":true,"_content":"\nspark-on-yarn系列\n[Spark-on-Yarn 源码解析 (一)Yarn 任务解析](\"http://www.gangtieguo.cn/2018/09/04/Spark-on-Yarn源码解析(一)Yarn任务解析/\")\n[Spark-on-Yarn 源码解析 (二)Spark-Submit 解析](\"http://www.gangtieguo.cn/2018/09/04/Spark-on-Yarn源码解析(二)Spark-Submit解析/\")\n[Spark-on-Yarn 源码解析 (三)client 做的事情](\"http://www.gangtieguo.cn/2018/09/04/Spark-on-Yarn源码解析(三)client做的事情/\")\n[Spark-on-Yarn 源码解析 (四)Spark 业务代码的执行及其任务分配调度 stage 划分](\"http://www.gangtieguo.cn/2018/09/04/Spark-on-Yarn源码解析(四)Spark业务代码的执行及其任务分配调度stage划分/\")\n\n\n# 看看自定义的类\n\n```scala\nobject WordCount {\n\n  def main(args: Array[String]): Unit = {\n    val conf = new SparkConf().setAppName(\"yaoWordCount\").setMaster(\"local[2]\")\n    val sc = new SparkContext(conf)\n    var hadoopRDD: RDD[String] = sc.textFile(args(0))\n    var hdfsRDD: RDD[String] = hadoopRDD.flatMap(_.split(\"\"))\n    //单词和出现的次数，构建RDD并且调用了他的Transformation\n    //返回的是一个hadoopRDD\n    //transFormation都是返回的RDD\n    var wordAndCount: RDD[(String, Int)] = hdfsRDD.map((_, 1))\n    //创建RDD 这里面有两个RDD,一个是hadoopRDD，然后会生成一个paritionRDD\n    //savaasTextfile还会产生一个RDD,因为会调用mapPartitons\n    //调用RDD的action 开始真正提交任务\n    var reducedRDD: RDD[(String, Int)] = wordAndCount.reduceByKey(_ + _)\n    reducedRDD.saveAsTextFile(args(1))\n    //关闭saprkContext资源\n    sc.stop()\n  }\n}\n```\n<!--more-->\n# sparkContext的初始化\n\n对于Spark程序入口为SparkContext,当我们使用spark-submit/spark-shell等命令来启动一个客户端,客户端与集群需要建立链接，建立的这个链接对象就叫做sparkContext，只有这个对象创建成功才标志这这个客户端与spark集群链接成功。现就将从SparkContext展开来描述一下Spark的任务启动和执行流程。\nSparkContext 完成了以下几个主要的功能： \n（1）创建 RDD，通过类似 textFile 等的方法。 \n（2）与资源管理器交互，通过 runJob 等方法启动应用。 \n（3）创建 DAGScheduler、TaskScheduler 等。 \n\n在SparkContext类中，SparkContext主构造器主要做\n\n我们看一下SparkContext的主构造器\n\n- 调用CreateSparkEnv方法创建SparkEnv(将driver的信息，url，ip等都封装)，SparkEnv中有一个对象ActorSystem\n- 创建TaskScheduler ，根据提交任务的URL（如：spark://(.*)\"，local[1]等，去创建TaskSchedulerImpl ，然后再创建SparkDeploySchedulerBackend(先后创建driverActor和clientActor)\n- 创建DAGScheduler\n- TaskScheduler启动，TaskScheduler.start()\n\n\n\n\n\n## SparkEnv\n\n最终将driver的host,port端口等各种信息都封装到里面\n\n```scala\nnew SparkEnv(\n  executorId,\n  actorSystem,\n  serializer,\n  closureSerializer,\n  cacheManager,\n  mapOutputTracker,\n  shuffleManager,\n  broadcastManager,\n  blockTransferService,\n  blockManager,\n  securityManager,\n  httpFileServer,\n  sparkFilesDir,\n  metricsSystem,\n  shuffleMemoryManager,\n  outputCommitCoordinator,\n  conf)\n```\n\n\n\n## TaskScheduler\n\n在SparkContext类中可以看到，TaskScheduler根据url类型匹配创建TaskSchedulerImpl\n\n```scala\n //TODO 根据提交任务时指定的URL创建相应的TaskScheduler\n  private def createTaskScheduler(\n      sc: SparkContext,\n      master: String): (SchedulerBackend, TaskScheduler) = {\n      ...\n      case \"yarn-standalone\" | \"yarn-cluster\" =>\n...\n        val scheduler = try {\n          val clazz = Class.forName(\"org.apache.spark.scheduler.cluster.YarnClusterScheduler\")\n          val cons = clazz.getConstructor(classOf[SparkContext])\n          cons.newInstance(sc).asInstanceOf[TaskSchedulerImpl]\n          }\n      ...\n        val backend = try {\n          val clazz =\n            Class.forName(\"org.apache.spark.scheduler.cluster.YarnClusterSchedulerBackend\")\n          val cons = clazz.getConstructor(classOf[TaskSchedulerImpl], classOf[SparkContext])\n          cons.newInstance(scheduler, sc).asInstanceOf[CoarseGrainedSchedulerBackend]\n        } \n        scheduler.initialize(backend)\n        (backend, scheduler)\n        ....\n        }\n```\n<!--more-->\n可知\nTaskScheduler 的实现类`org.apache.spark.scheduler.cluster.YarnScheduler`\nTaskSchedulerBacked 的实现类为`org.apache.spark.scheduler.cluster.YarnClientSchedulerBackend`\n且TaskScheduler对TaskSchedulerBacked保持了引用\nscheduler.initialize(backend)\n\n### 启动TaskScheduler\n\n在Spark的构造函数中,会启动TaskScheduler\n\n```scala\ntaskScheduler.start()\n```\n\n可以看到继承关系\n\n```scala\nprivate[spark] class YarnClusterScheduler(sc: SparkContext) extends YarnScheduler(sc) \nprivate[spark] class YarnScheduler(sc: SparkContext) extends TaskSchedulerImpl(sc)\n```\n\n可以跟踪到，start方法最终调用的是TaskSchedulerImpl里面start方法，在start方法里面\n\n```scala\n override def start() {\n    //TODO 首先调用SparkDeploySchedulerBackend的start方法\n    backend.start()\n    ......\n}\n```\n\n,这里的backend就是YarnClusterSchedulerBackend，而这个最终继承的是CoarseGrainedSchedulerBackend中start方法\n\n```scala\n  override def start() {\n  ...\n    driverActor = actorSystem.actorOf(\n      Props(new DriverActor(properties)), name = CoarseGrainedSchedulerBackend.ACTOR_NAME)\n  }\n```\n\n获取到spark的配置信息后，会创建driverActor\n\n## DAGScheduler\n\n在SparkContext的构造函数中，会创建DAGScheduler\n\n```scala\n    dagScheduler= new DAGScheduler(this)\n```\n\n在DAGScheduler构造函数中\n\n```scala\n def this(sc: SparkContext) = this(sc, sc.taskScheduler)\n```\n\n可以看到DAGScheduler对TaskScheduler保持了引用\n\n```scala\nclass DAGScheduler(\n    private[scheduler] val sc: SparkContext,\n    private[scheduler] val taskScheduler: TaskScheduler,\n    listenerBus: LiveListenerBus,\n    mapOutputTracker: MapOutputTrackerMaster,\n    blockManagerMaster: BlockManagerMaster,\n    env: SparkEnv,\n    clock: Clock = new SystemClock())\n  extends Logging {\n  ......\n  }\n```\n\n- mapOutputTracker：是运行在 Driver 端管理 shuffle 的中间输出位置信息的。 \n- blockManagerMaster：也是运行在 Driver 端的，它是管理整个 Job 的 Bolck 信息。\n\n# RDD的构建过程\n\n其中hadoopRDD，hdfsRDD，wordRDD，reduceRDD是经过一系列transformation装换rdd，只有等到action时，才会触发数据的流转\n\n该例的action为saveAsTextFile调用链为\n\n```\n   saveAsTextFile()\n       saveAsHadoopFile()\n            saveAsHadoopFile（重载函数）\n                    saveAsHadoopDataset()\n                        runJob()之间会调用几个重载函数\n                        dagScheduler.runJob()最终调用\n```\n\n# 作业提交\n\n# 任务流转\n\n首先注意区分 2 个概述： \njob: 每个 action 都是执行 runJob 方法，可以将之视为一个 job。 \nstage：在这个 job 内部，会根据宽依赖，划分成多个 stage。\n\n在action触发后，最最终调用的是DAGScheduler.runJob()\n\n```scala\ndagScheduler.runJob(rdd, cleanedFunc, partitions, callSite, resultHandler, localProperties.get)\n```\n\n而runJob() 的核心代码为：\n\n```scala\nval waiter = submitJob(rdd, func, partitions, callSite, resultHandler, properties)\n```\n\n即调用 submitJob 方法，我们进一步看看 submitJob()\n\n```scala\n  def submitJob[T, U](\n      rdd: RDD[T],\n      func: (TaskContext, Iterator[T]) => U,\n      partitions: Seq[Int],\n      callSite: CallSite,\n      resultHandler: (Int, U) => Unit,\n      properties: Properties): JobWaiter[U] = {\n....    \n    val jobId = nextJobId.getAndIncrement()\n.....\n\n    val waiter = new JobWaiter(this, jobId, partitions.size, resultHandler)\n    eventProcessLoop.post(JobSubmitted(\n      jobId, rdd, func2, partitions.toArray, callSite, waiter,\n      SerializationUtils.clone(properties)))\n    waiter\n  } \n```\n\nsubmitJob() 方法主要完成了以下 3 个工作： \n\n- 获取一个新的 jobId \n- 生成一个 JobWaiter，它会监听 Job 的执行状态，而 Job 是由多个 Task 组成的，因此只有当 Job 的所有 Task 均已完成，Job 才会标记成功 \n- 最后调用 eventProcessLoop.post() 将 Job 提交到一个队列中，等待处理。这是一个典型的生产者消费者模式。这些消息都是通过 handleJobSubmitted 来处理。\n\n简单看一下 handleJobSubmitted 是如何被调用的。 \n首先是 DAGSchedulerEventProcessLoop#onReceive 调用 \n\n```scala\n  //TODO 通过模式匹配判断事件的类型 比如任务提交，作业取消 ...\n  override def onReceive(event: DAGSchedulerEvent): Unit = event match {\n      //TODO 提交计算任务\n    case JobSubmitted(jobId, rdd, func, partitions, allowLocal, callSite, listener, properties) =>\n      //todo 调用dagScheduler的handlerJobSubmitted方法处理\n      dagScheduler.handleJobSubmitted(jobId, rdd, func, partitions, allowLocal, callSite,  listener, properties)\n    ... ...   \n```\n\nDAGSchedulerEventProcessLoop 是 EventLoop 的子类，它重写了 EventLoop 的 onReceive 方法。以后再分析这个 EventLoop。\nonReceive 会调用 handleJobSubmitted。\n\n## stage 的划分\n\n刚才说到 handleJobSubmitted 会从 eventProcessLoop 中取出 Job 来进行处理，处理的第一步就是将 Job 划分成不同的 stage。handleJobSubmitted 主要 2 个工作，一是进行 stage 的划分，这是这部分要介绍的内容；二是创建一个 activeJob，并生成一个任务，这在下一小节介绍。\n\n还是先看看调用链\n\n```\n   handleJobSubmitted\n       ->newStage()\n         ->getParentStages()//此处会遍历RDD所有依赖\n            ->getShuffleMapStage()//如果是ShuffleDependency（宽依赖，获取到一个Map）\n                ->newOrUsedStage()//这就可以解释我们常说的遇到宽依赖就会划分stage，并且返回stage                \n```\n\n所以最终返回的是一个拥有款依赖的           \n\n```scala\n  private[scheduler] def handleJobSubmitted(jobId: Int,\n      finalRDD: RDD[_],\n      func: (TaskContext, Iterator[_]) => _,\n      partitions: Array[Int],\n      callSite: CallSite,\n      listener: JobListener,\n      properties: Properties) {\n      ...\n      //todo 重要：该方法用于划分stage，主要依赖的是finalStage\n       finalStage = newStage(finalRDD, partitions.size, None, jobId, callSite)\n      .....\n    //TODO 集群模式\n      activeJobs += job\n      ......\n    //todo 提交stage\n      submitStage(finalStage)\n    }\n    //TODO  开始向集群提交还在等待的stage\n    submitWaitingStages()\n  }\n```\n\ngetParentStages()。 \n因为是从最终的 stage 往回推算的，这需要计算最终 stage 所依赖的各个 stage。\n\n```scala\n //TODO 用于获取父stage\n  private def getParentStages(rdd: RDD[_], jobId: Int): List[Stage] = {\n    val parents = new HashSet[Stage]\n    val waitingForVisit = new Stack[RDD[_]]\n    def visit(r: RDD[_]) {\n      if (!visited(r)) {\n        visited + r\n        for (dep <- r.dependencies) {\n          dep match {\n            case shufDep: ShuffleDependency[_, _, _] =>\n              //TODO 把宽依赖传进去，获得父stage\n              parents += getShuffleMapStage(shufDep, jobId)\n            case _ =>\n              waitingForVisit.push(dep.rdd)\n          }\n        }\n      }\n    }\n    waitingForVisit.push(rdd)\n    while (!waitingForVisit.isEmpty) {\n      visit(waitingForVisit.pop())\n    }\n    parents.toList\n  }\n```\n\n## 任务的生成\n\n回到 handleJobSubmitted 中的代码：\n\n```\nsubmitStage(finalStage)\n```\n\nsubmitStage 会提交 finalStage，如果这个 stage 的某些 parentStage 未提交，则递归调用 submitStage()，直至所有的 stage 均已计算完成。\n\nsubmitStage() 会调用 submitMissingTasks():\n\nsubmitMissingTasks(stage, jobId.get)\n\n而 submitMissingTasks() 会完成 DAGScheduler 最后的工作：它判断出哪些 Partition 需要计算，为每个 Partition 生成 Task，然后这些 Task 就会封闭到 TaskSet\n\n```scala\n //TODO  DAG提交stage  根据最后一个stage  开始找到第一个stage递归提交stage\n  /** Submits stage, but first recursively submits any missing parents. */\n  private def submitStage(stage: Stage) {\n    val jobId = activeJobForStage(stage)\n    if (jobId.isDefined) {\n      \n      if (!waitingStages(stage) && !runningStages(stage) && !failedStages(stage)) {\n        //TODO 获取他的父stage 没有提交的stage\n        val missing = getMissingParentStages(stage).sortBy(_.id)\n        //todo 判断父stage是否为空，为空就以为着他是第一stage\n        if (missing == Nil) {\n       //TODO 开始提交最前面的stage, DAG提交stage给TaskScheduler 会将stage转换成taskSet\n          submitMissingTasks(stage, jobId.get)\n        } else {\n          //TODO 有父stage  就递归提交\n          for (parent <- missing) {\n            submitStage(parent)\n          }\n          waitingStages += stage\n        }\n      }\n    } else {\n      abortStage(stage, \"No active job for stage \" + stage.id)\n    }\n  }\n\n```\n\nsubmitMissingTasks在最后提交给 TaskScheduler 进行处理\n\n```scala\n  //TODO  DAG提交stage给TaskScheduler 会将stage转换成taskSet\n  private def submitMissingTasks(stage: Stage, jobId: Int) {\n...\n//TODO 创建多少个Task\n\n    val tasks: Seq[Task[_]] = if (stage.isShuffleMap) {\n      partitionsToCompute.map { id =>\n        //TODO 数据存储的最佳位置   移动计算，而不是移动数据\n        val locs = getPreferredLocs(stage.rdd, id)\n        val part = stage.rdd.partitions(id)\n        //TODO 从上游拉取数据\n        new ShuffleMapTask(stage.id, taskBinary, part, locs)\n      }\n    } else {\n      val job = stage.resultOfJob.get\n      partitionsToCompute.map { id =>\n        val p: Int = job.partitions(id)\n        val part = stage.rdd.partitions(p)\n        val locs = getPreferredLocs(stage.rdd, p)\n        //TODO  将数据写入某个介质里面，nosql hdfs 等等\n        new ResultTask(stage.id, taskBinary, part, locs, id)\n      }\n    }\n\n//TODO task的数量最好和分区数一样  如果分区数大于0\n //TODO task的数量最好和分区数一样  如果分区数大于0\n    if (tasks.size > 0) {\n      logInfo(\"Submitting \" + tasks.size + \" missing tasks from \" + stage + \" (\" + stage.rdd + \")\")\n      stage.pendingTasks ++= tasks\n\n      //TODO 调用taskScheduler的submitTasks提交taskSet 现在将task转换成一个array\ntaskScheduler.submitTasks(new TaskSet(\n        tasks.toArray, stage.id, stage.latestInfo.attemptId, stage.firstJobId, properties))\n      stage.latestInfo.submissionTime = Some(clock.getTimeMillis())\n      .....\n}\n```\n\n## TaskScheduler && TaskSchedulerBackend\n\n上文分析到在 DAGScheduler 中最终会执行 taskScheduler.submitTasks() 方法，我们先简单看一下从这里开始往下的执行逻辑：\n\n```\n①taskScheduler.submitTasks()\n    ->②schedulableBuilder.addTaskSetManager() 调度模式，是先来先服务还是公平调度模式\n    ->③CoarseGrainedSchedulerBackend.reviveOffers() 这个是向driverActor发送消息driverActor ! ReviveOffers\n        ->④CoarseGrainedSchedulerBackend.receiveWithLogging 这是driverActor接收消息的部分\n            ->⑤CoarseGrainedSchedulerBackend.makeOffers() //case ReviveOffers =>makeOffers()\n        这个模式匹配会调用maksOffers方法\n                ->⑥launchTasks()调用launchTask向Executor提交task\n                    ->⑦ executorData.executorActor ! LaunchTask(new SerializableBuffer(serializedTask))向executor发送序列化好的task，发送一个Task\n```\n\n步骤一、二中主要将这组\n任务的 TaskSet 加入到一个 TaskSetManager 中。TaskSetManager 会根据数据就近原则为 task 分配计算资源，监控 task 的执行状态等，比如失败重试，推测执行等。 \n步骤三、四逻辑较为简单。 \n步骤五为每个 task 具体分配资源，它的输入是一个 Executor 的列表，输出是 TaskDescription 的二维数组。TaskDescription 包含了 TaskID, Executor ID 和 task 执行的依赖信息等。 \n步骤六、七就是将任务真正的发送到 executor 中执行了，并等待 executor 的状态返回。\n\n​                 \n\n","source":"_posts/Spark-on-Yarn源码解析(四)Spark业务代码的执行及其任务分配调度stage划分.md","raw":"---\ntitle: Spark-on-Yarn源码解析(四)Spark业务代码的执行及其任务分配调度stage划分\ndate: 2018年09月04日\ntags: [Spark,原理]\ncategories: Spark-On-Yarn\ntoc: true\n---\n\nspark-on-yarn系列\n[Spark-on-Yarn 源码解析 (一)Yarn 任务解析](\"http://www.gangtieguo.cn/2018/09/04/Spark-on-Yarn源码解析(一)Yarn任务解析/\")\n[Spark-on-Yarn 源码解析 (二)Spark-Submit 解析](\"http://www.gangtieguo.cn/2018/09/04/Spark-on-Yarn源码解析(二)Spark-Submit解析/\")\n[Spark-on-Yarn 源码解析 (三)client 做的事情](\"http://www.gangtieguo.cn/2018/09/04/Spark-on-Yarn源码解析(三)client做的事情/\")\n[Spark-on-Yarn 源码解析 (四)Spark 业务代码的执行及其任务分配调度 stage 划分](\"http://www.gangtieguo.cn/2018/09/04/Spark-on-Yarn源码解析(四)Spark业务代码的执行及其任务分配调度stage划分/\")\n\n\n# 看看自定义的类\n\n```scala\nobject WordCount {\n\n  def main(args: Array[String]): Unit = {\n    val conf = new SparkConf().setAppName(\"yaoWordCount\").setMaster(\"local[2]\")\n    val sc = new SparkContext(conf)\n    var hadoopRDD: RDD[String] = sc.textFile(args(0))\n    var hdfsRDD: RDD[String] = hadoopRDD.flatMap(_.split(\"\"))\n    //单词和出现的次数，构建RDD并且调用了他的Transformation\n    //返回的是一个hadoopRDD\n    //transFormation都是返回的RDD\n    var wordAndCount: RDD[(String, Int)] = hdfsRDD.map((_, 1))\n    //创建RDD 这里面有两个RDD,一个是hadoopRDD，然后会生成一个paritionRDD\n    //savaasTextfile还会产生一个RDD,因为会调用mapPartitons\n    //调用RDD的action 开始真正提交任务\n    var reducedRDD: RDD[(String, Int)] = wordAndCount.reduceByKey(_ + _)\n    reducedRDD.saveAsTextFile(args(1))\n    //关闭saprkContext资源\n    sc.stop()\n  }\n}\n```\n<!--more-->\n# sparkContext的初始化\n\n对于Spark程序入口为SparkContext,当我们使用spark-submit/spark-shell等命令来启动一个客户端,客户端与集群需要建立链接，建立的这个链接对象就叫做sparkContext，只有这个对象创建成功才标志这这个客户端与spark集群链接成功。现就将从SparkContext展开来描述一下Spark的任务启动和执行流程。\nSparkContext 完成了以下几个主要的功能： \n（1）创建 RDD，通过类似 textFile 等的方法。 \n（2）与资源管理器交互，通过 runJob 等方法启动应用。 \n（3）创建 DAGScheduler、TaskScheduler 等。 \n\n在SparkContext类中，SparkContext主构造器主要做\n\n我们看一下SparkContext的主构造器\n\n- 调用CreateSparkEnv方法创建SparkEnv(将driver的信息，url，ip等都封装)，SparkEnv中有一个对象ActorSystem\n- 创建TaskScheduler ，根据提交任务的URL（如：spark://(.*)\"，local[1]等，去创建TaskSchedulerImpl ，然后再创建SparkDeploySchedulerBackend(先后创建driverActor和clientActor)\n- 创建DAGScheduler\n- TaskScheduler启动，TaskScheduler.start()\n\n\n\n\n\n## SparkEnv\n\n最终将driver的host,port端口等各种信息都封装到里面\n\n```scala\nnew SparkEnv(\n  executorId,\n  actorSystem,\n  serializer,\n  closureSerializer,\n  cacheManager,\n  mapOutputTracker,\n  shuffleManager,\n  broadcastManager,\n  blockTransferService,\n  blockManager,\n  securityManager,\n  httpFileServer,\n  sparkFilesDir,\n  metricsSystem,\n  shuffleMemoryManager,\n  outputCommitCoordinator,\n  conf)\n```\n\n\n\n## TaskScheduler\n\n在SparkContext类中可以看到，TaskScheduler根据url类型匹配创建TaskSchedulerImpl\n\n```scala\n //TODO 根据提交任务时指定的URL创建相应的TaskScheduler\n  private def createTaskScheduler(\n      sc: SparkContext,\n      master: String): (SchedulerBackend, TaskScheduler) = {\n      ...\n      case \"yarn-standalone\" | \"yarn-cluster\" =>\n...\n        val scheduler = try {\n          val clazz = Class.forName(\"org.apache.spark.scheduler.cluster.YarnClusterScheduler\")\n          val cons = clazz.getConstructor(classOf[SparkContext])\n          cons.newInstance(sc).asInstanceOf[TaskSchedulerImpl]\n          }\n      ...\n        val backend = try {\n          val clazz =\n            Class.forName(\"org.apache.spark.scheduler.cluster.YarnClusterSchedulerBackend\")\n          val cons = clazz.getConstructor(classOf[TaskSchedulerImpl], classOf[SparkContext])\n          cons.newInstance(scheduler, sc).asInstanceOf[CoarseGrainedSchedulerBackend]\n        } \n        scheduler.initialize(backend)\n        (backend, scheduler)\n        ....\n        }\n```\n<!--more-->\n可知\nTaskScheduler 的实现类`org.apache.spark.scheduler.cluster.YarnScheduler`\nTaskSchedulerBacked 的实现类为`org.apache.spark.scheduler.cluster.YarnClientSchedulerBackend`\n且TaskScheduler对TaskSchedulerBacked保持了引用\nscheduler.initialize(backend)\n\n### 启动TaskScheduler\n\n在Spark的构造函数中,会启动TaskScheduler\n\n```scala\ntaskScheduler.start()\n```\n\n可以看到继承关系\n\n```scala\nprivate[spark] class YarnClusterScheduler(sc: SparkContext) extends YarnScheduler(sc) \nprivate[spark] class YarnScheduler(sc: SparkContext) extends TaskSchedulerImpl(sc)\n```\n\n可以跟踪到，start方法最终调用的是TaskSchedulerImpl里面start方法，在start方法里面\n\n```scala\n override def start() {\n    //TODO 首先调用SparkDeploySchedulerBackend的start方法\n    backend.start()\n    ......\n}\n```\n\n,这里的backend就是YarnClusterSchedulerBackend，而这个最终继承的是CoarseGrainedSchedulerBackend中start方法\n\n```scala\n  override def start() {\n  ...\n    driverActor = actorSystem.actorOf(\n      Props(new DriverActor(properties)), name = CoarseGrainedSchedulerBackend.ACTOR_NAME)\n  }\n```\n\n获取到spark的配置信息后，会创建driverActor\n\n## DAGScheduler\n\n在SparkContext的构造函数中，会创建DAGScheduler\n\n```scala\n    dagScheduler= new DAGScheduler(this)\n```\n\n在DAGScheduler构造函数中\n\n```scala\n def this(sc: SparkContext) = this(sc, sc.taskScheduler)\n```\n\n可以看到DAGScheduler对TaskScheduler保持了引用\n\n```scala\nclass DAGScheduler(\n    private[scheduler] val sc: SparkContext,\n    private[scheduler] val taskScheduler: TaskScheduler,\n    listenerBus: LiveListenerBus,\n    mapOutputTracker: MapOutputTrackerMaster,\n    blockManagerMaster: BlockManagerMaster,\n    env: SparkEnv,\n    clock: Clock = new SystemClock())\n  extends Logging {\n  ......\n  }\n```\n\n- mapOutputTracker：是运行在 Driver 端管理 shuffle 的中间输出位置信息的。 \n- blockManagerMaster：也是运行在 Driver 端的，它是管理整个 Job 的 Bolck 信息。\n\n# RDD的构建过程\n\n其中hadoopRDD，hdfsRDD，wordRDD，reduceRDD是经过一系列transformation装换rdd，只有等到action时，才会触发数据的流转\n\n该例的action为saveAsTextFile调用链为\n\n```\n   saveAsTextFile()\n       saveAsHadoopFile()\n            saveAsHadoopFile（重载函数）\n                    saveAsHadoopDataset()\n                        runJob()之间会调用几个重载函数\n                        dagScheduler.runJob()最终调用\n```\n\n# 作业提交\n\n# 任务流转\n\n首先注意区分 2 个概述： \njob: 每个 action 都是执行 runJob 方法，可以将之视为一个 job。 \nstage：在这个 job 内部，会根据宽依赖，划分成多个 stage。\n\n在action触发后，最最终调用的是DAGScheduler.runJob()\n\n```scala\ndagScheduler.runJob(rdd, cleanedFunc, partitions, callSite, resultHandler, localProperties.get)\n```\n\n而runJob() 的核心代码为：\n\n```scala\nval waiter = submitJob(rdd, func, partitions, callSite, resultHandler, properties)\n```\n\n即调用 submitJob 方法，我们进一步看看 submitJob()\n\n```scala\n  def submitJob[T, U](\n      rdd: RDD[T],\n      func: (TaskContext, Iterator[T]) => U,\n      partitions: Seq[Int],\n      callSite: CallSite,\n      resultHandler: (Int, U) => Unit,\n      properties: Properties): JobWaiter[U] = {\n....    \n    val jobId = nextJobId.getAndIncrement()\n.....\n\n    val waiter = new JobWaiter(this, jobId, partitions.size, resultHandler)\n    eventProcessLoop.post(JobSubmitted(\n      jobId, rdd, func2, partitions.toArray, callSite, waiter,\n      SerializationUtils.clone(properties)))\n    waiter\n  } \n```\n\nsubmitJob() 方法主要完成了以下 3 个工作： \n\n- 获取一个新的 jobId \n- 生成一个 JobWaiter，它会监听 Job 的执行状态，而 Job 是由多个 Task 组成的，因此只有当 Job 的所有 Task 均已完成，Job 才会标记成功 \n- 最后调用 eventProcessLoop.post() 将 Job 提交到一个队列中，等待处理。这是一个典型的生产者消费者模式。这些消息都是通过 handleJobSubmitted 来处理。\n\n简单看一下 handleJobSubmitted 是如何被调用的。 \n首先是 DAGSchedulerEventProcessLoop#onReceive 调用 \n\n```scala\n  //TODO 通过模式匹配判断事件的类型 比如任务提交，作业取消 ...\n  override def onReceive(event: DAGSchedulerEvent): Unit = event match {\n      //TODO 提交计算任务\n    case JobSubmitted(jobId, rdd, func, partitions, allowLocal, callSite, listener, properties) =>\n      //todo 调用dagScheduler的handlerJobSubmitted方法处理\n      dagScheduler.handleJobSubmitted(jobId, rdd, func, partitions, allowLocal, callSite,  listener, properties)\n    ... ...   \n```\n\nDAGSchedulerEventProcessLoop 是 EventLoop 的子类，它重写了 EventLoop 的 onReceive 方法。以后再分析这个 EventLoop。\nonReceive 会调用 handleJobSubmitted。\n\n## stage 的划分\n\n刚才说到 handleJobSubmitted 会从 eventProcessLoop 中取出 Job 来进行处理，处理的第一步就是将 Job 划分成不同的 stage。handleJobSubmitted 主要 2 个工作，一是进行 stage 的划分，这是这部分要介绍的内容；二是创建一个 activeJob，并生成一个任务，这在下一小节介绍。\n\n还是先看看调用链\n\n```\n   handleJobSubmitted\n       ->newStage()\n         ->getParentStages()//此处会遍历RDD所有依赖\n            ->getShuffleMapStage()//如果是ShuffleDependency（宽依赖，获取到一个Map）\n                ->newOrUsedStage()//这就可以解释我们常说的遇到宽依赖就会划分stage，并且返回stage                \n```\n\n所以最终返回的是一个拥有款依赖的           \n\n```scala\n  private[scheduler] def handleJobSubmitted(jobId: Int,\n      finalRDD: RDD[_],\n      func: (TaskContext, Iterator[_]) => _,\n      partitions: Array[Int],\n      callSite: CallSite,\n      listener: JobListener,\n      properties: Properties) {\n      ...\n      //todo 重要：该方法用于划分stage，主要依赖的是finalStage\n       finalStage = newStage(finalRDD, partitions.size, None, jobId, callSite)\n      .....\n    //TODO 集群模式\n      activeJobs += job\n      ......\n    //todo 提交stage\n      submitStage(finalStage)\n    }\n    //TODO  开始向集群提交还在等待的stage\n    submitWaitingStages()\n  }\n```\n\ngetParentStages()。 \n因为是从最终的 stage 往回推算的，这需要计算最终 stage 所依赖的各个 stage。\n\n```scala\n //TODO 用于获取父stage\n  private def getParentStages(rdd: RDD[_], jobId: Int): List[Stage] = {\n    val parents = new HashSet[Stage]\n    val waitingForVisit = new Stack[RDD[_]]\n    def visit(r: RDD[_]) {\n      if (!visited(r)) {\n        visited + r\n        for (dep <- r.dependencies) {\n          dep match {\n            case shufDep: ShuffleDependency[_, _, _] =>\n              //TODO 把宽依赖传进去，获得父stage\n              parents += getShuffleMapStage(shufDep, jobId)\n            case _ =>\n              waitingForVisit.push(dep.rdd)\n          }\n        }\n      }\n    }\n    waitingForVisit.push(rdd)\n    while (!waitingForVisit.isEmpty) {\n      visit(waitingForVisit.pop())\n    }\n    parents.toList\n  }\n```\n\n## 任务的生成\n\n回到 handleJobSubmitted 中的代码：\n\n```\nsubmitStage(finalStage)\n```\n\nsubmitStage 会提交 finalStage，如果这个 stage 的某些 parentStage 未提交，则递归调用 submitStage()，直至所有的 stage 均已计算完成。\n\nsubmitStage() 会调用 submitMissingTasks():\n\nsubmitMissingTasks(stage, jobId.get)\n\n而 submitMissingTasks() 会完成 DAGScheduler 最后的工作：它判断出哪些 Partition 需要计算，为每个 Partition 生成 Task，然后这些 Task 就会封闭到 TaskSet\n\n```scala\n //TODO  DAG提交stage  根据最后一个stage  开始找到第一个stage递归提交stage\n  /** Submits stage, but first recursively submits any missing parents. */\n  private def submitStage(stage: Stage) {\n    val jobId = activeJobForStage(stage)\n    if (jobId.isDefined) {\n      \n      if (!waitingStages(stage) && !runningStages(stage) && !failedStages(stage)) {\n        //TODO 获取他的父stage 没有提交的stage\n        val missing = getMissingParentStages(stage).sortBy(_.id)\n        //todo 判断父stage是否为空，为空就以为着他是第一stage\n        if (missing == Nil) {\n       //TODO 开始提交最前面的stage, DAG提交stage给TaskScheduler 会将stage转换成taskSet\n          submitMissingTasks(stage, jobId.get)\n        } else {\n          //TODO 有父stage  就递归提交\n          for (parent <- missing) {\n            submitStage(parent)\n          }\n          waitingStages += stage\n        }\n      }\n    } else {\n      abortStage(stage, \"No active job for stage \" + stage.id)\n    }\n  }\n\n```\n\nsubmitMissingTasks在最后提交给 TaskScheduler 进行处理\n\n```scala\n  //TODO  DAG提交stage给TaskScheduler 会将stage转换成taskSet\n  private def submitMissingTasks(stage: Stage, jobId: Int) {\n...\n//TODO 创建多少个Task\n\n    val tasks: Seq[Task[_]] = if (stage.isShuffleMap) {\n      partitionsToCompute.map { id =>\n        //TODO 数据存储的最佳位置   移动计算，而不是移动数据\n        val locs = getPreferredLocs(stage.rdd, id)\n        val part = stage.rdd.partitions(id)\n        //TODO 从上游拉取数据\n        new ShuffleMapTask(stage.id, taskBinary, part, locs)\n      }\n    } else {\n      val job = stage.resultOfJob.get\n      partitionsToCompute.map { id =>\n        val p: Int = job.partitions(id)\n        val part = stage.rdd.partitions(p)\n        val locs = getPreferredLocs(stage.rdd, p)\n        //TODO  将数据写入某个介质里面，nosql hdfs 等等\n        new ResultTask(stage.id, taskBinary, part, locs, id)\n      }\n    }\n\n//TODO task的数量最好和分区数一样  如果分区数大于0\n //TODO task的数量最好和分区数一样  如果分区数大于0\n    if (tasks.size > 0) {\n      logInfo(\"Submitting \" + tasks.size + \" missing tasks from \" + stage + \" (\" + stage.rdd + \")\")\n      stage.pendingTasks ++= tasks\n\n      //TODO 调用taskScheduler的submitTasks提交taskSet 现在将task转换成一个array\ntaskScheduler.submitTasks(new TaskSet(\n        tasks.toArray, stage.id, stage.latestInfo.attemptId, stage.firstJobId, properties))\n      stage.latestInfo.submissionTime = Some(clock.getTimeMillis())\n      .....\n}\n```\n\n## TaskScheduler && TaskSchedulerBackend\n\n上文分析到在 DAGScheduler 中最终会执行 taskScheduler.submitTasks() 方法，我们先简单看一下从这里开始往下的执行逻辑：\n\n```\n①taskScheduler.submitTasks()\n    ->②schedulableBuilder.addTaskSetManager() 调度模式，是先来先服务还是公平调度模式\n    ->③CoarseGrainedSchedulerBackend.reviveOffers() 这个是向driverActor发送消息driverActor ! ReviveOffers\n        ->④CoarseGrainedSchedulerBackend.receiveWithLogging 这是driverActor接收消息的部分\n            ->⑤CoarseGrainedSchedulerBackend.makeOffers() //case ReviveOffers =>makeOffers()\n        这个模式匹配会调用maksOffers方法\n                ->⑥launchTasks()调用launchTask向Executor提交task\n                    ->⑦ executorData.executorActor ! LaunchTask(new SerializableBuffer(serializedTask))向executor发送序列化好的task，发送一个Task\n```\n\n步骤一、二中主要将这组\n任务的 TaskSet 加入到一个 TaskSetManager 中。TaskSetManager 会根据数据就近原则为 task 分配计算资源，监控 task 的执行状态等，比如失败重试，推测执行等。 \n步骤三、四逻辑较为简单。 \n步骤五为每个 task 具体分配资源，它的输入是一个 Executor 的列表，输出是 TaskDescription 的二维数组。TaskDescription 包含了 TaskID, Executor ID 和 task 执行的依赖信息等。 \n步骤六、七就是将任务真正的发送到 executor 中执行了，并等待 executor 的状态返回。\n\n​                 \n\n","slug":"Spark-on-Yarn源码解析(四)Spark业务代码的执行及其任务分配调度stage划分","published":1,"updated":"2018-09-04T10:16:15.370Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloj0lm60035ykpbeg9vge1b"},{"title":"SparkSQL介绍","date":"2018-08-15T18:04:32.317Z","toc":true,"_content":"\n[TOC]\n\nHive，它是将Hive SQL转换成MapReduce然后提交到集群上执行，大大简化了编写MapReduce的程序的复杂性，由于MapReduce这种计算模型执行效率比较慢。所有Spark SQL的应运而生，它是将Spark SQL转换成RDD，然后提交到集群执行，执行效率非常快！\n\n<!-- more -->\n\n> 需要将hive-site.xml拷到spark的配置文件夹\n\n#### hive只认latin1编码\n\nlinux下的mysql编码是latin1 \nwindows下的也设置成latin1.如果要和hive搭配使用的话\n\n#### 进入sparksql和hive连接的命令\n\n```bash\n/home/bigdata/apps/spark/bin/spark-sql --master spark://bigdata1:7077 --driver-class-path /home/bigdata/apps/hive/lib/mysql-connector-java-5.1.31-bin.jar\n```\n\n需要注意的是，需要是集群模式，--master 等等，还要指定一个jdbc的连接驱动 \nsparksql也会走hive的元数据库\n\n**hive语法**在spark-sql下 \n\n```bash\n'>create table person(id bigint,name string,age int) row format delimited fields terminated by ',';\n```\n\n在hive下： \n\n```bash\nload data inpath \"hdfs://master:9000/person.txt\" into table person;\n```\n\n","source":"_posts/SparkSQL介绍.md","raw":"---\ntitle: SparkSQL介绍\ndate: 2018年08月06日 22时15分52秒\ntags: [Spark,SparkSQL]\ncategories: 大数据\ntoc: true\n---\n\n[TOC]\n\nHive，它是将Hive SQL转换成MapReduce然后提交到集群上执行，大大简化了编写MapReduce的程序的复杂性，由于MapReduce这种计算模型执行效率比较慢。所有Spark SQL的应运而生，它是将Spark SQL转换成RDD，然后提交到集群执行，执行效率非常快！\n\n<!-- more -->\n\n> 需要将hive-site.xml拷到spark的配置文件夹\n\n#### hive只认latin1编码\n\nlinux下的mysql编码是latin1 \nwindows下的也设置成latin1.如果要和hive搭配使用的话\n\n#### 进入sparksql和hive连接的命令\n\n```bash\n/home/bigdata/apps/spark/bin/spark-sql --master spark://bigdata1:7077 --driver-class-path /home/bigdata/apps/hive/lib/mysql-connector-java-5.1.31-bin.jar\n```\n\n需要注意的是，需要是集群模式，--master 等等，还要指定一个jdbc的连接驱动 \nsparksql也会走hive的元数据库\n\n**hive语法**在spark-sql下 \n\n```bash\n'>create table person(id bigint,name string,age int) row format delimited fields terminated by ',';\n```\n\n在hive下： \n\n```bash\nload data inpath \"hdfs://master:9000/person.txt\" into table person;\n```\n\n","slug":"SparkSQL介绍","published":1,"updated":"2018-08-20T01:38:13.848Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloj0lm80039ykpburkj5bss"},{"title":"SparkRDD介绍","date":"2018-08-15T16:49:49.734Z","toc":true,"_content":"\n[TOC]\n\n```scala\nsc.textfile(\"hdfs://master:9000/wc\").flatMap(_.split(\"分隔符\")).map((_,1)).reduceByKey(_+_).saveAsTextFile(\"hdfs://master:9000/wcResult\")\n```\n\n<!-- more -->\n\n当rdd形成过程中，worker的分区中只是预留了存放数据的位置，只有当action触发的时候，worker的分区中才会存在数据，sparkSubmit submit的命令行默认的是driver ，RDD的创建都是在在driver上创建的 \n\n\n\n\n\n# spark的分区与hdfs数据块的关系\n\nPartitioner函数不但决定了RDD本身的分片数量，也决定了parent RDD Shuffle输出时的分片数量。\n\n# SparkRDD\n\nRDD（ResilientDistributed Dataset）叫做分布式数据集，是Spark中最基本的数据抽象，它代表一个不可变、可分区、里面的元素可并行计算的集合。RDD具有数据流模型的特点：自动容错、位置感知性调度和可伸缩性。RDD允许用户在执行多个查询时显式地将工作集缓存在内存中，后续的查询能够重用工作集，这极大地提升了查询速度。\n\n![](https://ws1.sinaimg.cn/large/0069RVTdgy1fuawo5mvk1j31c20bq3zz.jpg)\n\n1）一组分片（Partition），即数据集的基本组成单位。对于RDD来说，每个分片都会被一个计算任务处理，并决定并行计算的粒度。用户可以在创建RDD时指定RDD的分片个数，如果没有指定，那么就会采用默认值。默认值就是程序所分配到的CPU Core的数目。\n\n2）一个计算每个分区的函数。Spark中RDD的计算是以分片为单位的，每个RDD都会实现compute函数以达到这个目的。compute函数会对迭代器进行复合，不需要保存每次计算的结果。\n\n3）RDD之间的依赖关系。RDD的每次转换都会生成一个新的RDD，所以RDD之间就会形成类似于流水线一样的前后依赖关系。在部分分区数据丢失时，Spark可以通过这个依赖关系重新计算丢失的分区数据，而不是对RDD的所有分区进行重新计算。\n\n 4）一个Partitioner，即RDD的分片函数。当前Spark中实现了两种类型的分片函数，一个是基于哈希的HashPartitioner，另外一个是基于范围的RangePartitioner。只有对于于key-value的RDD，才会有Partitioner，非key-value的RDD的Parititioner的值是None。Partitioner函数不但决定了RDD本身的分片数量，也决定了parent RDD Shuffle输出时的分片数量。\n\n 5）一个列表，存储存取每个Partition的优先位置（preferredlocation）。对于一个HDFS文件来说，**这个列表保存的就是每个****Partition所在的块的位置**。按照“移动数据不如移动计算”的理念，Spark在进行任务调度的时候，会尽可能地将计算任务分配到其所要处理数据块的存储位置。 血缘依赖\n\nRDD 5个特性 \n一个function作用一个partition \n如果是key-value格式的有一个默认的partitioner 默认是hashpartitioner \n如果是从hdfs这种文件系统类型读取的数据，会有一个prefered location，因为在大数据领域宁愿移动计算，也不愿移动数据，通常叫做数据本地化， \n\n# RDD数据读取\n\nrdd向hdfs中读取数据是一行一行读取放在迭代器里面，而不是一下子全部读取数据\n\nrdd向hdfs中读取数据，hdfs文件有几个数据块就会创建几个分区 \n\n读取数据还是用的hadoop的inputFormat来读取的\n\n# RDD的生成方式\n\n\n\n## RDD算子\n\n### Transformation\n\nRDD中的所有转换都是延迟加载的，也就是说，它们并不会直接计算结果。相反的，它们只是记住这些应用到基础数据集（例如一个文件）上的转换动作。只有当发生一个要求返回结果给Driver的动作时，这些转换才会真正运行。这种设计让Spark更加有效率地运行。\n\n常用的Transformation：\n\n| **转换**                                   | **含义**                                   |\n| ---------------------------------------- | ---------------------------------------- |\n| **map**(func)                            | 返回一个新的RDD，该RDD由每一个输入元素经过func函数转换后组成      |\n| **filter**(func)                         | 返回一个新的RDD，该RDD由经过func函数计算后返回值为true的输入元素组成 |\n| **flatMap**(func)                        | 类似于map，但是每一个输入元素可以被映射为0或多个输出元素（所以func应该返回一个序列，而不是单一元素） |\n| **mapPartitions**(func)                  | 类似于map，但独立地在RDD的每一个分片上运行，因此在类型为T的RDD上运行时，func的函数类型必须是Iterator[T] => Iterator[U] |\n| **mapPartitionsWithIndex**(func)         | 类似于mapPartitions，但func带有一个整数参数表示分片的索引值，因此在类型为T的RDD上运行时，func的函数类型必须是  (Int,  Interator[T]) => Iterator[U] |\n| **sample**(withReplacement, fraction, seed) | 根据fraction指定的比例对数据进行采样，可以选择是否使用随机数进行替换，seed用于指定随机数生成器种子 |\n| **union**(otherDataset)                  | 对源RDD和参数RDD求并集后返回一个新的RDD                 |\n| **intersection**(otherDataset)           | 对源RDD和参数RDD求交集后返回一个新的RDD                 |\n| **distinct**([numTasks]))                | 对源RDD进行去重后返回一个新的RDD                      |\n| **groupByKey**([numTasks])               | 在一个(K,V)的RDD上调用，返回一个(K, Iterator[V])的RDD |\n| **reduceByKey**(func, [numTasks])        | 在一个(K,V)的RDD上调用，返回一个(K,V)的RDD，使用指定的reduce函数，将相同key的值聚合到一起，与groupByKey类似，reduce任务的个数可以通过第二个可选的参数来设置 |\n| **aggregateByKey**(zeroValue)(seqOp, combOp, [numTasks]) |                                          |\n| **sortByKey**([ascending], [numTasks])   | 在一个(K,V)的RDD上调用，K必须实现Ordered接口，返回一个按照key进行排序的(K,V)的RDD |\n| **sortBy**(func,[ascending], [numTasks]) | 与sortByKey类似，但是更灵活                       |\n| **join**(otherDataset, [numTasks])       | 在类型为(K,V)和(K,W)的RDD上调用，返回一个相同key对应的所有元素对在一起的(K,(V,W))的RDD |\n| **cogroup**(otherDataset, [numTasks])    | 在类型为(K,V)和(K,W)的RDD上调用，返回一个(K,(Iterable<V>,Iterable<W>))类型的RDD |\n| **cartesian**(otherDataset)              | 笛卡尔积                                     |\n| **pipe**(command, [envVars])             |                                          |\n| **coalesce**(numPartitions**)   **       |                                          |\n| **repartition**(numPartitions)           |                                          |\n| **repartitionAndSortWithinPartitions**(partitioner) |                                          |\n\n### Action\n\n| **动作**                                   | **含义**                                   |\n| ---------------------------------------- | ---------------------------------------- |\n| **reduce**(*func*)                       | 通过func函数聚集RDD中的所有元素，这个功能必须是可交换且可并联的      |\n| **collect**()                            | 在驱动程序中，以数组的形式返回数据集的所有元素                  |\n| **count**()                              | 返回RDD的元素个数                               |\n| **first**()                              | 返回RDD的第一个元素（类似于take(1)）                  |\n| **take**(*n*)                            | 返回一个由数据集的前n个元素组成的数组                      |\n| **takeSample**(*withReplacement*,*num*, [*seed*]) | 返回一个数组，该数组由从数据集中随机采样的num个元素组成，可以选择是否用随机数替换不足的部分，seed用于指定随机数生成器种子 |\n| **takeOrdered**(*n*, *[ordering]*)       |                                          |\n| **saveAsTextFile**(*path*)               | 将数据集的元素以textfile的形式保存到HDFS文件系统或者其他支持的文件系统，对于每个元素，Spark将会调用toString方法，将它装换为文件中的文本 |\n| **saveAsSequenceFile**(*path*)           | 将数据集中的元素以Hadoop sequencefile的格式保存到指定的目录下，可以使HDFS或者其他Hadoop支持的文件系统。 |\n| **saveAsObjectFile**(*path*)             |                                          |\n| **countByKey**()                         | 针对(K,V)类型的RDD，返回一个(K,Int)的map，表示每一个key对应的元素个数。 |\n\n\n\n# 宽依赖窄依赖区分\n\n![](https://ws3.sinaimg.cn/large/006tNbRwly1fuhtdoo3nvj30gf087jrt.jpg)\n\n## 窄依赖 narrow dependencies\n\n三个小分块是RDD的分区，组合起来的大框是RDD，后面的是子rdd的分区，一个父rdd的分区只对应一个子rdd的分区（类比独生子女） ，一个子可以对应多个父分区（可以类比父母分区）\n\n如map，filter，union等算子都是操作的原来分区里面的数据,操作之后也在原来的分区 \njoin大多数情况下是宽依赖，在一种特殊情况下是窄依赖 (join是针对key value形式的rdd，相同key的会join在一起)\n\n## 宽依赖 wide dependencies\n\n父rdd一个分区会流向多个子rdd的分区类比多子女情况\n\ngroupBy ，reduceByKey ，join等\n\n下图b到g不是一个stage是因为，提前已经分好组，所以是窄依赖，没有stage \n![](https://ws3.sinaimg.cn/large/006tNbRwly1fuhu3makagj30af05rmxa.jpg)\n\n### Lineage\n\nRDD只支持粗粒度转换，即在大量记录上执行的单个操作。将创建RDD的一系列Lineage（即血统）记录下来，以便恢复丢失的分区。RDD的Lineage会记录RDD的元数据信息和转换行为，当该RDD的部分分区数据丢失时，它可以根据这些信息来重新运算和恢复丢失的数据分区。\n\n\n\n##  RDD的缓存\n\nSpark速度非常快的原因之一，就是在不同操作中可以在内存中持久化或缓存个数据集。当持久化某个RDD后，每一个节点都将把计算的分片结果保存在内存中，并在对此RDD或衍生出的RDD进行的其他动作中重用。这使得后续的动作变得更加迅速。RDD相关的持久化和缓存，是Spark最重要的特征之一。可以说，缓存是Spark构建迭代式算法和快速交互式查询的关键。\n\n### 缓存方式\n\nRDD通过persist方法或cache方法可以将前面的计算结果缓存，但是并不是这两个方法被调用时立即缓存，而是触发后面的action时，该RDD将会被缓存在计算节点的内存中，并供后面重用。\n\n\n\n通过查看源码发现cache最终也是调用了persist方法，默认的存储级别都是仅在内存存储一份，Spark的存储级别还有好多种，存储级别在object StorageLevel中定义的。\n\n缓存有可能丢失，或者存储存储于内存的数据由于内存不足而被删除，RDD的缓存容错机制保证了即使缓存丢失也能保证计算的正确执行。通过基于RDD的一系列转换，丢失的数据会被重算，由于RDD的各个Partition是相对独立的，因此只需要计算丢失的部分即可，并不需要重算全部Partition。\n\n\n\n\n\n\n\n# RDD缓存\n\nval rdd = sc.textFile(\"hdfs:hadoop1:9000/yao\").cache(); \ncache是trancsformation也是懒加载，遇到action 如count.collect才会，缓存到内存里面,而不是文件系统中读取 \ncache()调用的persist()\n\nrdd.unpersist() 就会将内存中的缓存释放掉 \nrdd.unpersist(true)\n\n\n\n# CheckPoint的背景\n\ncheckpoint属于transaction\n\n云计算一边要将中间结果进行产生多个RDD和多次运算，特别是机器学习，需要中间结果计算很多很多次迭代，有可能上百次 \n这样就需要将中间RDD结果保存下来，这就是我们的checkpoint，一般保存在高可用中，比如hdfs就是高可用的。 \n\n只有rdd才能checkPoint \n缓存cache到内存中，直接到内存中拿 \ncheckPoint是到hdfs\n\n# CheckPoint命令\n\n**设定目录，创建目录** ，\n必须指定缓存到哪个目录 \n\n```scala\nval rdd = sc.setCheckpointDir(\"hdfs://master:9000/ckpoint\")\nval rdd = sc.textFile(\"hdfs://master:9000/yao\")\nrdd.checkpoint\nrdd.count\n```\n\n会触发**两个**任务，一个任务计算，一个任务写入到ck指定的hdfs目录 \n\n为减小持久化的数据量，最好将RDD过滤出有节点意义的数据再进行ck操作，直接ck会把文件记录起来到hdfs中 ，但是count产生的数据不能ck，因为返回的是Long类型的，单数据类型的数据不能checkpoint\n\n\n在ck操作以后，RDD和数据的关联都取消了，ck成功以后，数据直接从ckpoint里面读取即可，由于ck属于transaction故ck必须在触发action之前执行 \n\n> 如果把RDD缓存到内存（即在ck之前有cache rdd到内存的操作）就不会另起一个作业一步一步从原始数据运行，然后再ck到hdfs目录，而是直接从内存中读取数据\n\n\n\n\n\n# 广播变量\n\n为了提高效率，比如mapreduce 使用join。当map段所需要的数据量不是很大，避免网络浪费，使用mapAsJoin把规则加入map端内存当中，这样mapreduce在map端可以直接在缓存中拿到规则，这样可以提高效率。广播变量的原理也是如此 \n\n```scala\nval bd = sc.broadcast(ruleArray)\n```\n\n广播出去 广播之后所有的executer都能收到，而且是相当于在每个executor中都存有这一小部分数据，不用通过网络传输，提高效率\n\n在rdd中拿到广播中的数据， \n\n```scala\nval arr  = bd.value \n//将数据展示\narr.toBuffer \n```\n\n","source":"_posts/SparkRDD介绍.md","raw":"---\ntitle: SparkRDD介绍\ndate: 2018年08月06日 22时15分52秒\ntags: [Spark,原理,RDD]\ncategories: 大数据\ntoc: true\n---\n\n[TOC]\n\n```scala\nsc.textfile(\"hdfs://master:9000/wc\").flatMap(_.split(\"分隔符\")).map((_,1)).reduceByKey(_+_).saveAsTextFile(\"hdfs://master:9000/wcResult\")\n```\n\n<!-- more -->\n\n当rdd形成过程中，worker的分区中只是预留了存放数据的位置，只有当action触发的时候，worker的分区中才会存在数据，sparkSubmit submit的命令行默认的是driver ，RDD的创建都是在在driver上创建的 \n\n\n\n\n\n# spark的分区与hdfs数据块的关系\n\nPartitioner函数不但决定了RDD本身的分片数量，也决定了parent RDD Shuffle输出时的分片数量。\n\n# SparkRDD\n\nRDD（ResilientDistributed Dataset）叫做分布式数据集，是Spark中最基本的数据抽象，它代表一个不可变、可分区、里面的元素可并行计算的集合。RDD具有数据流模型的特点：自动容错、位置感知性调度和可伸缩性。RDD允许用户在执行多个查询时显式地将工作集缓存在内存中，后续的查询能够重用工作集，这极大地提升了查询速度。\n\n![](https://ws1.sinaimg.cn/large/0069RVTdgy1fuawo5mvk1j31c20bq3zz.jpg)\n\n1）一组分片（Partition），即数据集的基本组成单位。对于RDD来说，每个分片都会被一个计算任务处理，并决定并行计算的粒度。用户可以在创建RDD时指定RDD的分片个数，如果没有指定，那么就会采用默认值。默认值就是程序所分配到的CPU Core的数目。\n\n2）一个计算每个分区的函数。Spark中RDD的计算是以分片为单位的，每个RDD都会实现compute函数以达到这个目的。compute函数会对迭代器进行复合，不需要保存每次计算的结果。\n\n3）RDD之间的依赖关系。RDD的每次转换都会生成一个新的RDD，所以RDD之间就会形成类似于流水线一样的前后依赖关系。在部分分区数据丢失时，Spark可以通过这个依赖关系重新计算丢失的分区数据，而不是对RDD的所有分区进行重新计算。\n\n 4）一个Partitioner，即RDD的分片函数。当前Spark中实现了两种类型的分片函数，一个是基于哈希的HashPartitioner，另外一个是基于范围的RangePartitioner。只有对于于key-value的RDD，才会有Partitioner，非key-value的RDD的Parititioner的值是None。Partitioner函数不但决定了RDD本身的分片数量，也决定了parent RDD Shuffle输出时的分片数量。\n\n 5）一个列表，存储存取每个Partition的优先位置（preferredlocation）。对于一个HDFS文件来说，**这个列表保存的就是每个****Partition所在的块的位置**。按照“移动数据不如移动计算”的理念，Spark在进行任务调度的时候，会尽可能地将计算任务分配到其所要处理数据块的存储位置。 血缘依赖\n\nRDD 5个特性 \n一个function作用一个partition \n如果是key-value格式的有一个默认的partitioner 默认是hashpartitioner \n如果是从hdfs这种文件系统类型读取的数据，会有一个prefered location，因为在大数据领域宁愿移动计算，也不愿移动数据，通常叫做数据本地化， \n\n# RDD数据读取\n\nrdd向hdfs中读取数据是一行一行读取放在迭代器里面，而不是一下子全部读取数据\n\nrdd向hdfs中读取数据，hdfs文件有几个数据块就会创建几个分区 \n\n读取数据还是用的hadoop的inputFormat来读取的\n\n# RDD的生成方式\n\n\n\n## RDD算子\n\n### Transformation\n\nRDD中的所有转换都是延迟加载的，也就是说，它们并不会直接计算结果。相反的，它们只是记住这些应用到基础数据集（例如一个文件）上的转换动作。只有当发生一个要求返回结果给Driver的动作时，这些转换才会真正运行。这种设计让Spark更加有效率地运行。\n\n常用的Transformation：\n\n| **转换**                                   | **含义**                                   |\n| ---------------------------------------- | ---------------------------------------- |\n| **map**(func)                            | 返回一个新的RDD，该RDD由每一个输入元素经过func函数转换后组成      |\n| **filter**(func)                         | 返回一个新的RDD，该RDD由经过func函数计算后返回值为true的输入元素组成 |\n| **flatMap**(func)                        | 类似于map，但是每一个输入元素可以被映射为0或多个输出元素（所以func应该返回一个序列，而不是单一元素） |\n| **mapPartitions**(func)                  | 类似于map，但独立地在RDD的每一个分片上运行，因此在类型为T的RDD上运行时，func的函数类型必须是Iterator[T] => Iterator[U] |\n| **mapPartitionsWithIndex**(func)         | 类似于mapPartitions，但func带有一个整数参数表示分片的索引值，因此在类型为T的RDD上运行时，func的函数类型必须是  (Int,  Interator[T]) => Iterator[U] |\n| **sample**(withReplacement, fraction, seed) | 根据fraction指定的比例对数据进行采样，可以选择是否使用随机数进行替换，seed用于指定随机数生成器种子 |\n| **union**(otherDataset)                  | 对源RDD和参数RDD求并集后返回一个新的RDD                 |\n| **intersection**(otherDataset)           | 对源RDD和参数RDD求交集后返回一个新的RDD                 |\n| **distinct**([numTasks]))                | 对源RDD进行去重后返回一个新的RDD                      |\n| **groupByKey**([numTasks])               | 在一个(K,V)的RDD上调用，返回一个(K, Iterator[V])的RDD |\n| **reduceByKey**(func, [numTasks])        | 在一个(K,V)的RDD上调用，返回一个(K,V)的RDD，使用指定的reduce函数，将相同key的值聚合到一起，与groupByKey类似，reduce任务的个数可以通过第二个可选的参数来设置 |\n| **aggregateByKey**(zeroValue)(seqOp, combOp, [numTasks]) |                                          |\n| **sortByKey**([ascending], [numTasks])   | 在一个(K,V)的RDD上调用，K必须实现Ordered接口，返回一个按照key进行排序的(K,V)的RDD |\n| **sortBy**(func,[ascending], [numTasks]) | 与sortByKey类似，但是更灵活                       |\n| **join**(otherDataset, [numTasks])       | 在类型为(K,V)和(K,W)的RDD上调用，返回一个相同key对应的所有元素对在一起的(K,(V,W))的RDD |\n| **cogroup**(otherDataset, [numTasks])    | 在类型为(K,V)和(K,W)的RDD上调用，返回一个(K,(Iterable<V>,Iterable<W>))类型的RDD |\n| **cartesian**(otherDataset)              | 笛卡尔积                                     |\n| **pipe**(command, [envVars])             |                                          |\n| **coalesce**(numPartitions**)   **       |                                          |\n| **repartition**(numPartitions)           |                                          |\n| **repartitionAndSortWithinPartitions**(partitioner) |                                          |\n\n### Action\n\n| **动作**                                   | **含义**                                   |\n| ---------------------------------------- | ---------------------------------------- |\n| **reduce**(*func*)                       | 通过func函数聚集RDD中的所有元素，这个功能必须是可交换且可并联的      |\n| **collect**()                            | 在驱动程序中，以数组的形式返回数据集的所有元素                  |\n| **count**()                              | 返回RDD的元素个数                               |\n| **first**()                              | 返回RDD的第一个元素（类似于take(1)）                  |\n| **take**(*n*)                            | 返回一个由数据集的前n个元素组成的数组                      |\n| **takeSample**(*withReplacement*,*num*, [*seed*]) | 返回一个数组，该数组由从数据集中随机采样的num个元素组成，可以选择是否用随机数替换不足的部分，seed用于指定随机数生成器种子 |\n| **takeOrdered**(*n*, *[ordering]*)       |                                          |\n| **saveAsTextFile**(*path*)               | 将数据集的元素以textfile的形式保存到HDFS文件系统或者其他支持的文件系统，对于每个元素，Spark将会调用toString方法，将它装换为文件中的文本 |\n| **saveAsSequenceFile**(*path*)           | 将数据集中的元素以Hadoop sequencefile的格式保存到指定的目录下，可以使HDFS或者其他Hadoop支持的文件系统。 |\n| **saveAsObjectFile**(*path*)             |                                          |\n| **countByKey**()                         | 针对(K,V)类型的RDD，返回一个(K,Int)的map，表示每一个key对应的元素个数。 |\n\n\n\n# 宽依赖窄依赖区分\n\n![](https://ws3.sinaimg.cn/large/006tNbRwly1fuhtdoo3nvj30gf087jrt.jpg)\n\n## 窄依赖 narrow dependencies\n\n三个小分块是RDD的分区，组合起来的大框是RDD，后面的是子rdd的分区，一个父rdd的分区只对应一个子rdd的分区（类比独生子女） ，一个子可以对应多个父分区（可以类比父母分区）\n\n如map，filter，union等算子都是操作的原来分区里面的数据,操作之后也在原来的分区 \njoin大多数情况下是宽依赖，在一种特殊情况下是窄依赖 (join是针对key value形式的rdd，相同key的会join在一起)\n\n## 宽依赖 wide dependencies\n\n父rdd一个分区会流向多个子rdd的分区类比多子女情况\n\ngroupBy ，reduceByKey ，join等\n\n下图b到g不是一个stage是因为，提前已经分好组，所以是窄依赖，没有stage \n![](https://ws3.sinaimg.cn/large/006tNbRwly1fuhu3makagj30af05rmxa.jpg)\n\n### Lineage\n\nRDD只支持粗粒度转换，即在大量记录上执行的单个操作。将创建RDD的一系列Lineage（即血统）记录下来，以便恢复丢失的分区。RDD的Lineage会记录RDD的元数据信息和转换行为，当该RDD的部分分区数据丢失时，它可以根据这些信息来重新运算和恢复丢失的数据分区。\n\n\n\n##  RDD的缓存\n\nSpark速度非常快的原因之一，就是在不同操作中可以在内存中持久化或缓存个数据集。当持久化某个RDD后，每一个节点都将把计算的分片结果保存在内存中，并在对此RDD或衍生出的RDD进行的其他动作中重用。这使得后续的动作变得更加迅速。RDD相关的持久化和缓存，是Spark最重要的特征之一。可以说，缓存是Spark构建迭代式算法和快速交互式查询的关键。\n\n### 缓存方式\n\nRDD通过persist方法或cache方法可以将前面的计算结果缓存，但是并不是这两个方法被调用时立即缓存，而是触发后面的action时，该RDD将会被缓存在计算节点的内存中，并供后面重用。\n\n\n\n通过查看源码发现cache最终也是调用了persist方法，默认的存储级别都是仅在内存存储一份，Spark的存储级别还有好多种，存储级别在object StorageLevel中定义的。\n\n缓存有可能丢失，或者存储存储于内存的数据由于内存不足而被删除，RDD的缓存容错机制保证了即使缓存丢失也能保证计算的正确执行。通过基于RDD的一系列转换，丢失的数据会被重算，由于RDD的各个Partition是相对独立的，因此只需要计算丢失的部分即可，并不需要重算全部Partition。\n\n\n\n\n\n\n\n# RDD缓存\n\nval rdd = sc.textFile(\"hdfs:hadoop1:9000/yao\").cache(); \ncache是trancsformation也是懒加载，遇到action 如count.collect才会，缓存到内存里面,而不是文件系统中读取 \ncache()调用的persist()\n\nrdd.unpersist() 就会将内存中的缓存释放掉 \nrdd.unpersist(true)\n\n\n\n# CheckPoint的背景\n\ncheckpoint属于transaction\n\n云计算一边要将中间结果进行产生多个RDD和多次运算，特别是机器学习，需要中间结果计算很多很多次迭代，有可能上百次 \n这样就需要将中间RDD结果保存下来，这就是我们的checkpoint，一般保存在高可用中，比如hdfs就是高可用的。 \n\n只有rdd才能checkPoint \n缓存cache到内存中，直接到内存中拿 \ncheckPoint是到hdfs\n\n# CheckPoint命令\n\n**设定目录，创建目录** ，\n必须指定缓存到哪个目录 \n\n```scala\nval rdd = sc.setCheckpointDir(\"hdfs://master:9000/ckpoint\")\nval rdd = sc.textFile(\"hdfs://master:9000/yao\")\nrdd.checkpoint\nrdd.count\n```\n\n会触发**两个**任务，一个任务计算，一个任务写入到ck指定的hdfs目录 \n\n为减小持久化的数据量，最好将RDD过滤出有节点意义的数据再进行ck操作，直接ck会把文件记录起来到hdfs中 ，但是count产生的数据不能ck，因为返回的是Long类型的，单数据类型的数据不能checkpoint\n\n\n在ck操作以后，RDD和数据的关联都取消了，ck成功以后，数据直接从ckpoint里面读取即可，由于ck属于transaction故ck必须在触发action之前执行 \n\n> 如果把RDD缓存到内存（即在ck之前有cache rdd到内存的操作）就不会另起一个作业一步一步从原始数据运行，然后再ck到hdfs目录，而是直接从内存中读取数据\n\n\n\n\n\n# 广播变量\n\n为了提高效率，比如mapreduce 使用join。当map段所需要的数据量不是很大，避免网络浪费，使用mapAsJoin把规则加入map端内存当中，这样mapreduce在map端可以直接在缓存中拿到规则，这样可以提高效率。广播变量的原理也是如此 \n\n```scala\nval bd = sc.broadcast(ruleArray)\n```\n\n广播出去 广播之后所有的executer都能收到，而且是相当于在每个executor中都存有这一小部分数据，不用通过网络传输，提高效率\n\n在rdd中拿到广播中的数据， \n\n```scala\nval arr  = bd.value \n//将数据展示\narr.toBuffer \n```\n\n","slug":"SparkRDD介绍","published":1,"updated":"2018-08-24T01:34:10.728Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloj0lm9003cykpbcuv7s64k"},{"title":"SparkStreaming介绍","date":"2018-08-15T17:50:47.842Z","toc":true,"_content":"\n[TOC]\n\n大数据领域，分为离线计算和实时计算 \n\n![](https://ws2.sinaimg.cn/large/006tNbRwgy1fuaxkz7halj30i6057dfw.jpg)\n\n![](https://ws2.sinaimg.cn/large/006tNbRwgy1fuaxl270fuj30kj034jrd.jpg)\n\n<!-- more -->\n\n## Streaming和Storm比较\n\n在时效性上比storm弱，在吞吐量上比storm大 \nstreaming需要设置时间间隔，设置多长时间产生一个批次记录到streaming放在RDD里面 \n比如设置5s，每隔5s就会产生一个RDD \nRDD需要是有序的\n\n![](https://ws3.sinaimg.cn/large/006tNbRwgy1fuax1z5n2wj30ne0ifgou.jpg)\n\n","source":"_posts/SparkStreaming介绍.md","raw":"---\ntitle: SparkStreaming介绍\ndate: 2018年08月06日 22时15分52秒\ntags: [Spark,SparkStreaming,原理]\ncategories: 大数据\ntoc: true\n---\n\n[TOC]\n\n大数据领域，分为离线计算和实时计算 \n\n![](https://ws2.sinaimg.cn/large/006tNbRwgy1fuaxkz7halj30i6057dfw.jpg)\n\n![](https://ws2.sinaimg.cn/large/006tNbRwgy1fuaxl270fuj30kj034jrd.jpg)\n\n<!-- more -->\n\n## Streaming和Storm比较\n\n在时效性上比storm弱，在吞吐量上比storm大 \nstreaming需要设置时间间隔，设置多长时间产生一个批次记录到streaming放在RDD里面 \n比如设置5s，每隔5s就会产生一个RDD \nRDD需要是有序的\n\n![](https://ws3.sinaimg.cn/large/006tNbRwgy1fuax1z5n2wj30ne0ifgou.jpg)\n\n","slug":"SparkStreaming介绍","published":1,"updated":"2018-08-15T18:09:40.373Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloj0lmb003hykpbl29fvuxu"},{"title":"SparkStreaming消费Kafka数据","date":"2018-08-15T15:53:30.330Z","toc":true,"_content":"\n[TOC]\n\nStreaming消费Kafka有两种方式\n\n#### 1、reciver方式\n\n根据时间来划分批次，缺点：有可能一个时间段会出现数据爆炸，有保存log到hdfs机制，但消耗大（zk来管理偏移量）\n\n#### 2、direct方式 1.3.6后推出\n\nexecutor和kafka的partition是一一对应的（是rdd的分区和kafka对应，如果一个executor的rdd有多个分区，那么一个executor可以对应多个partition）必须自己来管理偏移量，最好把偏移量写在zk或者其他第三方介质里面\n\n<!-- more -->\n\n# 非直连方式 receive方式\n\n \nspark cluster先与kafka集群建立连接 \n在每一个executor中创建一个Reciver \n当executor启动kafka启动后，reciver会一直消费kafka中的数据，一直拉，直连是每隔一个时间段去拉取 \n这种方式是zookeeper来管理数据的偏移量 \n问题:在时间间隔中，executor接收的数据超过了Executor的内存数，会造成数据的丢失 \n为了防止数据丢失，可以做checkpoint，或者是记录日志 \n可以多个reciver，一个reciver可以指定多个线程 \n**可以读读文章 Kafka Intergration Guide 官网链接**\n\n# 直连Direct Approach (No Receives)\n\n\nB-*代表broker，每一个broker中有三个分区（假设），但是每个broker里面只有一个分区是活着的 \n直连是每隔一个时间段去拉取 \n对消费数据的位置保证 \n会定期实时查询kafka topic+partition的偏移量，会根据偏移量的范围来处理每一个批次， executor不会接收超出接收范围的数据，而是记录下偏移量，下次接着拉取 \n一个kafka的partiton对应rdd的一个partition\n\n问题：一个partition只有一个Executor连接上，不能并行读去数据。 \n解决办法，可以repartition，分散到多个partition上去读取。 \n怎样让executor读取kafka分区里面的数据的速度快？ \n将boker的分区数创建成和worker的数目一样，也就是executor的数目一样，一个executor消费一个分区，这样数据读取比较快。并行读取数据，也可以控制读取的速度。 \n这样需要自己管理偏移量，以前的方式是zk管理偏移量 \n最好是将偏移量保存到zk里面，不过是自己控制的，防止将偏移量保存到本地宕机无法恢复。 \n**需要读博客 Spark streaming整合kafka** \n官方文档显示，一个数据保证只会消费一次，不会重复消费，更加高效 \n简化并行，一对一消费，高效，没有reciver作为消费者","source":"_posts/SparkStreaming消费Kafka数据.md","raw":"---\ntitle: SparkStreaming消费Kafka数据\ndate: 2018年08月06日 22时15分52秒\ntags: [Spark,SparkStreaming]\ncategories:\ntoc: true\n---\n\n[TOC]\n\nStreaming消费Kafka有两种方式\n\n#### 1、reciver方式\n\n根据时间来划分批次，缺点：有可能一个时间段会出现数据爆炸，有保存log到hdfs机制，但消耗大（zk来管理偏移量）\n\n#### 2、direct方式 1.3.6后推出\n\nexecutor和kafka的partition是一一对应的（是rdd的分区和kafka对应，如果一个executor的rdd有多个分区，那么一个executor可以对应多个partition）必须自己来管理偏移量，最好把偏移量写在zk或者其他第三方介质里面\n\n<!-- more -->\n\n# 非直连方式 receive方式\n\n \nspark cluster先与kafka集群建立连接 \n在每一个executor中创建一个Reciver \n当executor启动kafka启动后，reciver会一直消费kafka中的数据，一直拉，直连是每隔一个时间段去拉取 \n这种方式是zookeeper来管理数据的偏移量 \n问题:在时间间隔中，executor接收的数据超过了Executor的内存数，会造成数据的丢失 \n为了防止数据丢失，可以做checkpoint，或者是记录日志 \n可以多个reciver，一个reciver可以指定多个线程 \n**可以读读文章 Kafka Intergration Guide 官网链接**\n\n# 直连Direct Approach (No Receives)\n\n\nB-*代表broker，每一个broker中有三个分区（假设），但是每个broker里面只有一个分区是活着的 \n直连是每隔一个时间段去拉取 \n对消费数据的位置保证 \n会定期实时查询kafka topic+partition的偏移量，会根据偏移量的范围来处理每一个批次， executor不会接收超出接收范围的数据，而是记录下偏移量，下次接着拉取 \n一个kafka的partiton对应rdd的一个partition\n\n问题：一个partition只有一个Executor连接上，不能并行读去数据。 \n解决办法，可以repartition，分散到多个partition上去读取。 \n怎样让executor读取kafka分区里面的数据的速度快？ \n将boker的分区数创建成和worker的数目一样，也就是executor的数目一样，一个executor消费一个分区，这样数据读取比较快。并行读取数据，也可以控制读取的速度。 \n这样需要自己管理偏移量，以前的方式是zk管理偏移量 \n最好是将偏移量保存到zk里面，不过是自己控制的，防止将偏移量保存到本地宕机无法恢复。 \n**需要读博客 Spark streaming整合kafka** \n官方文档显示，一个数据保证只会消费一次，不会重复消费，更加高效 \n简化并行，一对一消费，高效，没有reciver作为消费者","slug":"SparkStreaming消费Kafka数据","published":1,"updated":"2018-08-20T01:39:18.490Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloj0lmc003kykpbj2o9z4ie"},{"title":"Spark启动流程及一些小总结","date":"2018-08-15T15:54:20.258Z","toc":true,"_content":"\n[TOC]\n\n# spark的架构模型\n\n![](https://ws3.sinaimg.cn/large/006tNbRwly1fuhrnmk1skj310i0ssgma.jpg)\n\n# 角色功能\n\nDriver：以spark-submit提交程序为例，执行该命令的主机为driver（在任意一台安装了spark（spark submit）的机器上启动一个任务的客户端也就是Driver 。客户端与集群需要建立链接，建立的这个链接对象叫做sparkContext，只有这个对象创建成功才标志这这个客户端与spark集群链接成功。SparkContext是driver进程中的一个对象，提交任务的时候，指定了每台机器需要多少个核cores，需要的内存 ）\n\nMaster: 给任务提供资源，分配资源，master跟worker通信，报活和更新资源 \n\nWorker:  以子进程的方式启动executor\n\nExecutor：Driver提交程序到executor(CoarseGrainedExecutorBankend)，执行任务的进程，exector是task运行的容器\n\n<!-- more -->\n\n## Driver端\n\ndriver创建sparkContext于spark集群建立连接，然后向master申请资源，master来调度决定向worker的哪台机器上执行 ，在合适的worker（资源分配策略）上以子进程的方式启动excutor来执行 （Class.forName()会只在自己的进程里面执行，反射是在同一进程 ，启动java子进程的方法 是另一个进程，debug跳不到子进程中去，进程之间进行方法调用只有rpc才可以 ）此过程只是启动executor，最终任务的执行需要等到action触发，提交程序最终也是提交到executor上，在整个过程中，\n\n\n\n> driver提交一个application时就会在driver主机生成一个sparkSubmit进程来监控任务的执行情况。action触发程序运行后，executor只会通过driverClinet与driver交互，applicationMaster 不负责具体某个任务的进度 ,只负责资源的调度和监控。driver在action的时候才会把任务提交给executor。\n\n## master与worker交互\n\nworker和master以进程方式启动后 ，worker会向master进行注册,worker在启动的时候，会在spark env中指定worker的资源，如果没指定的话，会默认使用机器的所有核数，所有内存-1G的内存，预留1G给操作系统，然后worker会告知master自己拥有的资源，如核数cores，内存等。在之后的过程中，worker会实时向master发送心跳报活。\n\n\n\n## 资源分配策略\n\nspark任务资源分配有两种策略：尽量打散 和尽量集中\n\n以task1需要2core为例：\n\n尽量打散是尽可能的将任务分散到不同的worker来启动exector，机器1分配1core，机器2分配1core\n\n尽量集中是尽可能在更少的机器上来启动worker并启动exector，在分配的机器上尽可能多的分配资源，达到集中在更少的机器上的目的。如在机器1上分配2core（前提是机器1 剩余core数>=2）\n\n\n\n\n\n# RDD整个运行流程\n\n首先rdd产生过后，经过一系列的处理，构成相互依赖，在有宽依赖的情况下会划分stage，构成一个有向无环图也就是DAG，整个rdd的构建，完成在action触发之前，action触发就会将task提交到executor容器中运行\n\n\n\n\n\n## Driver与executor交互\n\n在任务提交的时候，会将driver信息封装，先告诉给master，master再告诉给worker，然后worker启动executor进程的时候，会将信息告诉给executor，故而最终exector能获取到driver的信息\n\n在executor创建成功后，就会和driver建立连接，而不再与Master通信，这样是为了减少Master压力，也不让Master成为性能瓶颈。\n\n由于executor有可能在很多台机器上启动，driver无法知晓在哪台机器上启动有exector，所以需要executor和driver进行rpc通信（netty或者akka）主动建立连接。建立通信后exector向driver汇报状态及其执行进度，driver向executor提交计算任务，然后在executor中执行，只有当RDD触发action的时候，driver才将taskset以stage的形式提交任务给executor，任务的最细粒度是task\n\n然后executor就跟driver进行通信，Rdd执行逻辑的时候就不再通过Master，这是为了减少Master压力，也不让Master成为性能瓶颈。\n\n\n\n# RDD的构建详细阶段\n\n\n\n![](https://ws2.sinaimg.cn/large/006tNbRwly1fuhtcjutpej30e007hmxg.jpg)\n\n\n\n## 第一阶段 rdd创建\n\nrdd创建都是在driver中执行，只有运行时有数据流向rdd才会提交到executor。如hdfs中读取数据，会产生很多的RDD….，RDD之间存在着依赖关系， RDD之间的**转换**都是由transformation产生的（故transformation返回对象为RDD），**在action触发后**，DAG就确定了RDD就形成了数据的流向hdfs->RDD1->RDD2->RDD3....->RDDn\n\n## 第二阶段 DAGScheduler\n\nstage的划分，也就是DAGScheduler的执行\n\nstage切分依据：有宽依赖（后面对宽窄依赖有说明）就会切分，更明确的说就是有shuffle的时候切分\n\n宽依赖：遇到shuffle就是宽依赖 \n窄依赖：没有shuffle就是窄依赖 \n\n把DAG切分成stage，然后以taskSet(流水线task的集合，所有的task业务逻辑都是一样的，只是计算的数据块不同，因为每一个task只计算一个分区，且taskSet集合中的任务会并行操作）\n\ntask由master决定在哪个executor上运行，之后由driver提交task到executor来执行\n\n> 前面的stage先提交，因为stage的划分意味着有shuffle，那么后面stage会依赖前面stage的数据，故此前面stage先提交。\n\n\n\nAction触发的时候，DAG就可以确定了，transformation的调用都是在driver中完成的，一旦调用了action，会提交这个任务。\n\n## 第三阶段 TaskScheduler\n\n**TaskScheduler**\n\n**cluster Manager** ：就是Master，启动work上的executor \n**stragling tasks**：例子：当100个任务，99都完成了，剩下了一个任务1，会再启动和剩下的一模一样的任务2，任务1和任务2谁先完成，就用谁的结果\n\n\n\n## 第四阶段 任务执行\n\nBlock Manager管理数据\n\n也就是action触发，数据开始流通，driver提交task到worker上的executor，执行真正的业务逻辑\n\n\n\n计算完成之后，若将这些结果数据collect聚合，则会将所有executor的部分结果聚合在一起，比如count、sum的，多个worker中每一个worker只会保存一部分数据，driver保存了所有数据，、都是在driver里面\n\n\n\n# task与读取hdfs数据的关系\n\ntask提交之后，如果向hdfs中拉取数据，driver已经将要获取数据的元数据都已经获取到了，task会和分区数挂钩，在executor上一个task读取一个分区。**task读取数据不是一下将所有数据加载到内存里面，是先构建一个迭代器，拿到一条处理一条**。处理完成之后会将数据保存在executor的内存中，如果内存放不下，就将数据持久化到磁盘上\n\n","source":"_posts/Spark启动流程及一些小总结.md","raw":"---\ntitle: Spark启动流程及一些小总结\ndate: 2018年08月06日 22时15分52秒\ntags: [Spark,原理]\ncategories: 大数据\ntoc: true\n---\n\n[TOC]\n\n# spark的架构模型\n\n![](https://ws3.sinaimg.cn/large/006tNbRwly1fuhrnmk1skj310i0ssgma.jpg)\n\n# 角色功能\n\nDriver：以spark-submit提交程序为例，执行该命令的主机为driver（在任意一台安装了spark（spark submit）的机器上启动一个任务的客户端也就是Driver 。客户端与集群需要建立链接，建立的这个链接对象叫做sparkContext，只有这个对象创建成功才标志这这个客户端与spark集群链接成功。SparkContext是driver进程中的一个对象，提交任务的时候，指定了每台机器需要多少个核cores，需要的内存 ）\n\nMaster: 给任务提供资源，分配资源，master跟worker通信，报活和更新资源 \n\nWorker:  以子进程的方式启动executor\n\nExecutor：Driver提交程序到executor(CoarseGrainedExecutorBankend)，执行任务的进程，exector是task运行的容器\n\n<!-- more -->\n\n## Driver端\n\ndriver创建sparkContext于spark集群建立连接，然后向master申请资源，master来调度决定向worker的哪台机器上执行 ，在合适的worker（资源分配策略）上以子进程的方式启动excutor来执行 （Class.forName()会只在自己的进程里面执行，反射是在同一进程 ，启动java子进程的方法 是另一个进程，debug跳不到子进程中去，进程之间进行方法调用只有rpc才可以 ）此过程只是启动executor，最终任务的执行需要等到action触发，提交程序最终也是提交到executor上，在整个过程中，\n\n\n\n> driver提交一个application时就会在driver主机生成一个sparkSubmit进程来监控任务的执行情况。action触发程序运行后，executor只会通过driverClinet与driver交互，applicationMaster 不负责具体某个任务的进度 ,只负责资源的调度和监控。driver在action的时候才会把任务提交给executor。\n\n## master与worker交互\n\nworker和master以进程方式启动后 ，worker会向master进行注册,worker在启动的时候，会在spark env中指定worker的资源，如果没指定的话，会默认使用机器的所有核数，所有内存-1G的内存，预留1G给操作系统，然后worker会告知master自己拥有的资源，如核数cores，内存等。在之后的过程中，worker会实时向master发送心跳报活。\n\n\n\n## 资源分配策略\n\nspark任务资源分配有两种策略：尽量打散 和尽量集中\n\n以task1需要2core为例：\n\n尽量打散是尽可能的将任务分散到不同的worker来启动exector，机器1分配1core，机器2分配1core\n\n尽量集中是尽可能在更少的机器上来启动worker并启动exector，在分配的机器上尽可能多的分配资源，达到集中在更少的机器上的目的。如在机器1上分配2core（前提是机器1 剩余core数>=2）\n\n\n\n\n\n# RDD整个运行流程\n\n首先rdd产生过后，经过一系列的处理，构成相互依赖，在有宽依赖的情况下会划分stage，构成一个有向无环图也就是DAG，整个rdd的构建，完成在action触发之前，action触发就会将task提交到executor容器中运行\n\n\n\n\n\n## Driver与executor交互\n\n在任务提交的时候，会将driver信息封装，先告诉给master，master再告诉给worker，然后worker启动executor进程的时候，会将信息告诉给executor，故而最终exector能获取到driver的信息\n\n在executor创建成功后，就会和driver建立连接，而不再与Master通信，这样是为了减少Master压力，也不让Master成为性能瓶颈。\n\n由于executor有可能在很多台机器上启动，driver无法知晓在哪台机器上启动有exector，所以需要executor和driver进行rpc通信（netty或者akka）主动建立连接。建立通信后exector向driver汇报状态及其执行进度，driver向executor提交计算任务，然后在executor中执行，只有当RDD触发action的时候，driver才将taskset以stage的形式提交任务给executor，任务的最细粒度是task\n\n然后executor就跟driver进行通信，Rdd执行逻辑的时候就不再通过Master，这是为了减少Master压力，也不让Master成为性能瓶颈。\n\n\n\n# RDD的构建详细阶段\n\n\n\n![](https://ws2.sinaimg.cn/large/006tNbRwly1fuhtcjutpej30e007hmxg.jpg)\n\n\n\n## 第一阶段 rdd创建\n\nrdd创建都是在driver中执行，只有运行时有数据流向rdd才会提交到executor。如hdfs中读取数据，会产生很多的RDD….，RDD之间存在着依赖关系， RDD之间的**转换**都是由transformation产生的（故transformation返回对象为RDD），**在action触发后**，DAG就确定了RDD就形成了数据的流向hdfs->RDD1->RDD2->RDD3....->RDDn\n\n## 第二阶段 DAGScheduler\n\nstage的划分，也就是DAGScheduler的执行\n\nstage切分依据：有宽依赖（后面对宽窄依赖有说明）就会切分，更明确的说就是有shuffle的时候切分\n\n宽依赖：遇到shuffle就是宽依赖 \n窄依赖：没有shuffle就是窄依赖 \n\n把DAG切分成stage，然后以taskSet(流水线task的集合，所有的task业务逻辑都是一样的，只是计算的数据块不同，因为每一个task只计算一个分区，且taskSet集合中的任务会并行操作）\n\ntask由master决定在哪个executor上运行，之后由driver提交task到executor来执行\n\n> 前面的stage先提交，因为stage的划分意味着有shuffle，那么后面stage会依赖前面stage的数据，故此前面stage先提交。\n\n\n\nAction触发的时候，DAG就可以确定了，transformation的调用都是在driver中完成的，一旦调用了action，会提交这个任务。\n\n## 第三阶段 TaskScheduler\n\n**TaskScheduler**\n\n**cluster Manager** ：就是Master，启动work上的executor \n**stragling tasks**：例子：当100个任务，99都完成了，剩下了一个任务1，会再启动和剩下的一模一样的任务2，任务1和任务2谁先完成，就用谁的结果\n\n\n\n## 第四阶段 任务执行\n\nBlock Manager管理数据\n\n也就是action触发，数据开始流通，driver提交task到worker上的executor，执行真正的业务逻辑\n\n\n\n计算完成之后，若将这些结果数据collect聚合，则会将所有executor的部分结果聚合在一起，比如count、sum的，多个worker中每一个worker只会保存一部分数据，driver保存了所有数据，、都是在driver里面\n\n\n\n# task与读取hdfs数据的关系\n\ntask提交之后，如果向hdfs中拉取数据，driver已经将要获取数据的元数据都已经获取到了，task会和分区数挂钩，在executor上一个task读取一个分区。**task读取数据不是一下将所有数据加载到内存里面，是先构建一个迭代器，拿到一条处理一条**。处理完成之后会将数据保存在executor的内存中，如果内存放不下，就将数据持久化到磁盘上\n\n","slug":"Spark启动流程及一些小总结","published":1,"updated":"2018-08-23T16:50:45.753Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloj0lme003pykpbvuxngkmp"},{"title":"Spark本地调试远程集群程序","date":"2018-08-07T08:09:43.314Z","toc":true,"_content":"\n\n\n[TOC]\n\n![](https://ws2.sinaimg.cn/large/006tNbRwgy1fu562ur7pxj317o0s2qfq.jpg)\n\n由于在生产环境中进行调试spark程序需要进行打包和各种跳板机跳转，最好在本地搭一套集群来进行一些代码基础检查。\n\n<!-- more-->\n\n需要将 本地集群中**hdfs-site.xml core.site.xml **拷贝到本地工程的resource文件夹下，这样会应用这些配置，注意要在提交到生产环境的时候，替换成对应环境的配置文件\n\n```scala\nval array = Array(\n      (\"spark.serializer\", \"org.apache.spark.serializer.KryoSerializer\"),\n      (\"spark.storage.memoryFraction\", \"0.3\"),\n      (\"spark.memory.useLegacyMode\", \"true\"),\n      (\"spark.shuffle.memoryFraction\", \"0.6\"),\n      (\"spark.shuffle.file.buffer\", \"128k\"),\n      (\"spark.reducer.maxSizeInFlight\", \"96m\"),\n      (\"spark.sql.shuffle.partitions\", \"500\"),\n      (\"spark.default.parallelism\", \"180\"),\n      (\"spark.dynamicAllocation.enabled\", \"false\")\n    )\n    val conf = new SparkConf().setAll(array)\n      .setJars(Array(\"your.jar\"))\n    val sparkSession: SparkSession = SparkSession\n      .builder\n      .appName(applicationName)\n      .enableHiveSupport()\n      .master(\"spark://master:7077\")\n      .config(conf)\n      .getOrCreate()\n    val sqlContext = sparkSession.sqlContext\n    val sparkContext: SparkContext = sparkSession.sparkContext\n```\n\n","source":"_posts/Spark本地调试远程集群程序.md","raw":"---\ntitle:  Spark本地调试远程集群程序\ndate: 2018年06月21日 22时15分52秒\ntags: [Spark]\ncategories: 大数据\ntoc: true\n---\n\n\n\n[TOC]\n\n![](https://ws2.sinaimg.cn/large/006tNbRwgy1fu562ur7pxj317o0s2qfq.jpg)\n\n由于在生产环境中进行调试spark程序需要进行打包和各种跳板机跳转，最好在本地搭一套集群来进行一些代码基础检查。\n\n<!-- more-->\n\n需要将 本地集群中**hdfs-site.xml core.site.xml **拷贝到本地工程的resource文件夹下，这样会应用这些配置，注意要在提交到生产环境的时候，替换成对应环境的配置文件\n\n```scala\nval array = Array(\n      (\"spark.serializer\", \"org.apache.spark.serializer.KryoSerializer\"),\n      (\"spark.storage.memoryFraction\", \"0.3\"),\n      (\"spark.memory.useLegacyMode\", \"true\"),\n      (\"spark.shuffle.memoryFraction\", \"0.6\"),\n      (\"spark.shuffle.file.buffer\", \"128k\"),\n      (\"spark.reducer.maxSizeInFlight\", \"96m\"),\n      (\"spark.sql.shuffle.partitions\", \"500\"),\n      (\"spark.default.parallelism\", \"180\"),\n      (\"spark.dynamicAllocation.enabled\", \"false\")\n    )\n    val conf = new SparkConf().setAll(array)\n      .setJars(Array(\"your.jar\"))\n    val sparkSession: SparkSession = SparkSession\n      .builder\n      .appName(applicationName)\n      .enableHiveSupport()\n      .master(\"spark://master:7077\")\n      .config(conf)\n      .getOrCreate()\n    val sqlContext = sparkSession.sqlContext\n    val sparkContext: SparkContext = sparkSession.sparkContext\n```\n\n","slug":"Spark本地调试远程集群程序","published":1,"updated":"2018-08-10T18:29:43.521Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloj0lmg003sykpb0a4821m7"},{"title":"Spark算子案例","date":"2018-08-15T15:52:40.133Z","toc":true,"_content":"\n[TOC]\n\n# HelloWord？WorldCount\n\n```scala\nsc.textfile(\"hdfs://master:9000/wc\").flatMap(_.split(\"分隔符\")).map((_,1)).reduceByKey(_+_).saveAsTextFile(\"hdfs://master:9000/wcResult\")\n```\n\n\n数据最开始在Driver，计算的时候数据会流入worker\n当rdd形成过程中，worker的分区中只是预留了存放数据的位置，只有当action触发的时候，worker的分区中才会存在数据\n\nSpark的运算都是通过算子进行RDD的转换及运算，那我们对算子进行简单熟悉[参考RDD算子实例](http://homepage.cs.latrobe.edu.au/zhe/ZhenHeSparkRDDAPIExamples.html)\n\n<!-- more -->\n\n\n\n\n\nreduceByKey先进行一下combineer 移动计算\n\ngroupByKey不好\n\nreduceByKey会在局部先进行一下求和\n\ngroupByKey是会将所有的数据放在一个大集合里面，然后再求和 ，会消耗更多的网络带宽，不符合计算本地化\n\n\n\n\n\n一下一些RDD是给予rdd1来操作的\n\n```scala\nval rdd1 = sc.parallelize(List(1,2,3,4,5,6,7,8,9), 2)\n```\n\n\n\n## mapPartitions\n\nmap 是对 rdd 中的每一个元素进行操作，而 mapPartitions(foreachPartition) 则是对 rdd 中的每个分区的迭代器进行操作。如果在 map 过程中需要频繁创建额外的对象 (例如将 rdd 中的数据通过 jdbc 写入数据库, map 需要为每个元素创建一个链接而 mapPartition 为每个 partition 创建一个链接), 则 mapPartitions 效率比 map 高的多。\n\nSparkSql 或 DataFrame 默认会对程序进行 mapPartition 的优化。\n\n\n\n## mapPartitionsWithIndex\n\nmapPartitionWithIndex与mapPartition类似，只是会带上分区的序号\n\n把每个partition中的**分区号和对应的值**拿出来, 源码中方法的形式：\n\n```scala\nval func(index,Int,iter:Interator[(Int)]):Interator[String] = {\niter.toList.map(x => \"[partID:\" +  index + \", val: \" + x + \"]\").iterator\n}\n```\n\n会转换成函数 \n函数的形式\n\n```scala\nval func = (index: Int, iter: Iterator[(Int)]) => {\n  iter.toList.map(x => \"[partID:\" +  index + \", val: \" + x + \"]\").iterator\n}\nrdd1.mapPartitionsWithIndex(func).collect\n```\n\n![](https://ws3.sinaimg.cn/large/006tNbRwgy1fucjpo4afaj31ik056whp.jpg)\n\n## aggregate (action)\n\naggregate是一个action操作\n\n源码定义\n\n```scala\ndef aggregate[U](zeroValue: U)(seqOp: (U, T) ⇒ U, combOp: (U, U) ⇒ U)(implicit arg0: ClassTag[U]): U\n```\n\neqOp 操作会聚合各分区中的元素，然后 combOp 操作把所有分区的聚合结果再次聚合，两个操作的初始值都是 zeroValue.   seqOp 的操作是遍历分区中的所有元素 (T)，第一个 T 跟 zeroValue 做操作，结果再作为与第二个 T 做操作的 zeroValue，直到遍历完整个分区。combOp 操作是把各分区聚合的结果，再聚合。aggregate 函数返回一个跟 RDD 不同类型的值。因此，需要一个操作 seqOp 来把分区中的元素 T 合并成一个 U，另外一个操作 combOp 把所有 U 聚合。\n\n参考[理解 Spark RDD 中的 aggregate 函数](https://blog.csdn.net/qingyang0320/article/details/51603243)\n\n第一个参数：初始值（在进行操作的时候，会默认带入该值进行） \n第二个参数:   是两个函数[每个函数都是2个参数(第一个函数:先对各个分区进行合并, 第二个函数:对各个分区合并后的结果再进行合并)] \n\n最后得到返回值\n\n\n\n> rdd1为上面的rdd1分区函数的结果\n\n```scala\nrdd1.aggregate(0)(_+_, _+_)\n```\n\n**0 + (0+1+2+3+4 + 0+5+6+7+8+9)**\n\n![](https://ws4.sinaimg.cn/large/006tNbRwgy1fuck6fl2chj30kg02ut96.jpg)\n\n```scala\nrdd1.aggregate(7)(_+_, _+_)\n```\n\n**7 + (7+1+2+3+4 + 7+5+6+7+8+9)**\n\n![](https://ws4.sinaimg.cn/large/006tNbRwgy1fuck87fxhij30ju02gt92.jpg)\n\n\n\n```scala\nrdd1.aggregate(0)(math.max(_, _), _ + _)\n```\n\n![](https://ws4.sinaimg.cn/large/006tNbRwgy1fuck95wu88j30qo02o74x.jpg)\n\n\n\n```Scala\nrdd1.aggregate(5)(math.max(_, _), _ + _)\n```\n\n**5和1比, 得5再和234比得5 --> 5和6789比,得9 --> 5 + (5+9)**\n\n![](https://ws4.sinaimg.cn/large/006tNbRwgy1fucouprhcjj30s402yjs5.jpg)\n\n\n\n\n\n```scala\nval rdd2 = sc.parallelize(List(\"q\",\"w\",\"e\",\"r\",\"t\",\"y\",\"u\",\"i\",\"o\",\"p\"),2)\n```\n\n可以用更加直接的方式验证操作\n\n```Scala\ndef func2(index: Int, iter: Iterator[(String)]) : Iterator[String] = {\n  iter.toList.map(x => \"[partID:\" +  index + \", val: \" + x + \"]\").iterator\n}\n```\n\n```Scala\nrdd2.aggregate(\"\")(_ + _, _ + _)\nrdd2.aggregate(\"=\")(_ + _, _ + _)\nrdd2.aggregate(\"|\")(_ + _, _ + _)\n```\n\n![](https://ws1.sinaimg.cn/large/006tNbRwgy1fucpd6axxej30os034wf7.jpg)\n\n\n\n\n\n```scala\nval rdd3 = sc.parallelize(List(\"qazqqw7\",\"jishhrwe9\",\"sdfwezsddf12\",\"12esdww8\"),2)\nrdd3.aggregate(\"\")((x,y) => math.max(x.length, y.length).toString, (x,y) => x + y)\n```\n\n![](https://ws3.sinaimg.cn/large/006tNbRwgy1fucpvxoentj31gw03276d.jpg)\n\n\n\n```scala\nval rdd4 = sc.parallelize(List(\"qazqqw7\",\"jishhrwe9\",\"sdfwezsddf12\",\"\"),2)\nrdd4.aggregate(\"\")((x,y) => math.min(x.length, y.length).toString, (x,y) => x + y)\n```\n\n![](https://ws1.sinaimg.cn/large/006tNbRwgy1fucpwdi27nj31g8032abq.jpg)\n\n\n\n\n\n## aggregateByKey\n\n对每个分区进行计算\n\n```scala\nval pairRDD = sc.parallelize(List( (\"a\",1), (\"a\", 12), (\"b\", 4),(\"c\", 17), (\"c\", 12), (\"b\", 2)), 2)\ndef func2(index: Int, iter: Iterator[(String, Int)]) : Iterator[String] = {\n  iter.toList.map(x => \"[partID:\" +  index + \", val: \" + x + \"]\").iterator\n}\npairRDD.mapPartitionsWithIndex(func2).collect\n\n```\n\n## combineByKey\n\nreduceByKey aggregateByKey底层都是依赖的combineByKey，combineByKey比较底层的算子 \n和reduceByKey是相同的效果\n\n**combineByKey有三个参数**\n\n第一个参数x: **原封不动取出来**  第二个参数:**是函数, 局部运算**, 第三个:是函数, **对局部运算后的结果再做运算**\n\n\n\n```scala\nval rdd4 = sc.parallelize(List(\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\"),2)\nval rdd5 = sc.parallelize(List(1,1,2,2,2,1,2,2,2),2)\nval rdd6 = rdd5.zip(rdd4)\nval rdd7 = rdd6.combineByKey(List(_),(x:List[String],y:String)=>x:+y,(m:List[String],n:List[String])=>m ++ n)\nrdd7.collect\n```\n\n\n\n## reduceByKey\n\nreduceByKey 用于对每个 key 对应的多个 value 进行 merge 操作，最重要的是它能够在本地先进行 merge 操作，并且 merge 操作可以通过函数自定义。\n\n## groupByKey\n\ngroupByKey 也是对每个 key 进行操作，但只生成一个 sequence。不会再进行\n\n需要特别注意 “Note” 中的话，它告诉我们：如果需要对 sequence 进行 aggregation 操作（注意，groupByKey 本身不能自定义操作函数），那么，选择 reduceByKey/aggregateByKey 更好。这是因为 groupByKey 不能自定义函数，我们需要先用 groupByKey 生成 RDD，然后才能对此 RDD 通过 map 进行自定义函数操作。\n\n\n\n## checkpoint\n\n将rdd内容持久化\n\n```scala\nsc.setCheckpointDir(\"hdfs://master:9000/ck\")\nval rdd = sc.textFile(\"hdfs://master:9000/wc\").flatMap(_.split(\" \")).map((_, 1)).reduceByKey(_+_)\nrdd.checkpoint\nrdd.isCheckpointed\nrdd.count\nrdd.isCheckpointed\nrdd.getCheckpointFile\n\n```\n\n## coalesce, repartition\n\n有时候需要重新设置 Rdd 的分区数量，比如 Rdd 的分区中，Rdd 分区比较多，但是每个 Rdd 的数据量比较小，需要设置一个比较合理的分区。或者需要把 Rdd 的分区数量调大。还有就是通过设置一个 Rdd 的分区来达到设置生成的文件的数量。\n\n如果分区的数量发生激烈的变化，如设置 numPartitions = 1，这可能会造成运行计算的节点比你想象的要少，为了避免这个情况，可以设置 shuffle=true，\n\n那么这会增加 shuffle 操作。\n\n关于这个分区的激烈的变化情况，比如分区数量从父 Rdd 的几千个分区设置成几个，有可能会遇到这么一个错误。\n\n```\njava.io.IOException: Unable to acquire 16777216 bytes of memory\n```\n\n这个错误只要把 shuffle 设置成 true 即可解决。\n\n当把父 Rdd 的分区数量增大时，比如 Rdd 的分区是 100，设置成 1000，如果 shuffle 为 false，并不会起作用。\n\n这时候就需要设置 shuffle 为 true 了，那么 Rdd 将在 shuffle 之后返回一个 1000 个分区的 Rdd，数据分区方式默认是采用 hash partitioner。\n\n最后来看看 repartition() 方法的源码：\n\n\n\n\n\ncoalesce() 方法的作用是返回指定一个新的指定分区的 Rdd。\n\n\n\n```scala\nval rdd1 = sc.parallelize(1 to 10, 10)\nval rdd2 = rdd1.coalesce(2, false)\nrdd2.partitions.length\n\n```\n\n[](https://www.cnblogs.com/fillPv/p/5392186.html)\n\n## collectAsMap \n\n将其他集合保存为map结构\n\n```scala\nval rdd = sc.parallelize(List((\"a\", 1), (\"b\", 2)))\nrdd.collectAsMap\n得到结果\nMap(b -> 2, a -> 1)\n```\n\n\n\n## countByKey\n\n```scala\nval rdd1 = sc.parallelize(List((\"a\", 1), (\"b\", 2), (\"b\", 2), (\"c\", 2), (\"c\", 1)))\nrdd1.countByKey \n统计Key出现的次数\n结果 Map(b -> 2, a -> 1, c -> 2) \n```\n\n\n\n## countByValue\n\n```scala\nval rdd1 = sc.parallelize(List((\"a\", 1), (\"b\", 2), (\"b\", 2), (\"c\", 2), (\"c\", 1)))\nrdd1.countByValue\n结果 (将整个元组作为key)\nMap((b,2) -> 2, (c,2) -> 1, (a,1) -> 1, (c,1) -> 1)\n```\n\n\n\n\n\n## filterByRange\n\n```scala\nval rdd1 = sc.parallelize(List((\"a\", 5), (\"b\", 3), (\"c\", 4), (\"d\", 2), (\"e\", 1)))\nval rdd2 = rdd1.filterByRange(\"b\", \"d\")\nrdd2.collect\n\nArray[(String, Int)] = Array((b,3), (c,4), (d,2))\n\n```\n\n## flatMapValues \n\n压平\n\n```scala\nval rdd3 = sc.parallelize(List((\"a\", \"1 2\"), (\"b\", \"3 4\")))\nval rdd4 = rdd3.flatMapValues(_.split(\" \"))\nrdd4.collect\n\nArray[(String, String)] = Array((a,1), (a,2), (b,3), (b,4))\n\n```\n\n## foldByKey\n\n```scala\nval rdd1 = sc.parallelize(List(\"a22\", \"b232\", \"c\", \"d\"), 2)\nval rdd2 = rdd1.map(x => (x.length, x))\nrdd2.collect\n结果： Array[(Int, String)] = Array((3,a22), (4,b232), (1,c), (1,d))\n\nval rdd3 = rdd2.foldByKey(\"\")(_+_)\nrdd3.collect\n\n\n\n\n结果：将相同key的元组合并在一起，\nArray[(Int, String)] = Array((4,b232), (1,cd), (3,a22))\n\n```\n\n## foreach\n\nforeach是针对于每一个元素， \nforeachPartition是针对每一个分区， \nforeachPartition是写入数据库时，可以将在foreachPartition时获得一个数据库连接，通过map方法来将每个分区的全部元素写入到数据库\n\n## foreachPartition\n\n3个分区\n\n```scala\nval rdd1 = sc.parallelize(List(1, 2, 3, 4, 5, 6, 7, 8, 9), 3)\nrdd1.foreachPartition(x => println(x.reduce(_ + _)))\n\n```\n\n## keyBy\n\n以传入的参数做key\n\n```scala\nval rdd1 = sc.parallelize(List(\"dog\", \"salmon\", \"salmon\", \"rat\", \"elephant\"), 3)\nval rdd2 = rdd1.keyBy(_.length)\nrdd2.collect\n结果 Array((3,dog), (6,salmon), (6,salmon), (3,rat), (8,elephant))\n\n```\n\n## keys values\n\n```scala\nval rdd1 = sc.parallelize(List(\"dog\", \"tiger\", \"lion\", \"cat\", \"panther\", \"eagle\"), 2)\nval rdd2 = rdd1.map(x => (x.length, x))\nrdd2.keys.collect\nrdd2.values.collect\n```\n\n\n\n\n\n","source":"_posts/Spark算子.md","raw":"---\ntitle: Spark算子案例\ndate: 2018年08月06日 22时15分52秒\ntags: [Spark]\ncategories: 大数据\ntoc: true\n---\n\n[TOC]\n\n# HelloWord？WorldCount\n\n```scala\nsc.textfile(\"hdfs://master:9000/wc\").flatMap(_.split(\"分隔符\")).map((_,1)).reduceByKey(_+_).saveAsTextFile(\"hdfs://master:9000/wcResult\")\n```\n\n\n数据最开始在Driver，计算的时候数据会流入worker\n当rdd形成过程中，worker的分区中只是预留了存放数据的位置，只有当action触发的时候，worker的分区中才会存在数据\n\nSpark的运算都是通过算子进行RDD的转换及运算，那我们对算子进行简单熟悉[参考RDD算子实例](http://homepage.cs.latrobe.edu.au/zhe/ZhenHeSparkRDDAPIExamples.html)\n\n<!-- more -->\n\n\n\n\n\nreduceByKey先进行一下combineer 移动计算\n\ngroupByKey不好\n\nreduceByKey会在局部先进行一下求和\n\ngroupByKey是会将所有的数据放在一个大集合里面，然后再求和 ，会消耗更多的网络带宽，不符合计算本地化\n\n\n\n\n\n一下一些RDD是给予rdd1来操作的\n\n```scala\nval rdd1 = sc.parallelize(List(1,2,3,4,5,6,7,8,9), 2)\n```\n\n\n\n## mapPartitions\n\nmap 是对 rdd 中的每一个元素进行操作，而 mapPartitions(foreachPartition) 则是对 rdd 中的每个分区的迭代器进行操作。如果在 map 过程中需要频繁创建额外的对象 (例如将 rdd 中的数据通过 jdbc 写入数据库, map 需要为每个元素创建一个链接而 mapPartition 为每个 partition 创建一个链接), 则 mapPartitions 效率比 map 高的多。\n\nSparkSql 或 DataFrame 默认会对程序进行 mapPartition 的优化。\n\n\n\n## mapPartitionsWithIndex\n\nmapPartitionWithIndex与mapPartition类似，只是会带上分区的序号\n\n把每个partition中的**分区号和对应的值**拿出来, 源码中方法的形式：\n\n```scala\nval func(index,Int,iter:Interator[(Int)]):Interator[String] = {\niter.toList.map(x => \"[partID:\" +  index + \", val: \" + x + \"]\").iterator\n}\n```\n\n会转换成函数 \n函数的形式\n\n```scala\nval func = (index: Int, iter: Iterator[(Int)]) => {\n  iter.toList.map(x => \"[partID:\" +  index + \", val: \" + x + \"]\").iterator\n}\nrdd1.mapPartitionsWithIndex(func).collect\n```\n\n![](https://ws3.sinaimg.cn/large/006tNbRwgy1fucjpo4afaj31ik056whp.jpg)\n\n## aggregate (action)\n\naggregate是一个action操作\n\n源码定义\n\n```scala\ndef aggregate[U](zeroValue: U)(seqOp: (U, T) ⇒ U, combOp: (U, U) ⇒ U)(implicit arg0: ClassTag[U]): U\n```\n\neqOp 操作会聚合各分区中的元素，然后 combOp 操作把所有分区的聚合结果再次聚合，两个操作的初始值都是 zeroValue.   seqOp 的操作是遍历分区中的所有元素 (T)，第一个 T 跟 zeroValue 做操作，结果再作为与第二个 T 做操作的 zeroValue，直到遍历完整个分区。combOp 操作是把各分区聚合的结果，再聚合。aggregate 函数返回一个跟 RDD 不同类型的值。因此，需要一个操作 seqOp 来把分区中的元素 T 合并成一个 U，另外一个操作 combOp 把所有 U 聚合。\n\n参考[理解 Spark RDD 中的 aggregate 函数](https://blog.csdn.net/qingyang0320/article/details/51603243)\n\n第一个参数：初始值（在进行操作的时候，会默认带入该值进行） \n第二个参数:   是两个函数[每个函数都是2个参数(第一个函数:先对各个分区进行合并, 第二个函数:对各个分区合并后的结果再进行合并)] \n\n最后得到返回值\n\n\n\n> rdd1为上面的rdd1分区函数的结果\n\n```scala\nrdd1.aggregate(0)(_+_, _+_)\n```\n\n**0 + (0+1+2+3+4 + 0+5+6+7+8+9)**\n\n![](https://ws4.sinaimg.cn/large/006tNbRwgy1fuck6fl2chj30kg02ut96.jpg)\n\n```scala\nrdd1.aggregate(7)(_+_, _+_)\n```\n\n**7 + (7+1+2+3+4 + 7+5+6+7+8+9)**\n\n![](https://ws4.sinaimg.cn/large/006tNbRwgy1fuck87fxhij30ju02gt92.jpg)\n\n\n\n```scala\nrdd1.aggregate(0)(math.max(_, _), _ + _)\n```\n\n![](https://ws4.sinaimg.cn/large/006tNbRwgy1fuck95wu88j30qo02o74x.jpg)\n\n\n\n```Scala\nrdd1.aggregate(5)(math.max(_, _), _ + _)\n```\n\n**5和1比, 得5再和234比得5 --> 5和6789比,得9 --> 5 + (5+9)**\n\n![](https://ws4.sinaimg.cn/large/006tNbRwgy1fucouprhcjj30s402yjs5.jpg)\n\n\n\n\n\n```scala\nval rdd2 = sc.parallelize(List(\"q\",\"w\",\"e\",\"r\",\"t\",\"y\",\"u\",\"i\",\"o\",\"p\"),2)\n```\n\n可以用更加直接的方式验证操作\n\n```Scala\ndef func2(index: Int, iter: Iterator[(String)]) : Iterator[String] = {\n  iter.toList.map(x => \"[partID:\" +  index + \", val: \" + x + \"]\").iterator\n}\n```\n\n```Scala\nrdd2.aggregate(\"\")(_ + _, _ + _)\nrdd2.aggregate(\"=\")(_ + _, _ + _)\nrdd2.aggregate(\"|\")(_ + _, _ + _)\n```\n\n![](https://ws1.sinaimg.cn/large/006tNbRwgy1fucpd6axxej30os034wf7.jpg)\n\n\n\n\n\n```scala\nval rdd3 = sc.parallelize(List(\"qazqqw7\",\"jishhrwe9\",\"sdfwezsddf12\",\"12esdww8\"),2)\nrdd3.aggregate(\"\")((x,y) => math.max(x.length, y.length).toString, (x,y) => x + y)\n```\n\n![](https://ws3.sinaimg.cn/large/006tNbRwgy1fucpvxoentj31gw03276d.jpg)\n\n\n\n```scala\nval rdd4 = sc.parallelize(List(\"qazqqw7\",\"jishhrwe9\",\"sdfwezsddf12\",\"\"),2)\nrdd4.aggregate(\"\")((x,y) => math.min(x.length, y.length).toString, (x,y) => x + y)\n```\n\n![](https://ws1.sinaimg.cn/large/006tNbRwgy1fucpwdi27nj31g8032abq.jpg)\n\n\n\n\n\n## aggregateByKey\n\n对每个分区进行计算\n\n```scala\nval pairRDD = sc.parallelize(List( (\"a\",1), (\"a\", 12), (\"b\", 4),(\"c\", 17), (\"c\", 12), (\"b\", 2)), 2)\ndef func2(index: Int, iter: Iterator[(String, Int)]) : Iterator[String] = {\n  iter.toList.map(x => \"[partID:\" +  index + \", val: \" + x + \"]\").iterator\n}\npairRDD.mapPartitionsWithIndex(func2).collect\n\n```\n\n## combineByKey\n\nreduceByKey aggregateByKey底层都是依赖的combineByKey，combineByKey比较底层的算子 \n和reduceByKey是相同的效果\n\n**combineByKey有三个参数**\n\n第一个参数x: **原封不动取出来**  第二个参数:**是函数, 局部运算**, 第三个:是函数, **对局部运算后的结果再做运算**\n\n\n\n```scala\nval rdd4 = sc.parallelize(List(\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\"),2)\nval rdd5 = sc.parallelize(List(1,1,2,2,2,1,2,2,2),2)\nval rdd6 = rdd5.zip(rdd4)\nval rdd7 = rdd6.combineByKey(List(_),(x:List[String],y:String)=>x:+y,(m:List[String],n:List[String])=>m ++ n)\nrdd7.collect\n```\n\n\n\n## reduceByKey\n\nreduceByKey 用于对每个 key 对应的多个 value 进行 merge 操作，最重要的是它能够在本地先进行 merge 操作，并且 merge 操作可以通过函数自定义。\n\n## groupByKey\n\ngroupByKey 也是对每个 key 进行操作，但只生成一个 sequence。不会再进行\n\n需要特别注意 “Note” 中的话，它告诉我们：如果需要对 sequence 进行 aggregation 操作（注意，groupByKey 本身不能自定义操作函数），那么，选择 reduceByKey/aggregateByKey 更好。这是因为 groupByKey 不能自定义函数，我们需要先用 groupByKey 生成 RDD，然后才能对此 RDD 通过 map 进行自定义函数操作。\n\n\n\n## checkpoint\n\n将rdd内容持久化\n\n```scala\nsc.setCheckpointDir(\"hdfs://master:9000/ck\")\nval rdd = sc.textFile(\"hdfs://master:9000/wc\").flatMap(_.split(\" \")).map((_, 1)).reduceByKey(_+_)\nrdd.checkpoint\nrdd.isCheckpointed\nrdd.count\nrdd.isCheckpointed\nrdd.getCheckpointFile\n\n```\n\n## coalesce, repartition\n\n有时候需要重新设置 Rdd 的分区数量，比如 Rdd 的分区中，Rdd 分区比较多，但是每个 Rdd 的数据量比较小，需要设置一个比较合理的分区。或者需要把 Rdd 的分区数量调大。还有就是通过设置一个 Rdd 的分区来达到设置生成的文件的数量。\n\n如果分区的数量发生激烈的变化，如设置 numPartitions = 1，这可能会造成运行计算的节点比你想象的要少，为了避免这个情况，可以设置 shuffle=true，\n\n那么这会增加 shuffle 操作。\n\n关于这个分区的激烈的变化情况，比如分区数量从父 Rdd 的几千个分区设置成几个，有可能会遇到这么一个错误。\n\n```\njava.io.IOException: Unable to acquire 16777216 bytes of memory\n```\n\n这个错误只要把 shuffle 设置成 true 即可解决。\n\n当把父 Rdd 的分区数量增大时，比如 Rdd 的分区是 100，设置成 1000，如果 shuffle 为 false，并不会起作用。\n\n这时候就需要设置 shuffle 为 true 了，那么 Rdd 将在 shuffle 之后返回一个 1000 个分区的 Rdd，数据分区方式默认是采用 hash partitioner。\n\n最后来看看 repartition() 方法的源码：\n\n\n\n\n\ncoalesce() 方法的作用是返回指定一个新的指定分区的 Rdd。\n\n\n\n```scala\nval rdd1 = sc.parallelize(1 to 10, 10)\nval rdd2 = rdd1.coalesce(2, false)\nrdd2.partitions.length\n\n```\n\n[](https://www.cnblogs.com/fillPv/p/5392186.html)\n\n## collectAsMap \n\n将其他集合保存为map结构\n\n```scala\nval rdd = sc.parallelize(List((\"a\", 1), (\"b\", 2)))\nrdd.collectAsMap\n得到结果\nMap(b -> 2, a -> 1)\n```\n\n\n\n## countByKey\n\n```scala\nval rdd1 = sc.parallelize(List((\"a\", 1), (\"b\", 2), (\"b\", 2), (\"c\", 2), (\"c\", 1)))\nrdd1.countByKey \n统计Key出现的次数\n结果 Map(b -> 2, a -> 1, c -> 2) \n```\n\n\n\n## countByValue\n\n```scala\nval rdd1 = sc.parallelize(List((\"a\", 1), (\"b\", 2), (\"b\", 2), (\"c\", 2), (\"c\", 1)))\nrdd1.countByValue\n结果 (将整个元组作为key)\nMap((b,2) -> 2, (c,2) -> 1, (a,1) -> 1, (c,1) -> 1)\n```\n\n\n\n\n\n## filterByRange\n\n```scala\nval rdd1 = sc.parallelize(List((\"a\", 5), (\"b\", 3), (\"c\", 4), (\"d\", 2), (\"e\", 1)))\nval rdd2 = rdd1.filterByRange(\"b\", \"d\")\nrdd2.collect\n\nArray[(String, Int)] = Array((b,3), (c,4), (d,2))\n\n```\n\n## flatMapValues \n\n压平\n\n```scala\nval rdd3 = sc.parallelize(List((\"a\", \"1 2\"), (\"b\", \"3 4\")))\nval rdd4 = rdd3.flatMapValues(_.split(\" \"))\nrdd4.collect\n\nArray[(String, String)] = Array((a,1), (a,2), (b,3), (b,4))\n\n```\n\n## foldByKey\n\n```scala\nval rdd1 = sc.parallelize(List(\"a22\", \"b232\", \"c\", \"d\"), 2)\nval rdd2 = rdd1.map(x => (x.length, x))\nrdd2.collect\n结果： Array[(Int, String)] = Array((3,a22), (4,b232), (1,c), (1,d))\n\nval rdd3 = rdd2.foldByKey(\"\")(_+_)\nrdd3.collect\n\n\n\n\n结果：将相同key的元组合并在一起，\nArray[(Int, String)] = Array((4,b232), (1,cd), (3,a22))\n\n```\n\n## foreach\n\nforeach是针对于每一个元素， \nforeachPartition是针对每一个分区， \nforeachPartition是写入数据库时，可以将在foreachPartition时获得一个数据库连接，通过map方法来将每个分区的全部元素写入到数据库\n\n## foreachPartition\n\n3个分区\n\n```scala\nval rdd1 = sc.parallelize(List(1, 2, 3, 4, 5, 6, 7, 8, 9), 3)\nrdd1.foreachPartition(x => println(x.reduce(_ + _)))\n\n```\n\n## keyBy\n\n以传入的参数做key\n\n```scala\nval rdd1 = sc.parallelize(List(\"dog\", \"salmon\", \"salmon\", \"rat\", \"elephant\"), 3)\nval rdd2 = rdd1.keyBy(_.length)\nrdd2.collect\n结果 Array((3,dog), (6,salmon), (6,salmon), (3,rat), (8,elephant))\n\n```\n\n## keys values\n\n```scala\nval rdd1 = sc.parallelize(List(\"dog\", \"tiger\", \"lion\", \"cat\", \"panther\", \"eagle\"), 2)\nval rdd2 = rdd1.map(x => (x.length, x))\nrdd2.keys.collect\nrdd2.values.collect\n```\n\n\n\n\n\n","slug":"Spark算子","published":1,"updated":"2018-08-20T01:44:42.481Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloj0lmi003xykpbcxxcv4l3"},{"title":"Spark读取HBase解析json创建临时表录入到Hive表","date":"2018-08-10T16:09:46.585Z","toc":true,"_content":"\n[TOC]\n\n![](https://ws1.sinaimg.cn/large/0069RVTdgy1fu81r6j5e5j30ji09c3z1.jpg)\n\n介绍：主要是读取通过mysql查到关联关系然后读取HBASE里面存放的Json，通过解析json将json数组对象里的元素拆分成单条json,再将json映射成临时表，查询临时表将数据落入到hive表中\n\n注意：查询HBASE的时候，HBase集群的HMaster，HRegionServer需要是正常运行\n\n主要将内容拆分成几块，spark读取HBase，spark解析json将json数组中每个元素拆成一条（比如json数组有10个元素，需要解析平铺成19个json，那么对应临时表中就是19条记录，对应查询插入到hive也就是19条记录）\n\nspark读取本地HBase\n\n<!-- more -->\n\n参考 [Spark读取HBase](http://www.gangtieguo.cn/2018/08/11/Spark读取Hbase/)\n\n# json样例\n\n![](https://ws1.sinaimg.cn/large/006tNbRwgy1fu53tng462j31721e6afd.jpg)\n\n\n\n# 读取hbase\n\nhbase里面存放的是身份id作为rowkey来存放的数据\n\n> JSON、JSONObject类包是引用的com.alibaba.fastjson包下的\n\n```scala\n val hbaseJsonRdd: RDD[String] = hbaseRDD.mapPartitions( it=>{\n      it.map(x=>x._2).map(hbaseValue => {\n        var listBuffer = new ListBuffer[String]()\n        //对应的值\n        //获取key,也就是身份证号，通过身份证号在广播map中的值 也就是risk_request_id\n        val idNum = Bytes.toString(hbaseValue.getRow)\n        val json: String = Bytes.toString(hbaseValue.getValue(Bytes.toBytes(\"cf\"), Bytes.toBytes(s\"273468436_data\")))\n        if (null != json ) {\n          //********************************获取到json之后进行解析********************************\n          try {\n            val jSONObject: JSONObject = JSON.parseObject(json)\n            if (jSONObject != null) {\n                val contactRegion = repostData.getJSONArray(\"contact_region\")\n                if (contactRegion != null) {\n                  contactRegion.toArray().foreach(v => {\n                    val arrays = JSON.parseObject(v.toString)\n                    //val map = JSON.toJavaObject(arrays,classOf[util.Map[String,String]])\n                    val map: mutable.Map[String, String] = JsonUtils.jsonObj2Map(arrays)\n                    //将json 转为Map\n                    //将******************************** 日期和requestId request_id封装到 map里面********************************，再将map转为json\n                    map.put(\"region_id\", \"2\")\n                    map.put(\"request_id\", \"1\")\n                    map.put(\"region_create_at\", \"0000\")\n                    map.put(\"region_update_at\", \"0000\")\n                    listBuffer += (JsonUtils.map2Json(map))\n                  })\n                }\n              }\n            }\n          }catch {\n            case e: Exception => e.printStackTrace()\n          }\n        }\n        listBuffer\n      })\n    }).flatMap(r => r)\n```\n\n代码中的 jsonObj2Map,map2Json 方法参照 [Json与Scala类型的相互转换处理](http://www.gangtieguo.cn/2018/08/11/Json与Scala类型的一些互相转换处理/)\n\n这里拆分json数组每一个元素为一个json，存放在ListBuffer里面，通过flatMap压平rdd里面的内容。\n\n# 映射临时表\n\n最后将得到的json通过sparkSql创建成临时表\n\n```scala\n val dataFrame: DataFrame = sqlContext.read.json(hbaseJsonRdd)\ndataFrame.createOrReplaceTempView(\"tmp_hbase\")\n//// 测试\n\nprintln(\"++++++++++++++++++++++++++++++hbaseJsonRdd.....创建临时表 测试查询数据  ......++++++++++++++++++++++++++++++\")\nval df = sqlContext.sql(\"select * from tmp_hbase limit 1\")\ndf.show(1)\n```\n\n# 插入Hive\n\n```scala\nsqlContext.sql(\"insert into ods.ods_r_juxinli_region_n partition(dt='20180101') select region_id as juxinli_region_id,request_id as juxinli_request_id,\" +\n        \"region_loc as juxinli_rejion_loc ,region_uniq_num_cnt as juxinli_region_uniq_num_cnt ,\" +\n        \"region_call_out_time as juxinli_region_call_out_time,region_call_in_time as juxinli_region_call_in_time,region_call_out_cnt as juxinli_region_call_out_cnt,\" +\n        \"region_call_in_cnt as juxinli_region_call_in_cnt,region_avg_call_in_time as juxinli_region_avg_call_in_time,region_avg_call_out_time as juxinli_region_avg_call_out_time,\" +\n        \"region_call_in_time_pct as juxinli_region_call_in_time_pct,region_call_out_time_pct as juxinli_region_call_out_time_pct ,region_call_in_cnt_pct as juxinli_region_call_in_cnt_pct,\" +\n        \"region_call_out_cnt_pct as juxinli_region_call_out_cnt_pct,region_create_at as juxinli_region_create_at,region_update_at as juxinli_region_update_at from tmp_hbase\")\n    }\n```\n\n**关闭资源**\n\n```scala\nsparkContext.stop()\nsparkSession.close()\n```","source":"_posts/Spark读取HBase解析json创建临时表录入到Hive表.md","raw":"---\ntitle: Spark读取HBase解析json创建临时表录入到Hive表\ndate: 2018年08月06日 22时15分52秒\ntags: [Spark,SparkSQL]\ncategories: 大数据\ntoc: true\n---\n\n[TOC]\n\n![](https://ws1.sinaimg.cn/large/0069RVTdgy1fu81r6j5e5j30ji09c3z1.jpg)\n\n介绍：主要是读取通过mysql查到关联关系然后读取HBASE里面存放的Json，通过解析json将json数组对象里的元素拆分成单条json,再将json映射成临时表，查询临时表将数据落入到hive表中\n\n注意：查询HBASE的时候，HBase集群的HMaster，HRegionServer需要是正常运行\n\n主要将内容拆分成几块，spark读取HBase，spark解析json将json数组中每个元素拆成一条（比如json数组有10个元素，需要解析平铺成19个json，那么对应临时表中就是19条记录，对应查询插入到hive也就是19条记录）\n\nspark读取本地HBase\n\n<!-- more -->\n\n参考 [Spark读取HBase](http://www.gangtieguo.cn/2018/08/11/Spark读取Hbase/)\n\n# json样例\n\n![](https://ws1.sinaimg.cn/large/006tNbRwgy1fu53tng462j31721e6afd.jpg)\n\n\n\n# 读取hbase\n\nhbase里面存放的是身份id作为rowkey来存放的数据\n\n> JSON、JSONObject类包是引用的com.alibaba.fastjson包下的\n\n```scala\n val hbaseJsonRdd: RDD[String] = hbaseRDD.mapPartitions( it=>{\n      it.map(x=>x._2).map(hbaseValue => {\n        var listBuffer = new ListBuffer[String]()\n        //对应的值\n        //获取key,也就是身份证号，通过身份证号在广播map中的值 也就是risk_request_id\n        val idNum = Bytes.toString(hbaseValue.getRow)\n        val json: String = Bytes.toString(hbaseValue.getValue(Bytes.toBytes(\"cf\"), Bytes.toBytes(s\"273468436_data\")))\n        if (null != json ) {\n          //********************************获取到json之后进行解析********************************\n          try {\n            val jSONObject: JSONObject = JSON.parseObject(json)\n            if (jSONObject != null) {\n                val contactRegion = repostData.getJSONArray(\"contact_region\")\n                if (contactRegion != null) {\n                  contactRegion.toArray().foreach(v => {\n                    val arrays = JSON.parseObject(v.toString)\n                    //val map = JSON.toJavaObject(arrays,classOf[util.Map[String,String]])\n                    val map: mutable.Map[String, String] = JsonUtils.jsonObj2Map(arrays)\n                    //将json 转为Map\n                    //将******************************** 日期和requestId request_id封装到 map里面********************************，再将map转为json\n                    map.put(\"region_id\", \"2\")\n                    map.put(\"request_id\", \"1\")\n                    map.put(\"region_create_at\", \"0000\")\n                    map.put(\"region_update_at\", \"0000\")\n                    listBuffer += (JsonUtils.map2Json(map))\n                  })\n                }\n              }\n            }\n          }catch {\n            case e: Exception => e.printStackTrace()\n          }\n        }\n        listBuffer\n      })\n    }).flatMap(r => r)\n```\n\n代码中的 jsonObj2Map,map2Json 方法参照 [Json与Scala类型的相互转换处理](http://www.gangtieguo.cn/2018/08/11/Json与Scala类型的一些互相转换处理/)\n\n这里拆分json数组每一个元素为一个json，存放在ListBuffer里面，通过flatMap压平rdd里面的内容。\n\n# 映射临时表\n\n最后将得到的json通过sparkSql创建成临时表\n\n```scala\n val dataFrame: DataFrame = sqlContext.read.json(hbaseJsonRdd)\ndataFrame.createOrReplaceTempView(\"tmp_hbase\")\n//// 测试\n\nprintln(\"++++++++++++++++++++++++++++++hbaseJsonRdd.....创建临时表 测试查询数据  ......++++++++++++++++++++++++++++++\")\nval df = sqlContext.sql(\"select * from tmp_hbase limit 1\")\ndf.show(1)\n```\n\n# 插入Hive\n\n```scala\nsqlContext.sql(\"insert into ods.ods_r_juxinli_region_n partition(dt='20180101') select region_id as juxinli_region_id,request_id as juxinli_request_id,\" +\n        \"region_loc as juxinli_rejion_loc ,region_uniq_num_cnt as juxinli_region_uniq_num_cnt ,\" +\n        \"region_call_out_time as juxinli_region_call_out_time,region_call_in_time as juxinli_region_call_in_time,region_call_out_cnt as juxinli_region_call_out_cnt,\" +\n        \"region_call_in_cnt as juxinli_region_call_in_cnt,region_avg_call_in_time as juxinli_region_avg_call_in_time,region_avg_call_out_time as juxinli_region_avg_call_out_time,\" +\n        \"region_call_in_time_pct as juxinli_region_call_in_time_pct,region_call_out_time_pct as juxinli_region_call_out_time_pct ,region_call_in_cnt_pct as juxinli_region_call_in_cnt_pct,\" +\n        \"region_call_out_cnt_pct as juxinli_region_call_out_cnt_pct,region_create_at as juxinli_region_create_at,region_update_at as juxinli_region_update_at from tmp_hbase\")\n    }\n```\n\n**关闭资源**\n\n```scala\nsparkContext.stop()\nsparkSession.close()\n```","slug":"Spark读取HBase解析json创建临时表录入到Hive表","published":1,"updated":"2018-08-13T06:16:38.124Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloj0lmj0040ykpbp5td5xiy"},{"title":"Spark读取HBase","date":"2018-08-10T16:18:11.706Z","toc":true,"_content":"\n[TOC]\n\n![](https://ws1.sinaimg.cn/large/006tNbRwgy1fu552ugvkxj30ys0han0l.jpg)\n\nSpark读取Hbase\n\n<!-- more -->\n\n# spark配置\n\n首先spark的配置\n\n```scala\nval array = Array(\n      (\"spark.serializer\", \"org.apache.spark.serializer.KryoSerializer\"),\n      (\"spark.storage.memoryFraction\", \"0.3\"),\n      (\"spark.memory.useLegacyMode\", \"true\"),\n      (\"spark.shuffle.memoryFraction\", \"0.6\"),\n      (\"spark.shuffle.file.buffer\", \"128k\"),\n      (\"spark.reducer.maxSizeInFlight\", \"96m\"),\n      (\"spark.sql.shuffle.partitions\", \"500\"),\n      (\"spark.default.parallelism\", \"180\"),\n      (\"spark.dynamicAllocation.enabled\", \"false\")\n    )\n    val conf = new SparkConf().setAll(array)\n      .setJars(Array(\"your.jar\"))\n    val sparkSession: SparkSession = SparkSession\n      .builder\n      .appName(applicationName)\n      .enableHiveSupport()\n      .master(\"spark://master:7077\")\n      .config(conf)\n      .getOrCreate()\n    val sqlContext = sparkSession.sqlContext\n    val sparkContext: SparkContext = sparkSession.sparkContext\n\n```\n\n# Hbase配置\n\n```scala\nval hBaseConf = HBaseConfiguration.create()\n\nvar scan = new Scan();\nscan.addFamily(Bytes.toBytes(\"cf\"));\nvar proto = ProtobufUtil.toScan(scan)\nvar scanToString = Base64.encodeBytes(proto.toByteArray())\n//以为全局扫描的方式\nhBaseConf.set(TableInputFormat.SCAN,scanToString)\n//如需要设置起止行的话\n//scan.setStartRow(Bytes.toBytes(\"1111111111111\"))\n//scan.setStopRow(Bytes.toBytes(\"999999999999999\"))\nhBaseConf.set(\"hbase.zookeeper.quorum\",\"zk1,zk2,zk3\")\nhBaseConf.set(\"phoenix.query.timeoutMs\",\"1800000\")\nhBaseConf.set(\"hbase.regionserver.lease.period\",\"1200000\")\nhBaseConf.set(\"hbase.rpc.timeout\",\"1200000\")\nhBaseConf.set(\"hbase.client.scanner.caching\",\"1000\")\nhBaseConf.set(\"hbase.client.scanner.timeout.period\",\"1200000\")\n//表名配置\nhBaseConf.set(TableInputFormat.INPUT_TABLE,\"beehive:a_up_rawdata\")\n// 从数据源获取数据\nval hbaseRDD = sparkContext.newAPIHadoopRDD(hBaseConf,classOf[TableInputFormat],classOf[org.apache.hadoop.hbase.io.ImmutableBytesWritable],classOf[org.apache.hadoop.hbase.client.Result])\n//即可得到读取Hbase查询的RDD\n val hbaseJsonRdd: RDD[String] = hbaseRDD.filter(t =>\n        broadCast.value.contains(Bytes.toString(t._2.getRow))\n      //********************************操作每个分区的数据********************************\n    ).mapPartitions( it=>{\n      it.map(x=>x._2).map(hbaseValue => {\n        var listBuffer = new ListBuffer[String]()\n        //对应的值\n        val rowkey = Bytes.toString(hbaseValue.getRow)\n        val value: String = Bytes.toString(hbaseValue.getValue(Bytes.toBytes(\"cf\"), Bytes.toBytes(\"填写获取哪一列\")))\n        if (null != value ) {\n          //如果value不为空则再进行操作\n        }\n        listBuffer\n\n      })\n    }).flatMap(r => r)\n\n//注意map操作是需要函数内部有返回值的，如果只是打印的话，换成foreach算子\n    println(s\"hbaseJsonRdd.size为：${hbaseJsonRdd.count()}\")\n    sparkContext.stop()\n    sparkSession.close()\n    println(\"ALL 已经关闭，程序终止\")\n```\n\n\n\n\n\n","source":"_posts/Spark读取Hbase.md","raw":"---\ntitle: Spark读取HBase\ndate: 2018年08月06日 22时15分52秒\ntags: [Spark,HBase]\ncategories: 大数据\ntoc: true\n---\n\n[TOC]\n\n![](https://ws1.sinaimg.cn/large/006tNbRwgy1fu552ugvkxj30ys0han0l.jpg)\n\nSpark读取Hbase\n\n<!-- more -->\n\n# spark配置\n\n首先spark的配置\n\n```scala\nval array = Array(\n      (\"spark.serializer\", \"org.apache.spark.serializer.KryoSerializer\"),\n      (\"spark.storage.memoryFraction\", \"0.3\"),\n      (\"spark.memory.useLegacyMode\", \"true\"),\n      (\"spark.shuffle.memoryFraction\", \"0.6\"),\n      (\"spark.shuffle.file.buffer\", \"128k\"),\n      (\"spark.reducer.maxSizeInFlight\", \"96m\"),\n      (\"spark.sql.shuffle.partitions\", \"500\"),\n      (\"spark.default.parallelism\", \"180\"),\n      (\"spark.dynamicAllocation.enabled\", \"false\")\n    )\n    val conf = new SparkConf().setAll(array)\n      .setJars(Array(\"your.jar\"))\n    val sparkSession: SparkSession = SparkSession\n      .builder\n      .appName(applicationName)\n      .enableHiveSupport()\n      .master(\"spark://master:7077\")\n      .config(conf)\n      .getOrCreate()\n    val sqlContext = sparkSession.sqlContext\n    val sparkContext: SparkContext = sparkSession.sparkContext\n\n```\n\n# Hbase配置\n\n```scala\nval hBaseConf = HBaseConfiguration.create()\n\nvar scan = new Scan();\nscan.addFamily(Bytes.toBytes(\"cf\"));\nvar proto = ProtobufUtil.toScan(scan)\nvar scanToString = Base64.encodeBytes(proto.toByteArray())\n//以为全局扫描的方式\nhBaseConf.set(TableInputFormat.SCAN,scanToString)\n//如需要设置起止行的话\n//scan.setStartRow(Bytes.toBytes(\"1111111111111\"))\n//scan.setStopRow(Bytes.toBytes(\"999999999999999\"))\nhBaseConf.set(\"hbase.zookeeper.quorum\",\"zk1,zk2,zk3\")\nhBaseConf.set(\"phoenix.query.timeoutMs\",\"1800000\")\nhBaseConf.set(\"hbase.regionserver.lease.period\",\"1200000\")\nhBaseConf.set(\"hbase.rpc.timeout\",\"1200000\")\nhBaseConf.set(\"hbase.client.scanner.caching\",\"1000\")\nhBaseConf.set(\"hbase.client.scanner.timeout.period\",\"1200000\")\n//表名配置\nhBaseConf.set(TableInputFormat.INPUT_TABLE,\"beehive:a_up_rawdata\")\n// 从数据源获取数据\nval hbaseRDD = sparkContext.newAPIHadoopRDD(hBaseConf,classOf[TableInputFormat],classOf[org.apache.hadoop.hbase.io.ImmutableBytesWritable],classOf[org.apache.hadoop.hbase.client.Result])\n//即可得到读取Hbase查询的RDD\n val hbaseJsonRdd: RDD[String] = hbaseRDD.filter(t =>\n        broadCast.value.contains(Bytes.toString(t._2.getRow))\n      //********************************操作每个分区的数据********************************\n    ).mapPartitions( it=>{\n      it.map(x=>x._2).map(hbaseValue => {\n        var listBuffer = new ListBuffer[String]()\n        //对应的值\n        val rowkey = Bytes.toString(hbaseValue.getRow)\n        val value: String = Bytes.toString(hbaseValue.getValue(Bytes.toBytes(\"cf\"), Bytes.toBytes(\"填写获取哪一列\")))\n        if (null != value ) {\n          //如果value不为空则再进行操作\n        }\n        listBuffer\n\n      })\n    }).flatMap(r => r)\n\n//注意map操作是需要函数内部有返回值的，如果只是打印的话，换成foreach算子\n    println(s\"hbaseJsonRdd.size为：${hbaseJsonRdd.count()}\")\n    sparkContext.stop()\n    sparkSession.close()\n    println(\"ALL 已经关闭，程序终止\")\n```\n\n\n\n\n\n","slug":"Spark读取Hbase","published":1,"updated":"2018-08-10T17:56:47.563Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloj0lml0045ykpbjo7jgagw"},{"title":"ELK容器的搭建","date":"2018-07-08T15:43:05.950Z","toc":true,"typora-copy-images-to":"ipic","_content":"\n[TOC]\n\n![](https://ws3.sinaimg.cn/large/006tNbRwgy1fu54yue2cxj31g20q875x.jpg)\n\n## 来源容器  elk\n\n新建容器，为减少工作量，引用的是有ssh服务的Docker镜像**kinogmt/centos-ssh:6.7**，生成容器os为基准。\n\n```\ndocker run -itd  --name elk --hostname elk kinogmt/centos-ssh:6.7 &> /dev/null\n```\n\n> 注意必须要以-d方式启动，不然sshd服务不会启动，这算是一个小bug\n\n<!--more-->\n\n在容器中下载需要的elk的源包。做解压就不赘述，很多案例教程。\n\n> 我是采用的下载到宿主机，解压后，用 \"docker cp 解压包目录  os:/usr/loca/\"来传到容器内，比在容器内下载速度更快\n\n\n\n\n## 设置Home\n `vim   ~/bashrc`\n\n```bash\nexport ES_HOME=/usr/es\nexport PATH=$ES_HOME/bin:$PATH\nexport KIBANA_HOME=/usr/kibana\nexport PATH=$KIBANA_HOME/bin:$PATH\nexport LOGSTASH_HOME=/usr/logstash\nexport PATH=$LOGSTASH_HOME/bin:$PATH\nexport NODE_HOME=/usr/node\nexport PATH=$NODE_HOME/bin:$PATH\nexport NODE_PATH=$NODE_HOME/lib/node_modules\n```\n`source ~/.bashrc`\n\n## 安装插件header\n\n### 安装nodejs\n\n一般预装的版本不对\n\n```\nyum erase nodejs npm -y   # 卸载旧版本的nodejs\nrpm -qa 'node|npm' | grep -v nodesource # 确认nodejs是否卸载干净\nyum install nodejs -y # 安装npm 安装的版本会有不对\n```\n\n下载合适版本\n\n```bash\ncd /usr\nwget https://npm.taobao.org/mirrors/node/latest-v4.x/node-v4.4.7-llinux-x64.tar.gz\ntar -zxvf node-v4.4.7-linux-x64.tar.gz\nmv node-v8.9.1-linux-x64 node\n```\n直接将node目录配置到home即可\n\n```\nexport NODE_HOME=/usr/node\nexport PATH=$NODE_HOME/bin:$PATH \n```\n\n\n\n### 下载 header，安装grunt\n\n（所有命令在hear的所在目录执行）\n\n`wget https://github.com/mobz/elasticsearch-head/archive/master.zip `\n\n`unzip master.zip`\n\n看当前 head 插件目录下有无 node_modules/grunt 目录： \n没有：执行命令创建：\n\n```\nnpm install grunt --save\n```\n\n安装 grunt： \ngrunt 是基于 Node.js 的项目构建工具，可以进行打包压缩、测试、执行等等的工作，head 插件就是通过 grunt 启动\n\n```\nnpm install -g grunt-cli\n```\n\n参考https://blog.csdn.net/ggwxk1990/article/details/78698648\n\n npm install 安装所下载的header包 \n\n```\nnpm install\n```\n\n\n\n## header启动\n\n在 elasticsearch-head-master 目录下\n\n```\ngrunt server  或者 npm run start\n```\n\n\n\n## els不能通过root启动，创建用户\n\n\tuseradd elk\n\tgroupadd elk\n\tusermod -a -G elk elk\n\t\n\techo elk | passwd --stdin elk\n\n将elk添加到sudoers\n\n\techo \"elk ALL = (root) NOPASSWD:ALL\" | tee /etc/sudoers.d/elk\n\tchmod 0440 /etc/sudoers.d/elk\n\n解决sudo: sorry, you must have a tty to run sudo问题，在/etc/sudoer注释掉 Default requiretty 一行\n\tsudo sed -i 's/Defaults requiretty/Defaults:elk !requiretty/' /etc/sudoers\n\n\n\n### 修改文件所有者\n`chown -R elk:elk /usr/es/`\n\n**设置资源参数**\n\n```\n  sudo vim  /etc/security/limits.d/90-nproc.conf\n```\n\n\n**添加**\n\t elk        soft    nproc     4096\n   <!-- 更改docker-machine的资源 -->\n```\ndocker-machine ssh\nsysctl -w vm.max_map_count=655360\n```\n\n### es启动脚本\n\n    单机 su elk -c \"$ES_HOME/bin/elasticsearch -d\"\n    ssh elk@elk1 \" $ES_HOME/bin/elasticsearch -d\"\n    ssh root@elk1 \" su elk -c  $ES_HOME/bin/elasticsearch \"\n\n\n\n### 集群\n#### elasticSearch\n脚本 `vim  es-start.sh`\n\n```bash\n#!/bin/bash\nsed -i '6c node.name: es1 '\n$ES_HOME/config/elasticsearch.yml\nsu - elk -c  \"$ES_HOME/bin/elasticsearch -d\"\nssh root@elk2 \"sed -i '6c node.name: es2 ' $ES_HOME/config/elasticsearch.yml\"\nssh root@elk2 ' su - elk -c  \"$ES_HOME/bin/elasticsearch -d\" '\nssh root@elk3 \"sed -i '6c node.name: es3 ' $ES_HOME/config/elasticsearch.yml\"\nssh root@elk3 ' su - elk -c  \"$ES_HOME/bin/elasticsearch -d\" '\n```\n#### kibana\n启动单机（只需要启动单机） `bin/kibana`\n```bash\n#!/bin/bash\nsed -i '3c http://elk1:9200 '\n$KIBANA_HOME/config/kibana.yml\nnohup $KIBANA_HOME/bin/kibana  &\nssh root@elk2 \"sed -i '3c http://elk2:9200 ' $KIBANA_HOME/config/kibana.yml\"\nssh root@elk2 \"nohup $KIBANA_HOME/bin/kibana & \"\nssh root@elk3 \"sed -i '3c   http://elk3:9200 ' $KIBANA_HOME/config/kibana.yml\"\nssh root@elk3 \"nohup $KIBANA_HOME/bin/kibana & \"\n```\n#### logstash\n单机启动   `$LOGSTASH_HOME/bin/logstash -f logstash.conf`\n `$LOGSTASH_HOME/bin/logstash -f 配置文件的目录`\n\b\n\n集群启动脚本 **logstash-start.sh**\n```shell\n#!/bin/bash\nnohup $LOGSTASH_HOME/bin/logstash -f  $LOGSTASH_HOME/conf/$1  &\nssh root@elk2 \"nohup $LOGSTASH_HOME/bin/logstash -f  $LOGSTASH_HOME/conf/$1 & \"\nssh root@elk3 \"nohup $LOGSTASH_HOME/bin/logstash -f  $LOGSTASH_HOME/conf/$1 & \"\n```\n\n\n\n## 保存容器为镜像\n\n```bash\ndocker commit -m \"elk镜像\"  --author=\"yaosong\"  os  yaosong5/elk:1.0\n```\n\n\n\n## 生成elk 容器\n\n```shell\ndocker run -itd --net=br --name elk1 --hostname elk1 yaosong5/elk:1.0 &> /dev/null\ndocker run -itd --net=br --name elk2 --hostname elk2 yaosong5/elk:1.0 &> /dev/null\ndocker run -itd --net=br --name elk3 --hostname elk3 yaosong5/elk:1.0 &> /dev/null\n```\n\n\n\n### 停止/删除elk 容器\n\n```shell\ndocker stop elk1\ndocker stop elk2\ndocker stop elk3\n\ndocker rm elk1\ndocker rm elk2\ndocker rm elk3\n```\n## 参考\n## elk 操作命令\n### es操作命令\nhttp://www.yfshare.vip/2017/11/04/%E9%83%A8%E7%BD%B2FileBeat-logstash-elasticsearch%E9%9B%86%E7%BE%A4-kibana/#%E9%85%8D%E7%BD%AE-filebeart\n\n\n\n## 其他\nyum erase nodejs npm -y   # 卸载旧版本的nodejs\nrpm -qa 'node|npm' | grep -v nodesource # 确认nodejs是否卸载干净\nyum install nodejs -y\n","source":"_posts/elk容器的搭建.md","raw":"---\ntitle:  ELK容器的搭建\ndate: 2018年08月06日 22时15分52秒\ntags:  [ELK,Docker]\ncategories: 安装部署\ntoc: true\ntypora-copy-images-to: ipic\n---\n\n[TOC]\n\n![](https://ws3.sinaimg.cn/large/006tNbRwgy1fu54yue2cxj31g20q875x.jpg)\n\n## 来源容器  elk\n\n新建容器，为减少工作量，引用的是有ssh服务的Docker镜像**kinogmt/centos-ssh:6.7**，生成容器os为基准。\n\n```\ndocker run -itd  --name elk --hostname elk kinogmt/centos-ssh:6.7 &> /dev/null\n```\n\n> 注意必须要以-d方式启动，不然sshd服务不会启动，这算是一个小bug\n\n<!--more-->\n\n在容器中下载需要的elk的源包。做解压就不赘述，很多案例教程。\n\n> 我是采用的下载到宿主机，解压后，用 \"docker cp 解压包目录  os:/usr/loca/\"来传到容器内，比在容器内下载速度更快\n\n\n\n\n## 设置Home\n `vim   ~/bashrc`\n\n```bash\nexport ES_HOME=/usr/es\nexport PATH=$ES_HOME/bin:$PATH\nexport KIBANA_HOME=/usr/kibana\nexport PATH=$KIBANA_HOME/bin:$PATH\nexport LOGSTASH_HOME=/usr/logstash\nexport PATH=$LOGSTASH_HOME/bin:$PATH\nexport NODE_HOME=/usr/node\nexport PATH=$NODE_HOME/bin:$PATH\nexport NODE_PATH=$NODE_HOME/lib/node_modules\n```\n`source ~/.bashrc`\n\n## 安装插件header\n\n### 安装nodejs\n\n一般预装的版本不对\n\n```\nyum erase nodejs npm -y   # 卸载旧版本的nodejs\nrpm -qa 'node|npm' | grep -v nodesource # 确认nodejs是否卸载干净\nyum install nodejs -y # 安装npm 安装的版本会有不对\n```\n\n下载合适版本\n\n```bash\ncd /usr\nwget https://npm.taobao.org/mirrors/node/latest-v4.x/node-v4.4.7-llinux-x64.tar.gz\ntar -zxvf node-v4.4.7-linux-x64.tar.gz\nmv node-v8.9.1-linux-x64 node\n```\n直接将node目录配置到home即可\n\n```\nexport NODE_HOME=/usr/node\nexport PATH=$NODE_HOME/bin:$PATH \n```\n\n\n\n### 下载 header，安装grunt\n\n（所有命令在hear的所在目录执行）\n\n`wget https://github.com/mobz/elasticsearch-head/archive/master.zip `\n\n`unzip master.zip`\n\n看当前 head 插件目录下有无 node_modules/grunt 目录： \n没有：执行命令创建：\n\n```\nnpm install grunt --save\n```\n\n安装 grunt： \ngrunt 是基于 Node.js 的项目构建工具，可以进行打包压缩、测试、执行等等的工作，head 插件就是通过 grunt 启动\n\n```\nnpm install -g grunt-cli\n```\n\n参考https://blog.csdn.net/ggwxk1990/article/details/78698648\n\n npm install 安装所下载的header包 \n\n```\nnpm install\n```\n\n\n\n## header启动\n\n在 elasticsearch-head-master 目录下\n\n```\ngrunt server  或者 npm run start\n```\n\n\n\n## els不能通过root启动，创建用户\n\n\tuseradd elk\n\tgroupadd elk\n\tusermod -a -G elk elk\n\t\n\techo elk | passwd --stdin elk\n\n将elk添加到sudoers\n\n\techo \"elk ALL = (root) NOPASSWD:ALL\" | tee /etc/sudoers.d/elk\n\tchmod 0440 /etc/sudoers.d/elk\n\n解决sudo: sorry, you must have a tty to run sudo问题，在/etc/sudoer注释掉 Default requiretty 一行\n\tsudo sed -i 's/Defaults requiretty/Defaults:elk !requiretty/' /etc/sudoers\n\n\n\n### 修改文件所有者\n`chown -R elk:elk /usr/es/`\n\n**设置资源参数**\n\n```\n  sudo vim  /etc/security/limits.d/90-nproc.conf\n```\n\n\n**添加**\n\t elk        soft    nproc     4096\n   <!-- 更改docker-machine的资源 -->\n```\ndocker-machine ssh\nsysctl -w vm.max_map_count=655360\n```\n\n### es启动脚本\n\n    单机 su elk -c \"$ES_HOME/bin/elasticsearch -d\"\n    ssh elk@elk1 \" $ES_HOME/bin/elasticsearch -d\"\n    ssh root@elk1 \" su elk -c  $ES_HOME/bin/elasticsearch \"\n\n\n\n### 集群\n#### elasticSearch\n脚本 `vim  es-start.sh`\n\n```bash\n#!/bin/bash\nsed -i '6c node.name: es1 '\n$ES_HOME/config/elasticsearch.yml\nsu - elk -c  \"$ES_HOME/bin/elasticsearch -d\"\nssh root@elk2 \"sed -i '6c node.name: es2 ' $ES_HOME/config/elasticsearch.yml\"\nssh root@elk2 ' su - elk -c  \"$ES_HOME/bin/elasticsearch -d\" '\nssh root@elk3 \"sed -i '6c node.name: es3 ' $ES_HOME/config/elasticsearch.yml\"\nssh root@elk3 ' su - elk -c  \"$ES_HOME/bin/elasticsearch -d\" '\n```\n#### kibana\n启动单机（只需要启动单机） `bin/kibana`\n```bash\n#!/bin/bash\nsed -i '3c http://elk1:9200 '\n$KIBANA_HOME/config/kibana.yml\nnohup $KIBANA_HOME/bin/kibana  &\nssh root@elk2 \"sed -i '3c http://elk2:9200 ' $KIBANA_HOME/config/kibana.yml\"\nssh root@elk2 \"nohup $KIBANA_HOME/bin/kibana & \"\nssh root@elk3 \"sed -i '3c   http://elk3:9200 ' $KIBANA_HOME/config/kibana.yml\"\nssh root@elk3 \"nohup $KIBANA_HOME/bin/kibana & \"\n```\n#### logstash\n单机启动   `$LOGSTASH_HOME/bin/logstash -f logstash.conf`\n `$LOGSTASH_HOME/bin/logstash -f 配置文件的目录`\n\b\n\n集群启动脚本 **logstash-start.sh**\n```shell\n#!/bin/bash\nnohup $LOGSTASH_HOME/bin/logstash -f  $LOGSTASH_HOME/conf/$1  &\nssh root@elk2 \"nohup $LOGSTASH_HOME/bin/logstash -f  $LOGSTASH_HOME/conf/$1 & \"\nssh root@elk3 \"nohup $LOGSTASH_HOME/bin/logstash -f  $LOGSTASH_HOME/conf/$1 & \"\n```\n\n\n\n## 保存容器为镜像\n\n```bash\ndocker commit -m \"elk镜像\"  --author=\"yaosong\"  os  yaosong5/elk:1.0\n```\n\n\n\n## 生成elk 容器\n\n```shell\ndocker run -itd --net=br --name elk1 --hostname elk1 yaosong5/elk:1.0 &> /dev/null\ndocker run -itd --net=br --name elk2 --hostname elk2 yaosong5/elk:1.0 &> /dev/null\ndocker run -itd --net=br --name elk3 --hostname elk3 yaosong5/elk:1.0 &> /dev/null\n```\n\n\n\n### 停止/删除elk 容器\n\n```shell\ndocker stop elk1\ndocker stop elk2\ndocker stop elk3\n\ndocker rm elk1\ndocker rm elk2\ndocker rm elk3\n```\n## 参考\n## elk 操作命令\n### es操作命令\nhttp://www.yfshare.vip/2017/11/04/%E9%83%A8%E7%BD%B2FileBeat-logstash-elasticsearch%E9%9B%86%E7%BE%A4-kibana/#%E9%85%8D%E7%BD%AE-filebeart\n\n\n\n## 其他\nyum erase nodejs npm -y   # 卸载旧版本的nodejs\nrpm -qa 'node|npm' | grep -v nodesource # 确认nodejs是否卸载干净\nyum install nodejs -y\n","slug":"elk容器的搭建","published":1,"updated":"2018-08-10T17:50:32.279Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloj0lmo0048ykpb26y9dnd6"},{"title":"FLINK容器的搭建","date":"2018-07-08T16:00:22.635Z","toc":true,"typora-copy-images-to":"ipic","_content":"\n[TOC]\n\n\n\n\n\n# 来源容器  flk\n\n新建容器，为减少工作量，引用的是有ssh服务的Docker镜像**kinogmt/centos-ssh:6.7**，生成容器os为基准。\n\n```\ndocker run -itd  --name flk --hostname flk kinogmt/centos-ssh:6.7 &> /dev/null\n```\n\n> 注意必须要以-d方式启动，不然sshd服务不会启动，这算是一个小bug\n\n<!--more-->\n\n在容器中下载需要的elk的源包。做解压就不赘述，很多案例教程。\n\n> 我是采用的下载到宿主机，解压后，用 \"docker cp 解压包目录  os:/usr/loca/\"来传到容器内，比在容器内下载速度更快\n>\n> ## 复制源包\n>\n> ```\n> docker cp /Users/yaosong/Yao/hadoop  flk:/usr/\n> docker cp /Users/yaosong/Yao/flink  flk:/usr/\n> ```\n\n\n\n\n\n# 配置home\n\n\n\texport JAVA_HOME=/usr/java/jdk1.8.0_144/\n\texport PATH=$JAVA_HOME/bin:$PATH\n\texport FLINK_HOME=/usr/flink\n\texport HADOOP_HOME=/usr/hadoop\n\texport HADOOP_CONFIG_HOME=$HADOOP_HOME/etc/hadoop\n\texport HADOOP_CONF_DIR=$HADOOP_HOME/etc/hadoop\n\texport PATH=$PATH:$HADOOP_HOME/bin\n\texport PATH=$PATH:$HADOOP_HOME/sbin\n\texport PATH=$PATH:$FLINK_HOME/bin\n\n**配置hadoop**  参考：\n\n[]: http://gangtieguo.cn/2018/07/20/Docker%E4%B8%ADhadoop%20spark%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/\t\"Docker 中 hadoop，spark 镜像搭建\"\n\n\n\n**flink.yml**\n\n```\n high-availability: zookeeper\n\n# The path where metadata for master recovery is persisted. While ZooKeeper stores\n# the small ground truth for checkpoint and leader election, this location stores\n# the larger objects, like persisted dataflow graphs.\n# \n# Must be a durable file system that is accessible from all nodes\n# (like HDFS, S3, Ceph, nfs, ...) \n#\n high-availability.storageDir: hdfs:///flink/ha/\n\n# The list of ZooKeeper quorum peers that coordinate the high-availability\n# setup. This must be a list of the form:\n# \"host1:clientPort,host2:clientPort,...\" (default clientPort: 2181)\n#\nhigh-availability.zookeeper.quorum: zk1:2181,zk2:2181,zk3:2181\n```\n\n**Master**\n\n```\nmaster:8081\n```\n\n**slave**\n\n```\nslave01\nslave02\n```\n\n**zoo.cfg**\n\n```\nserver.1=zk1:2888:3888\nserver.2=zk2:2888:3888\nserver.3=zk3:2888:3888\n```\n\n**需要在yarn-site.xml中配置**\n\n```xml\n<property>\n \t<name>yarn.resourcemanager.am.max-attempts</name>\n\t<value>4</value>\n</property>\n<property>\n\t<name>yarn.nodemanager.resource.cpu-vcores</name>\n\t<value>8</value>\n</property>\n```\n\n# 保存镜像\n\n```bash\ndocker commit -m \"bigdata:flink,hadoop\"  --author=\"yaosong\"  flk  yao/flinkonyarn:1.0\n```\n\n#   获得flk 容器\n\n```bash\n docker run -itd --net=br --name flk1 --hostname flk1 yao/flinkonyarn:1.0 &> /dev/null\n docker run -itd --net=br --name flk2 --hostname flk2 yao/flinkonyarn:1.0 &> /dev/null\n docker run -itd --net=br --name flk3 --hostname flk3 yao/flinkonyarn:1.0 &> /dev/null\n```\n\n# 停止/删除flk 容器\n\n```bash\ndocker stop flk1\ndocker stop flk2\ndocker stop flk3\ndocker rm flk1\ndocker rm flk2\ndocker rm flk3\n```\n\n# 官方：wordcount\n\n## flink测试命令\n\n由于在本地搭建，机器配置有限，故设置不同参数命令来运行官方wordcount\n\n```bash\nflink run -m yarn-cluster $FLINK_HOME/examples/batch/WordCount.jar\n\nflink run -m yarn-cluster -ynd 2 $FLINK_HOME/examples/batch/WordCount.jar\n\nflink run -m yarn-cluster -yn 4  $FLINK_HOME/examples/batch/WordCount.jar\n\nflink run -m yarn-cluster -yn 6  $FLINK_HOME/examples/batch/WordCount.jar\n\nflink run -m yarn-cluster -yn 8  $FLINK_HOME/examples/batch/WordCount.jar\n\nflink run -m yarn-cluster -yn 10  $FLINK_HOME/examples/batch/WordCount.jar\n```\n\n\n\n\n\n\n\n","source":"_posts/flink容器搭建.md","raw":"---\ntitle:  FLINK容器的搭建\ndate: 2018年08月06日 22时15分52秒\ntags:  [Docker,FLINK]\ncategories: 安装部署\ntoc: true\ntypora-copy-images-to: ipic\n---\n\n[TOC]\n\n\n\n\n\n# 来源容器  flk\n\n新建容器，为减少工作量，引用的是有ssh服务的Docker镜像**kinogmt/centos-ssh:6.7**，生成容器os为基准。\n\n```\ndocker run -itd  --name flk --hostname flk kinogmt/centos-ssh:6.7 &> /dev/null\n```\n\n> 注意必须要以-d方式启动，不然sshd服务不会启动，这算是一个小bug\n\n<!--more-->\n\n在容器中下载需要的elk的源包。做解压就不赘述，很多案例教程。\n\n> 我是采用的下载到宿主机，解压后，用 \"docker cp 解压包目录  os:/usr/loca/\"来传到容器内，比在容器内下载速度更快\n>\n> ## 复制源包\n>\n> ```\n> docker cp /Users/yaosong/Yao/hadoop  flk:/usr/\n> docker cp /Users/yaosong/Yao/flink  flk:/usr/\n> ```\n\n\n\n\n\n# 配置home\n\n\n\texport JAVA_HOME=/usr/java/jdk1.8.0_144/\n\texport PATH=$JAVA_HOME/bin:$PATH\n\texport FLINK_HOME=/usr/flink\n\texport HADOOP_HOME=/usr/hadoop\n\texport HADOOP_CONFIG_HOME=$HADOOP_HOME/etc/hadoop\n\texport HADOOP_CONF_DIR=$HADOOP_HOME/etc/hadoop\n\texport PATH=$PATH:$HADOOP_HOME/bin\n\texport PATH=$PATH:$HADOOP_HOME/sbin\n\texport PATH=$PATH:$FLINK_HOME/bin\n\n**配置hadoop**  参考：\n\n[]: http://gangtieguo.cn/2018/07/20/Docker%E4%B8%ADhadoop%20spark%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/\t\"Docker 中 hadoop，spark 镜像搭建\"\n\n\n\n**flink.yml**\n\n```\n high-availability: zookeeper\n\n# The path where metadata for master recovery is persisted. While ZooKeeper stores\n# the small ground truth for checkpoint and leader election, this location stores\n# the larger objects, like persisted dataflow graphs.\n# \n# Must be a durable file system that is accessible from all nodes\n# (like HDFS, S3, Ceph, nfs, ...) \n#\n high-availability.storageDir: hdfs:///flink/ha/\n\n# The list of ZooKeeper quorum peers that coordinate the high-availability\n# setup. This must be a list of the form:\n# \"host1:clientPort,host2:clientPort,...\" (default clientPort: 2181)\n#\nhigh-availability.zookeeper.quorum: zk1:2181,zk2:2181,zk3:2181\n```\n\n**Master**\n\n```\nmaster:8081\n```\n\n**slave**\n\n```\nslave01\nslave02\n```\n\n**zoo.cfg**\n\n```\nserver.1=zk1:2888:3888\nserver.2=zk2:2888:3888\nserver.3=zk3:2888:3888\n```\n\n**需要在yarn-site.xml中配置**\n\n```xml\n<property>\n \t<name>yarn.resourcemanager.am.max-attempts</name>\n\t<value>4</value>\n</property>\n<property>\n\t<name>yarn.nodemanager.resource.cpu-vcores</name>\n\t<value>8</value>\n</property>\n```\n\n# 保存镜像\n\n```bash\ndocker commit -m \"bigdata:flink,hadoop\"  --author=\"yaosong\"  flk  yao/flinkonyarn:1.0\n```\n\n#   获得flk 容器\n\n```bash\n docker run -itd --net=br --name flk1 --hostname flk1 yao/flinkonyarn:1.0 &> /dev/null\n docker run -itd --net=br --name flk2 --hostname flk2 yao/flinkonyarn:1.0 &> /dev/null\n docker run -itd --net=br --name flk3 --hostname flk3 yao/flinkonyarn:1.0 &> /dev/null\n```\n\n# 停止/删除flk 容器\n\n```bash\ndocker stop flk1\ndocker stop flk2\ndocker stop flk3\ndocker rm flk1\ndocker rm flk2\ndocker rm flk3\n```\n\n# 官方：wordcount\n\n## flink测试命令\n\n由于在本地搭建，机器配置有限，故设置不同参数命令来运行官方wordcount\n\n```bash\nflink run -m yarn-cluster $FLINK_HOME/examples/batch/WordCount.jar\n\nflink run -m yarn-cluster -ynd 2 $FLINK_HOME/examples/batch/WordCount.jar\n\nflink run -m yarn-cluster -yn 4  $FLINK_HOME/examples/batch/WordCount.jar\n\nflink run -m yarn-cluster -yn 6  $FLINK_HOME/examples/batch/WordCount.jar\n\nflink run -m yarn-cluster -yn 8  $FLINK_HOME/examples/batch/WordCount.jar\n\nflink run -m yarn-cluster -yn 10  $FLINK_HOME/examples/batch/WordCount.jar\n```\n\n\n\n\n\n\n\n","slug":"flink容器搭建","published":1,"updated":"2018-08-07T02:52:58.322Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloj0lmq004cykpboq4t2xna"},{"title":"ES测试命令","date":"2018-07-09T16:11:03.158Z","toc":true,"typora-copy-images-to":"ipic","_content":"\n[TOC]\n\n![](https://ws1.sinaimg.cn/large/006tNbRwgy1fu55ayb4i7j31kw0c73yz.jpg)\n\n简单命令测试和展示es的功能\n\n<!--more -->\n\n插入记录\n\n```\ncurl  -H \"Content-Type: application/json\"  -XPUT 'http://localhost:9200/store/books/1' -d '{\n\n\"title\": \"Elasticsearch: The Definitive Guide\",\n\"name\" : {\n    \"first\" : \"Zachary\",\n    \"last\" : \"Tong\"\n},\n\"publish_date\":\"2015-02-06\",\n\"price\":\"49.99\"\n\n}'\n\n\n```\n\n在添加一个书的信息\n```\ncurl  -H \"Content-Type: application/json\"  -XPUT 'http://elk1:9200/store/books/2' -d '{\n\"title\": \"Elasticsearch Blueprints\",\n\"name\" : {\n    \"first\" : \"Vineeth\",\n    \"last\" : \"Mohan\"\n},\n\"publish_date\":\"2015-06-06\",\n\"price\":\"35.99\"\n}'\n```\n\n通过ID获得文档信息\n\n```\ncurl   -H \"Content-Type: application/json\"  -XGET 'http://elk1:9200/store/books/1'\n```\n\n\n\n```\ncurl  -H \"Content-Type: application/json\"  -XGET 'http://elk1:9200/store/books/_search' -d '{\n\"query\" : {\n\n\"filtered\" : {\n    \"query\" : {\n        \"match_all\" : {}\n        },\n        \"filter\" : {\n            \"term\" : {\n                \"price\" : 35.99\n            }\n        }\n    }\n}\n\n}'\n```\n\n\n\n在浏览\n\n \t\n\n```\ncurl -H \"Content-Type: application/json\"  -XPUT 'http://elk1:9200/store/books/1' -d '{\n\n\"title\": \"Elasticsearch: The Definitive Guide\",\n\"name\" : {\n    \"first\" : \"Zachary\",\n    \"last\" : \"Tong\"\n},\n\"publish_date\":\"2015-02-06\",\n\"price\":\"49.99\"\n\n}'\n```\n\n\n\n```\ncurl -H \"Content-Type: application/json\" -XPUT 'http://127.0.0.1:9200/kc22k2_test’ -d ‘\n```\n\n\n\n```\ncurl -XPUT elk1:9200/test\n```\n\n\n\n```\ncurl -XGET 'http://elk1:9200/_cluster/state?pretty'\n{\n  \"error\" : {\n\n\"root_cause\" : [\n  {\n    \"type\" : \"master_not_discovered_exception\",\n    \"reason\" : null\n  }\n],\n\"type\" : \"master_not_discovered_exception\",\n\"reason\" : null\n\n  },\n  \"status\" : 503\n}\n```\n\n","source":"_posts/es测试命令.md","raw":"---\ntitle:  ES测试命令\ndate: 2018年08月06日 22时15分52秒\ntags:  [ELK,Docker,es]\ncategories: 安装部署\ntoc: true\ntypora-copy-images-to: ipic\n---\n\n[TOC]\n\n![](https://ws1.sinaimg.cn/large/006tNbRwgy1fu55ayb4i7j31kw0c73yz.jpg)\n\n简单命令测试和展示es的功能\n\n<!--more -->\n\n插入记录\n\n```\ncurl  -H \"Content-Type: application/json\"  -XPUT 'http://localhost:9200/store/books/1' -d '{\n\n\"title\": \"Elasticsearch: The Definitive Guide\",\n\"name\" : {\n    \"first\" : \"Zachary\",\n    \"last\" : \"Tong\"\n},\n\"publish_date\":\"2015-02-06\",\n\"price\":\"49.99\"\n\n}'\n\n\n```\n\n在添加一个书的信息\n```\ncurl  -H \"Content-Type: application/json\"  -XPUT 'http://elk1:9200/store/books/2' -d '{\n\"title\": \"Elasticsearch Blueprints\",\n\"name\" : {\n    \"first\" : \"Vineeth\",\n    \"last\" : \"Mohan\"\n},\n\"publish_date\":\"2015-06-06\",\n\"price\":\"35.99\"\n}'\n```\n\n通过ID获得文档信息\n\n```\ncurl   -H \"Content-Type: application/json\"  -XGET 'http://elk1:9200/store/books/1'\n```\n\n\n\n```\ncurl  -H \"Content-Type: application/json\"  -XGET 'http://elk1:9200/store/books/_search' -d '{\n\"query\" : {\n\n\"filtered\" : {\n    \"query\" : {\n        \"match_all\" : {}\n        },\n        \"filter\" : {\n            \"term\" : {\n                \"price\" : 35.99\n            }\n        }\n    }\n}\n\n}'\n```\n\n\n\n在浏览\n\n \t\n\n```\ncurl -H \"Content-Type: application/json\"  -XPUT 'http://elk1:9200/store/books/1' -d '{\n\n\"title\": \"Elasticsearch: The Definitive Guide\",\n\"name\" : {\n    \"first\" : \"Zachary\",\n    \"last\" : \"Tong\"\n},\n\"publish_date\":\"2015-02-06\",\n\"price\":\"49.99\"\n\n}'\n```\n\n\n\n```\ncurl -H \"Content-Type: application/json\" -XPUT 'http://127.0.0.1:9200/kc22k2_test’ -d ‘\n```\n\n\n\n```\ncurl -XPUT elk1:9200/test\n```\n\n\n\n```\ncurl -XGET 'http://elk1:9200/_cluster/state?pretty'\n{\n  \"error\" : {\n\n\"root_cause\" : [\n  {\n    \"type\" : \"master_not_discovered_exception\",\n    \"reason\" : null\n  }\n],\n\"type\" : \"master_not_discovered_exception\",\n\"reason\" : null\n\n  },\n  \"status\" : 503\n}\n```\n\n","slug":"es测试命令","published":1,"updated":"2018-08-10T18:02:13.602Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloj0lmr004fykpbncq6dtnc"},{"title":"git命令总结","date":"2018-05-21T17:43:07.025Z","toc":true,"_content":"\n\n\n![](https://ws2.sinaimg.cn/large/006tNbRwgy1fu55a5sqb0j313s0cwmxj.jpg)\n\n## 提交\n\n>git add .\n>git commit -m \" \"\n>git push origin master\n>git push origin master -f\n## 拉取\ngit pull <远程主机名> <远程分支名>:<本地分支名>\n如拉取远程的 master 分支到本地 wy 分支：\ngit pull origin master:wy\n\n## 分支切换\n<!-- more -->\n查看分支：git branch\n创建分支：git branch <name>\n切换分支：git checkout <name>\n创建 + 切换分支：git checkout -b <name>\n合并某分支到当前分支：git merge <name>\n删除分支：git branch -d <name>\n","source":"_posts/git命令总结.md","raw":"---\ntitle:  git命令总结\ndate:\ntags:  [git]\ncategories: 工程框架\ntoc: true\n---\n\n\n\n![](https://ws2.sinaimg.cn/large/006tNbRwgy1fu55a5sqb0j313s0cwmxj.jpg)\n\n## 提交\n\n>git add .\n>git commit -m \" \"\n>git push origin master\n>git push origin master -f\n## 拉取\ngit pull <远程主机名> <远程分支名>:<本地分支名>\n如拉取远程的 master 分支到本地 wy 分支：\ngit pull origin master:wy\n\n## 分支切换\n<!-- more -->\n查看分支：git branch\n创建分支：git branch <name>\n切换分支：git checkout <name>\n创建 + 切换分支：git checkout -b <name>\n合并某分支到当前分支：git merge <name>\n删除分支：git branch -d <name>\n","slug":"git命令总结","published":1,"updated":"2018-08-10T18:01:16.275Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloj0lmt004jykpbhiq1ifth"},{"title":"Hadoop&Spark组合容器的搭建","date":"2018-07-08T17:06:20.114Z","toc":true,"typora-copy-images-to":"ipic","_content":"\n[TOC]\n\n**配置centos集群 hadoop spark组件**\n启动容器\n各组件版本对应\nhbase1.2  hive 版本 2.0.0  hbase1.x ZooKeeper 3.4.x is required as of HBase 1.0.0\n\n\n\n新建容器，为减少工作量，引用的是有ssh服务的Docker镜像**kinogmt/centos-ssh:6.7**，生成容器os为基准。\n\n```\ndocker run -itd  --name bigdata --hostname bigdata kinogmt/centos-ssh:6.7 &> /dev/null\n```\n\n> 注意必须要以-d方式启动，不然sshd服务不会启动，这算是一个小bug\n\n<!--more-->\n\n在容器中下载需要的elk的源包，做解压就不赘述，很多案例教程。\n\n 我是采用的下载到宿主机，解压后，用 \"docker cp 解压包目录  os:/usr/loca/\"来传到容器内，比在容器内下载速度更快\n\n # 拷贝文件到容器\n\n \n\n 命令格式`docker cp 本地文件路径   容器id或者容器名称:`\n 将所有组件下载解压并拷贝到容器\n\n ```bash\n docker cp /Users/yaosong/Downloads/hadoop-2.8.0.tar.gz   bigdata:/\n docker cp /Users/yaosong/Downloads/spark-2.2.0-bin-without-hadoop.tgz   bigdata:/\n docker cp /Users/yaosong/Downloads/jdk-8u144-linux-x64.rpm   bigdata:/\n docker cp /Users/yaosong/Downloads/spark-2.1.0-bin-hadoop2.6.tgz   bigdata:/\n docker cp  /Users/yaosong/Yao/spark源包/hive bigdata:/usr\n docker cp /Users/yaosong/Downloads/jdk-8u144-linux-x64.rpm  bigdata:/\n docker cp /Users/yaosong/Downloads/hadoop-2.8.0.tar.gz  bigdata:/\n docker cp /Users/yaosong/Downloads/spark-2.2.0-bin-without-hadoop.tgz  bigdata:/\n docker cp /Users/yaosong/Downloads/spark-2.1.0-bin-hadoop2.6.tgz  bigdata:/\n docker cp /Users/yaosong/Yao/spark源包/hbase  bigdata:/usr\n docker cp /Users/yaosong/Yao/spark源包/zk   bigdata:/usr\n docker cp  /Users/yaosong/Yao/ant    bigdata:/usr\n docker cp  /Users/yaosong/Yao/maven  bigdata:/usr\n docker cp  /Users/yaosong/Yao/hue4  bigdata:/usr\n 创建home\n\n vim /etc/profile\n\n mac: vim ~/.bashrc\n\n 添加以下内容\n\n     export JAVA_HOME=/usr/java/jdk\n     export PATH=$JAVA_HOME:$PATH\n     export SCALA_HOME=/usr/scala-2.12.3/\n     export HADOOP_HOME=/usr/hadoop\n     export HADOOP_CONFIG_HOME=$HADOOP_HOME/etc/hadoop\n     export HADOOP_CONF_DIR=$HADOOP_HOME/etc/hadoop\n     export PATH=$PATH:$HADOOP_HOME/bin\n     export PATH=$PATH:$HADOOP_HOME/sbin\n     export SPARK_DIST_CLASSPATH=$(hadoop classpath)\n     SPARK_MASTER_IP=master\n     SPARK_LOCAL_DIRS=/usr/spark\n     SPARK_DRIVER_MEMORY=1G\n     export SPARK_HOME=/usr/spark\n     export PATH=$SPARK_HOME/bin:$PATH\n     export PATH=$SPARK_HOME/sbin:$PATH\n     \n     MAVEN_HOME=/usr/maven\n     export MAVEN_HOME\n     export PATH=${PATH}:${MAVEN_HOME}/bin\n     ANT_HOME=/usr/ant\n     PATH=$JAVA_HOME/bin:$ANT_HOME/bin:$PATH\n     export ANT_HOME PATH\n     HUE_HOME=/usr/hue4\n     export ZK_HOME=/usr/zk\n     export HBASE_HOME=/usr/hbase\n     export PATH=$HBASE_HOME/bin:$PATH\n     export PATH=$ZK_HOME/bin:$PATH\n\n\n\n ```\n\n\n\n# 安装\n\n## 创建 hadoop 集群所需目录：\n\n在以下配置文件中会有以下目录\n\n```bash\ncd $HADOOP_HOME;\nmkdir tmp\nmkdir namenode\nmkdir datanode\ncd $HADOOP_CONFIG_HOME/\n```\n## 更改配置文件\n\n`cd $HADOOP_CONFIG_HOME/` or `cd $HADOOP_HOME/etc/hadoop`\n#### hdfs slaves\n\n```bash\nslave01\nslave02\n```\n\n#### core-site.xml：\n\n```xml\n<property>\n        <name>hadoop.tmp.dir</name>\n        <value>/usr/hadoop/tmp</value>\n        <description>A base for other temporary directories.</description>\n</property>\n<property>\n\t<name>fs.default.name</name>\n\t  <value>hdfs://master:9000</value>\n\t  <final>true</final>\n\t  <description>The name of the default file system.\n\t  A URI whose scheme and authority determine the\n\t  FileSystem implementation.\n\t  </description>\n  </property>\n  <!--hive的配置，参考https://blog.csdn.net/lblblblblzdx/article/details/79760959-->\n  <property>\n  \t<name>hive.server2.authentication</name>\n  \t<value>NONE</value>\n  </property>\n  <!--hive的配置hadoop代理用户  root用户提交的任务可以在任意机器上以任意组的所有用户的身份执行。-->\n  <property>\n \t<name>hadoop.proxyuser.root.hosts</name>\n  \t<value>*</value>\n  </property>\n  <property>\n\t<name>hadoop.proxyuser.root.groups</name>\n\t<value>*</value>\n  </property>\n\t <!--HUE 增加一个值开启 hdfs 的 web 交互-->\n\t<property>\n\t      <name>dfs.webhdfs.enabled</name>\n\t      <value>true</value>\n\t</property>\n <!--HUE 增加一个值开启 hdfs 的 web 交互-->\n```\n\n#### hdfs-site.xml：\n```xml\n<property>\n    <name>dfs.replication</name>\n    <value>2</value>\n    <final>true</final>\n    <description>Default block replication.\n    The actual number of replications can be specified when the file is created.\n    The default is used if replication is not specified in create time.\n    </description>\n</property>\n\n<property>\n    <name>dfs.namenode.name.dir</name>\n    <value>/usr/hadoop/namenode</value>\n    <final>true</final>\n</property>\n\n<property>\n    <name>dfs.datanode.data.dir</name>\n    <value>/usr/hadoop/datanode</value>\n    <final>true</final>\n</property>\n<!--《为了让 hue 能够访问 hdfs，需要在 hdfs-site.xml 里面配置一些内容-->\n<property>\n    <name>hadoop.proxyuser.hue.hosts</name>\n    <value>*</value>\n</property>\n<property>\n    <name>hadoop.proxyuser.hue.groups</name>\n    <value>*</value>\n</property>\n<!--《为了让 hue 能够访问 hdfs，需要在 hdfs-site.xml 里面配置一些内容-->\n```\n\n#### mapred-site.xml：\n```xml\n<property>\n    <name>mapred.job.tracker</name>\n    <value>master:9001</value>\n    <description>The host and port that the MapReduce job tracker runs\n    at.  If \"local\", then jobs are run in-process as a single map\n    and reduce task.\n    </description>\n</property>\n```\n####  yarn-site.xml：\n```xml\n<property>\n\t<name>yarn.nodemanager.pmem-check-enabled</name>\n\t<value>false</value>\n</property>\n<property>\n    <name>yarn.nodemanager.vmem-check-enabled</name>\n    <value>false</value>\n    <description>Whether virtual memory limits will be enforced for containers</description>\n</property>\n<property>\n  <name>yarn.scheduler.minimum-allocation-mb</name>\n  <value>256</value>\n</property>\n<property>\n\t<name>yarn.resourcemanager.address</name>\n\t<value>master:8032</value>\n</property>\n<property>\n\t<name>yarn.resourcemanager.scheduler.address</name>\n\t<value>master:8030</value>\n</property>\n<property>\n\t<name>yarn.resourcemanager.resource-tracker.address</name>\n\t<value>master:8031</value>\n</property>\n```\n\n\n\n如果是hadoop3以上版本，需要在**start-dfs.sh start-yarn.sh**中开头空白处分别配置一下内容\n\n```bash\nvim $HADOOP_HOME/sbin/start-dfs.sh\n\nHDFS_DATANODE_USER=root\nHADOOP_SECURE_DN_USER=hdfs\nHDFS_NAMENODE_USER=root\nHDFS_SECONDARYNAMENODE_USER=root\n\nvim $HADOOP_HOME/sbin/start-yarn.sh\n\nYARN_RESOURCEMANAGER_USER=root\nHADOOP_SECURE_DN_USER=root\nYARN_NODEMANAGER_USER=yarn\nYARN_PROXYSERVER_USER=root\n```\n\n## 格式化namenode\n\n```bash\n$HADOOP_HOME/bin/hadoop namenode -format\n```\n\n\n# 启动集群\n\n`$HADOOP_HOME/sbin/start-all.sh`\n\n测试\n\n```bash\nyarn 8088端口   http://yourip:8088\n```\n\n```bash\nhdfs 50070端口 hdfs3.0为9870   http://yourip:50070\n```\n\n## spark只需要在slaves中添加\n\n```bash\nslave01\nslave02\n\n```\n**sparkUI端口8080**\n\n# 测试spark集群\n\n启动spark \n\n```bash\n$HADOOP_HOME/bin/start-all.sh\n```\n\n## 官网命令\n\n```bash\n$SPARK_HOME/bin/spark-submit --class org.apache.spark.examples.SparkPi \\\n--master yarn \\\n--deploy-mode cluster \\\n--driver-memory 512m \\\n--executor-memory 512m \\\n--executor-cores 1 \\\n$SPARK_HOME/examples/jars/spark-examples*.jar \\\n10\n```\n\n\n\n## 执行spark on yarn命令行模式\n\n```bash\nspark-shell --master yarn --deploy-mode client --driver-memory 1g --executor-memory 1g --executor-cores 1\n\nspark-shell --master yarn --deploy-mode client --driver-memory 512m --executor-memory 512m --executor-cores 1\n\nspark-shell --master yarn --deploy-mode client --driver-memory 475m --executor-memory 475m --executor-cores 1\n\nspark-shell --master yarn --deploy-mode client --driver-memory 350m --executor-memory 350m --executor-cores 1\n\nspark-shell --master yarn --deploy-mode client --driver-memory 650m --executor-memory 650m --executor-cores 1\n```\n\n\n\n# 创建镜像\n\n```bash\ndocker commit -m \"bigdata基础组件镜像\"  bigdata yaosong5/bigdata:2.0\n```\n\n\n\n# 创建容器\n\n```bash\ndocker run -itd  --net=br  --name master --hostname master yaosong5/bigdata:2.0 &> /dev/null\ndocker run -itd  --net=br  --name slave01 --hostname slave01 yaosong5/bigdata:2.0 &> /dev/null\ndocker run -itd  --net=br  --name slave02 --hostname slave02 yaosong5/bigdata:2.0 &> /dev/null\n```\n\n# 停止and 删除容器\n\n```bash\ndocker stop master\ndocker stop slave01\ndocker stop slave02\ndocker rm master\ndocker rm slave01\ndocker rm slave02\n```\n\n","source":"_posts/hadoop-spark集群搭建.md","raw":"---\ntitle:  Hadoop&Spark组合容器的搭建\ndate: 2018年08月06日 22时15分52秒\ntags:  [Docker,Spark,Hadoop]\ncategories: 安装部署\ntoc: true\ntypora-copy-images-to: ipic\n---\n\n[TOC]\n\n**配置centos集群 hadoop spark组件**\n启动容器\n各组件版本对应\nhbase1.2  hive 版本 2.0.0  hbase1.x ZooKeeper 3.4.x is required as of HBase 1.0.0\n\n\n\n新建容器，为减少工作量，引用的是有ssh服务的Docker镜像**kinogmt/centos-ssh:6.7**，生成容器os为基准。\n\n```\ndocker run -itd  --name bigdata --hostname bigdata kinogmt/centos-ssh:6.7 &> /dev/null\n```\n\n> 注意必须要以-d方式启动，不然sshd服务不会启动，这算是一个小bug\n\n<!--more-->\n\n在容器中下载需要的elk的源包，做解压就不赘述，很多案例教程。\n\n 我是采用的下载到宿主机，解压后，用 \"docker cp 解压包目录  os:/usr/loca/\"来传到容器内，比在容器内下载速度更快\n\n # 拷贝文件到容器\n\n \n\n 命令格式`docker cp 本地文件路径   容器id或者容器名称:`\n 将所有组件下载解压并拷贝到容器\n\n ```bash\n docker cp /Users/yaosong/Downloads/hadoop-2.8.0.tar.gz   bigdata:/\n docker cp /Users/yaosong/Downloads/spark-2.2.0-bin-without-hadoop.tgz   bigdata:/\n docker cp /Users/yaosong/Downloads/jdk-8u144-linux-x64.rpm   bigdata:/\n docker cp /Users/yaosong/Downloads/spark-2.1.0-bin-hadoop2.6.tgz   bigdata:/\n docker cp  /Users/yaosong/Yao/spark源包/hive bigdata:/usr\n docker cp /Users/yaosong/Downloads/jdk-8u144-linux-x64.rpm  bigdata:/\n docker cp /Users/yaosong/Downloads/hadoop-2.8.0.tar.gz  bigdata:/\n docker cp /Users/yaosong/Downloads/spark-2.2.0-bin-without-hadoop.tgz  bigdata:/\n docker cp /Users/yaosong/Downloads/spark-2.1.0-bin-hadoop2.6.tgz  bigdata:/\n docker cp /Users/yaosong/Yao/spark源包/hbase  bigdata:/usr\n docker cp /Users/yaosong/Yao/spark源包/zk   bigdata:/usr\n docker cp  /Users/yaosong/Yao/ant    bigdata:/usr\n docker cp  /Users/yaosong/Yao/maven  bigdata:/usr\n docker cp  /Users/yaosong/Yao/hue4  bigdata:/usr\n 创建home\n\n vim /etc/profile\n\n mac: vim ~/.bashrc\n\n 添加以下内容\n\n     export JAVA_HOME=/usr/java/jdk\n     export PATH=$JAVA_HOME:$PATH\n     export SCALA_HOME=/usr/scala-2.12.3/\n     export HADOOP_HOME=/usr/hadoop\n     export HADOOP_CONFIG_HOME=$HADOOP_HOME/etc/hadoop\n     export HADOOP_CONF_DIR=$HADOOP_HOME/etc/hadoop\n     export PATH=$PATH:$HADOOP_HOME/bin\n     export PATH=$PATH:$HADOOP_HOME/sbin\n     export SPARK_DIST_CLASSPATH=$(hadoop classpath)\n     SPARK_MASTER_IP=master\n     SPARK_LOCAL_DIRS=/usr/spark\n     SPARK_DRIVER_MEMORY=1G\n     export SPARK_HOME=/usr/spark\n     export PATH=$SPARK_HOME/bin:$PATH\n     export PATH=$SPARK_HOME/sbin:$PATH\n     \n     MAVEN_HOME=/usr/maven\n     export MAVEN_HOME\n     export PATH=${PATH}:${MAVEN_HOME}/bin\n     ANT_HOME=/usr/ant\n     PATH=$JAVA_HOME/bin:$ANT_HOME/bin:$PATH\n     export ANT_HOME PATH\n     HUE_HOME=/usr/hue4\n     export ZK_HOME=/usr/zk\n     export HBASE_HOME=/usr/hbase\n     export PATH=$HBASE_HOME/bin:$PATH\n     export PATH=$ZK_HOME/bin:$PATH\n\n\n\n ```\n\n\n\n# 安装\n\n## 创建 hadoop 集群所需目录：\n\n在以下配置文件中会有以下目录\n\n```bash\ncd $HADOOP_HOME;\nmkdir tmp\nmkdir namenode\nmkdir datanode\ncd $HADOOP_CONFIG_HOME/\n```\n## 更改配置文件\n\n`cd $HADOOP_CONFIG_HOME/` or `cd $HADOOP_HOME/etc/hadoop`\n#### hdfs slaves\n\n```bash\nslave01\nslave02\n```\n\n#### core-site.xml：\n\n```xml\n<property>\n        <name>hadoop.tmp.dir</name>\n        <value>/usr/hadoop/tmp</value>\n        <description>A base for other temporary directories.</description>\n</property>\n<property>\n\t<name>fs.default.name</name>\n\t  <value>hdfs://master:9000</value>\n\t  <final>true</final>\n\t  <description>The name of the default file system.\n\t  A URI whose scheme and authority determine the\n\t  FileSystem implementation.\n\t  </description>\n  </property>\n  <!--hive的配置，参考https://blog.csdn.net/lblblblblzdx/article/details/79760959-->\n  <property>\n  \t<name>hive.server2.authentication</name>\n  \t<value>NONE</value>\n  </property>\n  <!--hive的配置hadoop代理用户  root用户提交的任务可以在任意机器上以任意组的所有用户的身份执行。-->\n  <property>\n \t<name>hadoop.proxyuser.root.hosts</name>\n  \t<value>*</value>\n  </property>\n  <property>\n\t<name>hadoop.proxyuser.root.groups</name>\n\t<value>*</value>\n  </property>\n\t <!--HUE 增加一个值开启 hdfs 的 web 交互-->\n\t<property>\n\t      <name>dfs.webhdfs.enabled</name>\n\t      <value>true</value>\n\t</property>\n <!--HUE 增加一个值开启 hdfs 的 web 交互-->\n```\n\n#### hdfs-site.xml：\n```xml\n<property>\n    <name>dfs.replication</name>\n    <value>2</value>\n    <final>true</final>\n    <description>Default block replication.\n    The actual number of replications can be specified when the file is created.\n    The default is used if replication is not specified in create time.\n    </description>\n</property>\n\n<property>\n    <name>dfs.namenode.name.dir</name>\n    <value>/usr/hadoop/namenode</value>\n    <final>true</final>\n</property>\n\n<property>\n    <name>dfs.datanode.data.dir</name>\n    <value>/usr/hadoop/datanode</value>\n    <final>true</final>\n</property>\n<!--《为了让 hue 能够访问 hdfs，需要在 hdfs-site.xml 里面配置一些内容-->\n<property>\n    <name>hadoop.proxyuser.hue.hosts</name>\n    <value>*</value>\n</property>\n<property>\n    <name>hadoop.proxyuser.hue.groups</name>\n    <value>*</value>\n</property>\n<!--《为了让 hue 能够访问 hdfs，需要在 hdfs-site.xml 里面配置一些内容-->\n```\n\n#### mapred-site.xml：\n```xml\n<property>\n    <name>mapred.job.tracker</name>\n    <value>master:9001</value>\n    <description>The host and port that the MapReduce job tracker runs\n    at.  If \"local\", then jobs are run in-process as a single map\n    and reduce task.\n    </description>\n</property>\n```\n####  yarn-site.xml：\n```xml\n<property>\n\t<name>yarn.nodemanager.pmem-check-enabled</name>\n\t<value>false</value>\n</property>\n<property>\n    <name>yarn.nodemanager.vmem-check-enabled</name>\n    <value>false</value>\n    <description>Whether virtual memory limits will be enforced for containers</description>\n</property>\n<property>\n  <name>yarn.scheduler.minimum-allocation-mb</name>\n  <value>256</value>\n</property>\n<property>\n\t<name>yarn.resourcemanager.address</name>\n\t<value>master:8032</value>\n</property>\n<property>\n\t<name>yarn.resourcemanager.scheduler.address</name>\n\t<value>master:8030</value>\n</property>\n<property>\n\t<name>yarn.resourcemanager.resource-tracker.address</name>\n\t<value>master:8031</value>\n</property>\n```\n\n\n\n如果是hadoop3以上版本，需要在**start-dfs.sh start-yarn.sh**中开头空白处分别配置一下内容\n\n```bash\nvim $HADOOP_HOME/sbin/start-dfs.sh\n\nHDFS_DATANODE_USER=root\nHADOOP_SECURE_DN_USER=hdfs\nHDFS_NAMENODE_USER=root\nHDFS_SECONDARYNAMENODE_USER=root\n\nvim $HADOOP_HOME/sbin/start-yarn.sh\n\nYARN_RESOURCEMANAGER_USER=root\nHADOOP_SECURE_DN_USER=root\nYARN_NODEMANAGER_USER=yarn\nYARN_PROXYSERVER_USER=root\n```\n\n## 格式化namenode\n\n```bash\n$HADOOP_HOME/bin/hadoop namenode -format\n```\n\n\n# 启动集群\n\n`$HADOOP_HOME/sbin/start-all.sh`\n\n测试\n\n```bash\nyarn 8088端口   http://yourip:8088\n```\n\n```bash\nhdfs 50070端口 hdfs3.0为9870   http://yourip:50070\n```\n\n## spark只需要在slaves中添加\n\n```bash\nslave01\nslave02\n\n```\n**sparkUI端口8080**\n\n# 测试spark集群\n\n启动spark \n\n```bash\n$HADOOP_HOME/bin/start-all.sh\n```\n\n## 官网命令\n\n```bash\n$SPARK_HOME/bin/spark-submit --class org.apache.spark.examples.SparkPi \\\n--master yarn \\\n--deploy-mode cluster \\\n--driver-memory 512m \\\n--executor-memory 512m \\\n--executor-cores 1 \\\n$SPARK_HOME/examples/jars/spark-examples*.jar \\\n10\n```\n\n\n\n## 执行spark on yarn命令行模式\n\n```bash\nspark-shell --master yarn --deploy-mode client --driver-memory 1g --executor-memory 1g --executor-cores 1\n\nspark-shell --master yarn --deploy-mode client --driver-memory 512m --executor-memory 512m --executor-cores 1\n\nspark-shell --master yarn --deploy-mode client --driver-memory 475m --executor-memory 475m --executor-cores 1\n\nspark-shell --master yarn --deploy-mode client --driver-memory 350m --executor-memory 350m --executor-cores 1\n\nspark-shell --master yarn --deploy-mode client --driver-memory 650m --executor-memory 650m --executor-cores 1\n```\n\n\n\n# 创建镜像\n\n```bash\ndocker commit -m \"bigdata基础组件镜像\"  bigdata yaosong5/bigdata:2.0\n```\n\n\n\n# 创建容器\n\n```bash\ndocker run -itd  --net=br  --name master --hostname master yaosong5/bigdata:2.0 &> /dev/null\ndocker run -itd  --net=br  --name slave01 --hostname slave01 yaosong5/bigdata:2.0 &> /dev/null\ndocker run -itd  --net=br  --name slave02 --hostname slave02 yaosong5/bigdata:2.0 &> /dev/null\n```\n\n# 停止and 删除容器\n\n```bash\ndocker stop master\ndocker stop slave01\ndocker stop slave02\ndocker rm master\ndocker rm slave01\ndocker rm slave02\n```\n\n","slug":"hadoop-spark集群搭建","published":1,"updated":"2018-08-10T16:07:47.069Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloj0lmu004mykpbgguz7qb4"},{"title":"HBase容器的搭建","date":"2018-07-08T16:01:32.819Z","toc":true,"typora-copy-images-to":"ipic","_content":"\n\n[TOC]\n\n![](https://ws1.sinaimg.cn/large/006tNbRwgy1fu56b6k2qjj316y0s0jtg.jpg)\n\n# 创建hbase镜像\n\n##   拷贝源码\n\n\n```bash\ndocker cp /Users/yaosong/Yao/hbase 8019587d559b:/usr/\ndocker cp /Users/yaosong/Yao/zk   8019587d559b:/usr/\ndocker cp /Users/yaosong/Yao/hbasezkStart.sh 8019587d559b:/usr/\ndocker cp /Users/yaosong/Yao/hbase-start.sh 8019587d559b:/usr/\ndocker cp /Users/yaosong/Yao/zk-start.sh 8019587d559b:/usr/\n```\n\n参考https://www.cnblogs.com/netbloomy/p/6677883.html\n\n<!--more-->\n\n## 解压\n\n`tar -zxvf hbase-1.3.0-bin.tar.gz`\n进入 hbase 的配置目录，在 hbase-env.sh 文件里面加入 java 环境变量.\n\n 即：\n\n```bash\nvim  hbase-env.sh\nexport JAVA_HOME=JAVA_HOME=/usr/java/jdk\n```\n\n关闭 HBase 自带的 Zookeeper, 使用 Zookeeper 集群：\n\n```\nvim  hbase-env.sh\nexport  HBASE_MANAGES_ZK=false\n```\n\nhbase-site.xml\n\n```xml\n<configuration>\n    <property>\n        <name>hbase.rootdir</name>\n        <value>hdfs://master:9000/hbase</value>\n    </property>\n    <property>\n        <name>hbase.cluster.distributed</name>\n        <value>true</value>\n    </property>\n    <property>\n        <name>hbase.zookeeper.quorum</name>\n        <value>hbasezk1,hbasezk2,hbasezk3</value>\n    </property>\n    <property>\n        <name>hbase.zookeeper.property.dataDir</name>\n        <value>/usr/hbase/tmp/zk/data</value>\n    </property>\n    <!-- webui的配置 -->\n    <property>\n        <name>hbase.master.info.port</name>\n        <value>60010</value>\n    </property>\n    <!-- webui新增的配置 -->\n</configuration>\n```\n\n\n\n创建zk的datadir目录\n\n`mkdir -p /usr/hbase/tmp/zk/data`\n\n\n编辑配置目录下面的文件 regionservers. 命令：\n\n\tvim   $HBASE_HOME/config/regionservers\n\n\t加入如下内容：\n\thbasezk1\n\thbasezk2\n\thbasezk3\n\n\n\t把 Hbase 复制到其他机器scp\n\n\t开启 hbase 服务。命令如下： 哪台上运行哪台就为hmaster\n\n \t$HBASE_HOME/bin/start-hbase.sh\n\n\t在 hbasezk1,2,3 中的任意一台机器使用 $HBASE_HOME/bin/hbase shell\n\n\t进入 hbase 自带的 shell 环境，然后使用命令 version 等，进行查看 hbase 信息及建立表等操作。\n要配置 HBase 高可用的话，只需要启动两个 HMaster，让 Zookeeper 自己去选择一个 Master Acitve。\n","source":"_posts/hbasezk容器的搭建.md","raw":"---\ntitle:  HBase容器的搭建\ndate: 2018年08月06日 22时15分52秒\ntags:  [HBase,Docker]\ncategories: 安装部署\ntoc: true\ntypora-copy-images-to: ipic\n---\n\n\n[TOC]\n\n![](https://ws1.sinaimg.cn/large/006tNbRwgy1fu56b6k2qjj316y0s0jtg.jpg)\n\n# 创建hbase镜像\n\n##   拷贝源码\n\n\n```bash\ndocker cp /Users/yaosong/Yao/hbase 8019587d559b:/usr/\ndocker cp /Users/yaosong/Yao/zk   8019587d559b:/usr/\ndocker cp /Users/yaosong/Yao/hbasezkStart.sh 8019587d559b:/usr/\ndocker cp /Users/yaosong/Yao/hbase-start.sh 8019587d559b:/usr/\ndocker cp /Users/yaosong/Yao/zk-start.sh 8019587d559b:/usr/\n```\n\n参考https://www.cnblogs.com/netbloomy/p/6677883.html\n\n<!--more-->\n\n## 解压\n\n`tar -zxvf hbase-1.3.0-bin.tar.gz`\n进入 hbase 的配置目录，在 hbase-env.sh 文件里面加入 java 环境变量.\n\n 即：\n\n```bash\nvim  hbase-env.sh\nexport JAVA_HOME=JAVA_HOME=/usr/java/jdk\n```\n\n关闭 HBase 自带的 Zookeeper, 使用 Zookeeper 集群：\n\n```\nvim  hbase-env.sh\nexport  HBASE_MANAGES_ZK=false\n```\n\nhbase-site.xml\n\n```xml\n<configuration>\n    <property>\n        <name>hbase.rootdir</name>\n        <value>hdfs://master:9000/hbase</value>\n    </property>\n    <property>\n        <name>hbase.cluster.distributed</name>\n        <value>true</value>\n    </property>\n    <property>\n        <name>hbase.zookeeper.quorum</name>\n        <value>hbasezk1,hbasezk2,hbasezk3</value>\n    </property>\n    <property>\n        <name>hbase.zookeeper.property.dataDir</name>\n        <value>/usr/hbase/tmp/zk/data</value>\n    </property>\n    <!-- webui的配置 -->\n    <property>\n        <name>hbase.master.info.port</name>\n        <value>60010</value>\n    </property>\n    <!-- webui新增的配置 -->\n</configuration>\n```\n\n\n\n创建zk的datadir目录\n\n`mkdir -p /usr/hbase/tmp/zk/data`\n\n\n编辑配置目录下面的文件 regionservers. 命令：\n\n\tvim   $HBASE_HOME/config/regionservers\n\n\t加入如下内容：\n\thbasezk1\n\thbasezk2\n\thbasezk3\n\n\n\t把 Hbase 复制到其他机器scp\n\n\t开启 hbase 服务。命令如下： 哪台上运行哪台就为hmaster\n\n \t$HBASE_HOME/bin/start-hbase.sh\n\n\t在 hbasezk1,2,3 中的任意一台机器使用 $HBASE_HOME/bin/hbase shell\n\n\t进入 hbase 自带的 shell 环境，然后使用命令 version 等，进行查看 hbase 信息及建立表等操作。\n要配置 HBase 高可用的话，只需要启动两个 HMaster，让 Zookeeper 自己去选择一个 Master Acitve。\n","slug":"hbasezk容器的搭建","published":1,"updated":"2018-08-15T14:34:04.875Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloj0lmv004qykpbcmuge83p"},{"title":"Hue搭建","date":"2018-07-09T16:37:50.903Z","toc":true,"_content":"[TOC]\n![](https://ws2.sinaimg.cn/large/006tNbRwgy1fu54s2yk2aj30z40dcmyl.jpg)\n# 本次采用的ant maven来编译hue\n\n## 启动一个基础容器\n`docker run -itd  --net=br  --name hue --hostname  hue yaosong5/centosbase:1.0 &> /dev/null`\n<!--more-->\n## 拷贝源包\n将ant、hue4.0.0、ant、maven等下载到本地结业后，再拷贝到容器（这样更快速）\n\n\tdocker cp  /Users/yaosong/Yao/ant   4115ea59088e:/\n\tdocker cp  /Users/yaosong/Yao/maven  4115ea59088e:/\n\tdocker cp  /Users/yaosong/Yao/hue4  4115ea59088e:/usr/\n\n## 配置HOME\n```bash\nvim ~/.bashrc\n加入\nMAVEN_HOME=/maven\nexport MAVEN_HOME\nexport PATH=${PATH}:${MAVEN_HOME}/bin\nANT_HOME=/ant\nPATH=$JAVA_HOME/bin:$ANT_HOME/bin:$PATH\nHUE_HOME=/hue4\n使其生效\nsource ~/.bashrc\n```\n## 安装依赖，编译hue需要安装一些依赖\n\n`yum install gmp-devel -y `\n> 参考 http://www.aizhuanji.com/a/0Vo0qEMW.html\n\n**若解决不了**\n```\nyum install asciidoc cyrus-sasl-devel cyrus-sasl-gssapi cyrus-sasl-plain gcc gcc-c++ krb5-devel libffi-devel libtidy libxml2-devel libxslt-devel make mysql-devel openldap-devel  sqlite-devel openssl-devel gmp-devel -y\n```\n\n> 参考链接：https://www.jianshu.com/p/417788238e3d\n\n## \b编译安装hue\n\n首先编译 Hue，并在要安装 Hue 的节点上创建 Hue 用户和 hue 组\n\n\n\n\n创建 Hue 用户\n```Bash\ngroupadd hue\nuseradd hue -g hue\ncd   $HUE_HOME\nchown -R hue:hue *\n```\n\n> 注：需要注意的是 hue 在编译时有两种方式:1.通过maven、ant编译 2.通过python编译（在centos6.5因为自身python为2.6.6版本和hue编译需要2.7版本会有一点小冲突，故采用1）两种方式都是在hue目录下 make apps，只是第一种方式要先配置maven、ant的环境而已\n\n```bash\ncd $HUE_HOME\nmake apps\n```\n> 参考 ：https://blog.csdn.net/u012802702/article/details/68071244\n\n如果报错\n\n```\n/usr/hue4/Makefile.vars:42: *** \"Error: must have python development packages for 2.6 or 2.7. Could not find Python.h. Please install python2.6-devel or python2.7-devel\".  Stop.\n```\n\n需执行\n\n```bash\n可以先查看一下含 python-devel 的包\nyum search python | grep python-devel\n64 位安装 python-devel.x86_64，32 位安装 python-devel.i686，我这里安装:\nsudo yum install python-devel.x86_64 -y\n```\n\n## 更改hue的配置文件\n\n`vim $HUE_HOME/desktop/conf/hue.ini`\n\n### mysql\n\n```Ini\n [[database]]\n  host=master\n  port=3306\n  engine=mysql\n  user=root\n  password=root\n  name=hue\n```\n\n### hive\n\n```ini\nhive_server_host=master\nhive_server_port=10000\nhive_conf_dir=$HIVE_HOME/conf\n```\n\n### hadoop-hdfs\n\n```ini\nfs_defaultfs=hdfs://master:9000\nlogical_name=master\nwebhdfs_url=http://master:50070/webhdfs/v1\nhadoop_hdfs_home=$HADOOP_HOME\nhadoop_conf_dir=$HADOOP_HOME/etc/hadoop\n```\n\n\n\n### hadoop-yarn\n\n在 [hadoop].[[yarn_clusters]].[[[default]]] 下\n\n```ini\nresourcemanager_host=master\nresourcemanager_port=8032\nresourcemanager_api_url=http://master:8088\nproxy_api_url=http://master:8088\n```\n\n### hbase\n\n\n在 [hbase] 节点下\n\n```ini\nhbase_clusters=(HBASE|master:9090)\nhbase_conf_dir=$HBASE_HOME/conf\nuse_doas=true\n```\n\n\n\n## 大数据各组件满足hue进行相应配置\n\n### 安装mysql\n\n由于需要hue需要存放一些元数据故安装mysql\n\n```bash\nyum install -y mysql-server\nservice mysqld start\nmysql -u root -p\nEnter password:           //默认密码为空，输入后回车即可\nset password for root@localhost=password('root'); 　　密码设置为root\n默认情况下Mysql只允许本地登录，所以只需配置root@localhost就好\nset password for root@%=password('root'); 　　　　　　密码设置为root （其实这一步可以不配）\nset password for root@master=password('root'); 　　密码设置为root （其实这一步可以不配）\n\nselect user,host,password from mysql.user;  　　查看密码是否设置成功\nGRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'root' WITH GRANT OPTION;\n\ncreate database hue;\n```\n\n### 报错DatabaseError\n\n> DatabaseError:(1146,\"Table 'hue.desktop_settings' doesn't exist\")-初始化mysql\n\n完成以上的这个配置，启动 Hue, 通过浏览器访问，会发生错误，原因是 mysql 数据库没有被初始化\n**DatabaseError: (1146,\"Table 'hue.desktop_settings' doesn't exist\")**\n执行以下指令对 hue 数据库进行初始化\n\n```bash\ncd $HUE_HOME/build/env/\nbin/hue syncdb\nbin/hue migrate\n```\n\n此外需要注意的是如果使用的是：\n`$HUE_HOME/build/env/bin/hue syncdb --noinput`\n\n则不会让输入初始的用户名和密码，只有在首次登录时才会让输入，作为超级管理员账户。\b\n\n### hdfs\n\n#### hdfs-site.xml\n增加一个值开启 hdfs 的 web 交互\n```xml\n <!--HUE 增加一个值开启 hdfs 的 web 交互-->\n<property>\n      <name>dfs.webhdfs.enabled</name>\n      <value>true</value>\n</property>\n <!--HUE 增加一个值开启 hdfs 的 web 交互-->\n```\n\n#### core-site.xml\n```xml\n<!--《为了让 hue 能够访问 hdfs，需要在 hdfs-site.xml 里面配置一些内容-->\n<property>\n    <name>hadoop.proxyuser.hue.hosts</name>\n    <value>*</value>\n</property>\n<property>\n    <name>hadoop.proxyuser.hue.groups</name>\n    <value>*</value>\n</property>\n<!--《为了让 hue 能够访问 hdfs，需要在 hdfs-site.xml 里面配置一些内容-->\n```\n\n### hbase\n\n**hbase-site.xml**\n\n```xml\n<!-- hue支持 -->\n<property>\n        <name>hbase.thrift.support.proxyuser</name>\n        <value>true</value>\n</property>\n<property>\n        <name>hbase.regionserver.thrift.http</name>\n        <value>true</value>\n</property>\n<!-- hue支持 -->\n```\n\nhue 访问 hbase 是用的 thriftserver，并且是 thrift1，不是 thrift2，所以要在 master 上面启动 thrif1\n\n```\n$HBASE_HOME/bin/hbase-daemon.sh start thrift\n```\n> 参考 https://blog.csdn.net/Dante_003/article/details/78889084\n\n### 读取hbase问题\n\n为解决访问\n**Failed to authenticate to HBase Thrift Server, check authentication configurations.**\n需要在hue的配置文件中配置\n\n```ini\nuse_doas=true\n```\n\n\n参考http://gethue.com/hbase-browsing-with-doas-impersonation-and-kerberos/\n\n若以上配置未能解决问题，还需要将core-site.xml拷贝到hbase/conf，并添加以下内容\n\n```xml\n<property>\n  <name>hadoop.proxyuser.hbase.hosts</name>\n  <value>*</value>\n</property>\n<property>\n  <name>hadoop.proxyuser.hbase.groups</name>\n  <value>*</value>\n</property>\n```\n\n\n\n> [参考]https://blog.csdn.net/u012802702/article/details/68071244\n\n### hive\n\nHue 与框架 Hive 的集成\n开启 Hive Remote MetaStore\n`nohup $HIVE_HOME/bin/hive --service metastore &`\n\nhive 只需启动 hiveserver2，thriftserver 的 10000 端口启动即可\n```bash\nnohup $HIVE_HOME/bin/hiveserver2 &\n或者\nnohup HIVE_HOME/bin/hive --service hiveserver2 &\n```\n\n### 解决 hue ui 界面查询中文乱码问题\n\n在 `[[[mysql]]] `节点下\n\n```ini\noptions={\"init_command\":\"SET NAMES'utf8'\"}\n```\n\n> [参考]\n> https://blog.csdn.net/u012802702/article/details/68071244\n\n\n\n## 依赖的组件启动\n\n### Mysql\n\n`service mysqld start`\n\n### hadoop\n\n`start-all.sh`\n\n### hive\n\n然后需要同时启动 hive 的 metastore 和 hiveserve2\n\n```bash\nnohup hive --service metastore &\nnohup hive --service hiveserver2 &\n```\n\n### hbase\n\nHue 需要读取 HBase 的数据是使用 thrift 的方式，默认 HBase 的 thrift 服务没有开启，所有需要手动额外开启 thrift 服务。\n\n启动 thrift service\n`$HBASE_HOME/bin/hbase-daemon.sh start thrift`\n\nthrift service 默认使用的是 9090 端口，使用如下命令查看端口是否被占用\n\n`netstat -nl|grep 9090`\n\n#### 依赖启动的脚本\n\n```bash\n#!/bin/bash\n#启动mysql\nservice mysqld start\n#启动hadoop\nsh /hadoop-start.sh\n#启动hive\nsh /hive-start-servers2.sh\n#启动 thrift service\n$HBASE_HOME/bin/hbase-daemon.sh start thrift\n#启动hue\nnohup $HUE_HOME/build/env/bin/supervisor &\n```\n\n\n## hue启动命令\n```bash\n$HUE_HOME/build/env/bin/supervisor &\n```\n\n(注：想要后台执行就是 **$HUE_HOME/build/env/bin/supervisor &** )\n\n或者\n\n```Bash\n$HUE_HOME/build/env/bin/hue runserver_plus 0.0.0.0:8888\n```\n\n>\n> 【参考】https://blog.csdn.net/hexinghua0126/article/details/80338779\n>\n\n*hue的\bweb服务端口：8888*\n\n\n\n## hue停止命令\n\n`pkill -U hue`\n\n# 报错\n\n1、如果修改配置文件后，启动后无法进人 hue 界面\n\n```\n可能是配置文件被锁住了\ncd $HUE_HOME/desktop/conf\nls –a\nrm –rf hue.ini.swp\n或者 hadoop、hive 等服务没有启动起来\n```\n\n2、在 hue\b界面异常，导致 hive 无法使用\n安装插件：\n`yum install cyrus-sasl-plain  cyrus-sasl-devel  cyrus-sasl-gssapi`\n\n# 操作镜像\n\n## 保存为镜像\n`docker commit -m \"hue\"  hue   yaosong5/hue4:1.0`\n\n## 创建容器\n`docker run -itd  --net=br  --name gethue --hostname gethue gethue/hue:latest &> /dev/null`\n\b映射宿主机的\b\bhosts文件及其hue的配置文件方式启动容器\n```\ndocker run --name=hue -d --net=br\n -v /etc/hosts/:/etc/hosts -v $PWD/pseudo-distributed.ini:/hue/desktop/conf/pseudo-distributed.ini \tyaosong5/hue4:1.0\n```\n\n--net=br为\b了宿主机和容器之前ip自由访问所搭建的网络模式，如有需求\b请参考\n\n**其他参考**\n\n```bash\ndocker run --name=hue -d --net=br -v /etc/hosts/:/etc/hosts -v $PWD/pseudo-distributed.ini:/hue/desktop/conf/pseudo-distributed.ini gethue/hue:latest\n```\n> 参考：https://blog.csdn.net/Dante_003/article/details/78889084\n","source":"_posts/hue搭建.md","raw":"---\ntitle:  Hue搭建\ndate: 2018年06月21日 22时15分52秒\ntags:  [Docker,Hue]\ncategories: 安装部署\ntoc: true\n---\n[TOC]\n![](https://ws2.sinaimg.cn/large/006tNbRwgy1fu54s2yk2aj30z40dcmyl.jpg)\n# 本次采用的ant maven来编译hue\n\n## 启动一个基础容器\n`docker run -itd  --net=br  --name hue --hostname  hue yaosong5/centosbase:1.0 &> /dev/null`\n<!--more-->\n## 拷贝源包\n将ant、hue4.0.0、ant、maven等下载到本地结业后，再拷贝到容器（这样更快速）\n\n\tdocker cp  /Users/yaosong/Yao/ant   4115ea59088e:/\n\tdocker cp  /Users/yaosong/Yao/maven  4115ea59088e:/\n\tdocker cp  /Users/yaosong/Yao/hue4  4115ea59088e:/usr/\n\n## 配置HOME\n```bash\nvim ~/.bashrc\n加入\nMAVEN_HOME=/maven\nexport MAVEN_HOME\nexport PATH=${PATH}:${MAVEN_HOME}/bin\nANT_HOME=/ant\nPATH=$JAVA_HOME/bin:$ANT_HOME/bin:$PATH\nHUE_HOME=/hue4\n使其生效\nsource ~/.bashrc\n```\n## 安装依赖，编译hue需要安装一些依赖\n\n`yum install gmp-devel -y `\n> 参考 http://www.aizhuanji.com/a/0Vo0qEMW.html\n\n**若解决不了**\n```\nyum install asciidoc cyrus-sasl-devel cyrus-sasl-gssapi cyrus-sasl-plain gcc gcc-c++ krb5-devel libffi-devel libtidy libxml2-devel libxslt-devel make mysql-devel openldap-devel  sqlite-devel openssl-devel gmp-devel -y\n```\n\n> 参考链接：https://www.jianshu.com/p/417788238e3d\n\n## \b编译安装hue\n\n首先编译 Hue，并在要安装 Hue 的节点上创建 Hue 用户和 hue 组\n\n\n\n\n创建 Hue 用户\n```Bash\ngroupadd hue\nuseradd hue -g hue\ncd   $HUE_HOME\nchown -R hue:hue *\n```\n\n> 注：需要注意的是 hue 在编译时有两种方式:1.通过maven、ant编译 2.通过python编译（在centos6.5因为自身python为2.6.6版本和hue编译需要2.7版本会有一点小冲突，故采用1）两种方式都是在hue目录下 make apps，只是第一种方式要先配置maven、ant的环境而已\n\n```bash\ncd $HUE_HOME\nmake apps\n```\n> 参考 ：https://blog.csdn.net/u012802702/article/details/68071244\n\n如果报错\n\n```\n/usr/hue4/Makefile.vars:42: *** \"Error: must have python development packages for 2.6 or 2.7. Could not find Python.h. Please install python2.6-devel or python2.7-devel\".  Stop.\n```\n\n需执行\n\n```bash\n可以先查看一下含 python-devel 的包\nyum search python | grep python-devel\n64 位安装 python-devel.x86_64，32 位安装 python-devel.i686，我这里安装:\nsudo yum install python-devel.x86_64 -y\n```\n\n## 更改hue的配置文件\n\n`vim $HUE_HOME/desktop/conf/hue.ini`\n\n### mysql\n\n```Ini\n [[database]]\n  host=master\n  port=3306\n  engine=mysql\n  user=root\n  password=root\n  name=hue\n```\n\n### hive\n\n```ini\nhive_server_host=master\nhive_server_port=10000\nhive_conf_dir=$HIVE_HOME/conf\n```\n\n### hadoop-hdfs\n\n```ini\nfs_defaultfs=hdfs://master:9000\nlogical_name=master\nwebhdfs_url=http://master:50070/webhdfs/v1\nhadoop_hdfs_home=$HADOOP_HOME\nhadoop_conf_dir=$HADOOP_HOME/etc/hadoop\n```\n\n\n\n### hadoop-yarn\n\n在 [hadoop].[[yarn_clusters]].[[[default]]] 下\n\n```ini\nresourcemanager_host=master\nresourcemanager_port=8032\nresourcemanager_api_url=http://master:8088\nproxy_api_url=http://master:8088\n```\n\n### hbase\n\n\n在 [hbase] 节点下\n\n```ini\nhbase_clusters=(HBASE|master:9090)\nhbase_conf_dir=$HBASE_HOME/conf\nuse_doas=true\n```\n\n\n\n## 大数据各组件满足hue进行相应配置\n\n### 安装mysql\n\n由于需要hue需要存放一些元数据故安装mysql\n\n```bash\nyum install -y mysql-server\nservice mysqld start\nmysql -u root -p\nEnter password:           //默认密码为空，输入后回车即可\nset password for root@localhost=password('root'); 　　密码设置为root\n默认情况下Mysql只允许本地登录，所以只需配置root@localhost就好\nset password for root@%=password('root'); 　　　　　　密码设置为root （其实这一步可以不配）\nset password for root@master=password('root'); 　　密码设置为root （其实这一步可以不配）\n\nselect user,host,password from mysql.user;  　　查看密码是否设置成功\nGRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'root' WITH GRANT OPTION;\n\ncreate database hue;\n```\n\n### 报错DatabaseError\n\n> DatabaseError:(1146,\"Table 'hue.desktop_settings' doesn't exist\")-初始化mysql\n\n完成以上的这个配置，启动 Hue, 通过浏览器访问，会发生错误，原因是 mysql 数据库没有被初始化\n**DatabaseError: (1146,\"Table 'hue.desktop_settings' doesn't exist\")**\n执行以下指令对 hue 数据库进行初始化\n\n```bash\ncd $HUE_HOME/build/env/\nbin/hue syncdb\nbin/hue migrate\n```\n\n此外需要注意的是如果使用的是：\n`$HUE_HOME/build/env/bin/hue syncdb --noinput`\n\n则不会让输入初始的用户名和密码，只有在首次登录时才会让输入，作为超级管理员账户。\b\n\n### hdfs\n\n#### hdfs-site.xml\n增加一个值开启 hdfs 的 web 交互\n```xml\n <!--HUE 增加一个值开启 hdfs 的 web 交互-->\n<property>\n      <name>dfs.webhdfs.enabled</name>\n      <value>true</value>\n</property>\n <!--HUE 增加一个值开启 hdfs 的 web 交互-->\n```\n\n#### core-site.xml\n```xml\n<!--《为了让 hue 能够访问 hdfs，需要在 hdfs-site.xml 里面配置一些内容-->\n<property>\n    <name>hadoop.proxyuser.hue.hosts</name>\n    <value>*</value>\n</property>\n<property>\n    <name>hadoop.proxyuser.hue.groups</name>\n    <value>*</value>\n</property>\n<!--《为了让 hue 能够访问 hdfs，需要在 hdfs-site.xml 里面配置一些内容-->\n```\n\n### hbase\n\n**hbase-site.xml**\n\n```xml\n<!-- hue支持 -->\n<property>\n        <name>hbase.thrift.support.proxyuser</name>\n        <value>true</value>\n</property>\n<property>\n        <name>hbase.regionserver.thrift.http</name>\n        <value>true</value>\n</property>\n<!-- hue支持 -->\n```\n\nhue 访问 hbase 是用的 thriftserver，并且是 thrift1，不是 thrift2，所以要在 master 上面启动 thrif1\n\n```\n$HBASE_HOME/bin/hbase-daemon.sh start thrift\n```\n> 参考 https://blog.csdn.net/Dante_003/article/details/78889084\n\n### 读取hbase问题\n\n为解决访问\n**Failed to authenticate to HBase Thrift Server, check authentication configurations.**\n需要在hue的配置文件中配置\n\n```ini\nuse_doas=true\n```\n\n\n参考http://gethue.com/hbase-browsing-with-doas-impersonation-and-kerberos/\n\n若以上配置未能解决问题，还需要将core-site.xml拷贝到hbase/conf，并添加以下内容\n\n```xml\n<property>\n  <name>hadoop.proxyuser.hbase.hosts</name>\n  <value>*</value>\n</property>\n<property>\n  <name>hadoop.proxyuser.hbase.groups</name>\n  <value>*</value>\n</property>\n```\n\n\n\n> [参考]https://blog.csdn.net/u012802702/article/details/68071244\n\n### hive\n\nHue 与框架 Hive 的集成\n开启 Hive Remote MetaStore\n`nohup $HIVE_HOME/bin/hive --service metastore &`\n\nhive 只需启动 hiveserver2，thriftserver 的 10000 端口启动即可\n```bash\nnohup $HIVE_HOME/bin/hiveserver2 &\n或者\nnohup HIVE_HOME/bin/hive --service hiveserver2 &\n```\n\n### 解决 hue ui 界面查询中文乱码问题\n\n在 `[[[mysql]]] `节点下\n\n```ini\noptions={\"init_command\":\"SET NAMES'utf8'\"}\n```\n\n> [参考]\n> https://blog.csdn.net/u012802702/article/details/68071244\n\n\n\n## 依赖的组件启动\n\n### Mysql\n\n`service mysqld start`\n\n### hadoop\n\n`start-all.sh`\n\n### hive\n\n然后需要同时启动 hive 的 metastore 和 hiveserve2\n\n```bash\nnohup hive --service metastore &\nnohup hive --service hiveserver2 &\n```\n\n### hbase\n\nHue 需要读取 HBase 的数据是使用 thrift 的方式，默认 HBase 的 thrift 服务没有开启，所有需要手动额外开启 thrift 服务。\n\n启动 thrift service\n`$HBASE_HOME/bin/hbase-daemon.sh start thrift`\n\nthrift service 默认使用的是 9090 端口，使用如下命令查看端口是否被占用\n\n`netstat -nl|grep 9090`\n\n#### 依赖启动的脚本\n\n```bash\n#!/bin/bash\n#启动mysql\nservice mysqld start\n#启动hadoop\nsh /hadoop-start.sh\n#启动hive\nsh /hive-start-servers2.sh\n#启动 thrift service\n$HBASE_HOME/bin/hbase-daemon.sh start thrift\n#启动hue\nnohup $HUE_HOME/build/env/bin/supervisor &\n```\n\n\n## hue启动命令\n```bash\n$HUE_HOME/build/env/bin/supervisor &\n```\n\n(注：想要后台执行就是 **$HUE_HOME/build/env/bin/supervisor &** )\n\n或者\n\n```Bash\n$HUE_HOME/build/env/bin/hue runserver_plus 0.0.0.0:8888\n```\n\n>\n> 【参考】https://blog.csdn.net/hexinghua0126/article/details/80338779\n>\n\n*hue的\bweb服务端口：8888*\n\n\n\n## hue停止命令\n\n`pkill -U hue`\n\n# 报错\n\n1、如果修改配置文件后，启动后无法进人 hue 界面\n\n```\n可能是配置文件被锁住了\ncd $HUE_HOME/desktop/conf\nls –a\nrm –rf hue.ini.swp\n或者 hadoop、hive 等服务没有启动起来\n```\n\n2、在 hue\b界面异常，导致 hive 无法使用\n安装插件：\n`yum install cyrus-sasl-plain  cyrus-sasl-devel  cyrus-sasl-gssapi`\n\n# 操作镜像\n\n## 保存为镜像\n`docker commit -m \"hue\"  hue   yaosong5/hue4:1.0`\n\n## 创建容器\n`docker run -itd  --net=br  --name gethue --hostname gethue gethue/hue:latest &> /dev/null`\n\b映射宿主机的\b\bhosts文件及其hue的配置文件方式启动容器\n```\ndocker run --name=hue -d --net=br\n -v /etc/hosts/:/etc/hosts -v $PWD/pseudo-distributed.ini:/hue/desktop/conf/pseudo-distributed.ini \tyaosong5/hue4:1.0\n```\n\n--net=br为\b了宿主机和容器之前ip自由访问所搭建的网络模式，如有需求\b请参考\n\n**其他参考**\n\n```bash\ndocker run --name=hue -d --net=br -v /etc/hosts/:/etc/hosts -v $PWD/pseudo-distributed.ini:/hue/desktop/conf/pseudo-distributed.ini gethue/hue:latest\n```\n> 参考：https://blog.csdn.net/Dante_003/article/details/78889084\n","slug":"hue搭建","published":1,"updated":"2018-08-10T17:44:19.068Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloj0lmw004uykpby2cpmzx4"},{"title":"jsontool使用","date":"2018-05-30T01:36:02.864Z","toc":true,"_content":"\njson-tool使用：`java -jar json-tool.jar \"json文件目录\" \"jsonPath路径\"`\n示例：\n\n```\njava -jar /Users/yaosong/Documents/json-tool.jar \"/Users/yaosong/tmp/access_report_data_by_token.json\"  \"$.report_data.behavior_check[?(@.check_point_cn == '朋友圈在哪里')].evidence\"\n```\n![示例截图](https://www.github.com/yaosong5/tuchuang/raw/master/mdtc/2018/5/30/1527644586687.jpg)","source":"_posts/json-tool使用.md","raw":"---\ntitle:  jsontool使用\ndate: 2018年06月21日 22时15分52秒\ntags:  [命令]\ncategories: tool\ntoc: true\n---\n\njson-tool使用：`java -jar json-tool.jar \"json文件目录\" \"jsonPath路径\"`\n示例：\n\n```\njava -jar /Users/yaosong/Documents/json-tool.jar \"/Users/yaosong/tmp/access_report_data_by_token.json\"  \"$.report_data.behavior_check[?(@.check_point_cn == '朋友圈在哪里')].evidence\"\n```\n![示例截图](https://www.github.com/yaosong5/tuchuang/raw/master/mdtc/2018/5/30/1527644586687.jpg)","slug":"json-tool使用","published":1,"updated":"2018-08-10T17:46:56.174Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloj0lmy004xykpb9lj8xkwx"},{"title":"kafka的启动及常用命令","date":"2018-07-08T15:58:00.558Z","toc":true,"_content":"# kafka的启动脚本\n\n \tkafka-startall.sh\n\n```bash\n#!/bin/bash\nsed -e '1c borker.id=0' $KAFKA_HOME/config/server.properties\n$KAFKA_HOME/bin/kafka-server-start.sh -daemon $KAFKA_HOME/config/server.properties\nssh root@slave01 \"sed -i '1c borker.id=1 ' $KAFKA_HOME/config/server.properties\"\nssh root@slave01 \"sed -i '5c host.name=slave01 ' $KAFKA_HOME/config/server.properties\"\nssh root@slave01 \"sed -i '6c advertised.host.name=slave01 ' $KAFKA_HOME/config/server.properties\"\nssh root@slave01 \"$KAFKA_HOME/bin/kafka-server-start.sh -daemon $KAFKA_HOME/config/server.properties\"\nssh root@slave02 \"sed -i '1c borker.id=2 ' $KAFKA_HOME/config/server.properties\"\nssh root@slave02 \"sed -i '5c host.name=slave02 ' $KAFKA_HOME/config/server.properties\"\nssh root@slave02 \"sed -i '6c advertised.host.name=slave02 ' $KAFKA_HOME/config/server.properties\"\nssh root@slave02 \"$KAFKA_HOME/bin/kafka-server-start.sh -daemon $KAFKA_HOME/config/server.properties\"\n```\n<!--more -->\n\n# kafka的shell命令\n\njps -ml 查看kafka的运行情况\n\n## 启动\n\n```bash\nnohup  $KAFKA_HOME/bin/kafka-server-start.sh  $KAFKA_HOME/config/server.properties > /dev/null 2>&1 &\n/usr/kafka/bin/kafka-server-start.sh -daemon /usr/kafka/config/server.properties\n```\n\n## 创建 topic\n\n```bash\n$KAFKA_HOME/bin/kafka-topics.sh --create --zookeeper zk1:2181 --replication-factor 2 --partitions 3 --topic shuaige\n```\n\n## 查看消费位置\n\n```bash\nsh  $KAFKA_HOME/bin/kafka-run-class.sh kafka.tools.ConsumerOffsetChecker --zookeeper zk1:2181 --group testGroup\n\n```\n\n## 查看某个 Topic 的详情\n\n```bash\nsh  $KAFKA_HOME/bin/kafka-topics.sh --topic test --describe --zookeeper zk1:2181\n\n```\n\n## 创建生产者\n\n```bash\n$KAFKA_HOME/bin/kafka-console-producer.sh --broker-list kafka1:9092 --topic shuaige\n```\n\n## 创建消费者\n\n```bash\n$KAFKA_HOME/bin/kafka-console-consumer.sh --zookeeper zk1:2181 --topic shuaige --from-beginning\n\n```\n\n## 查看所有 topic\n\nzk 表示 zk 的地址 地址表示 zookeeper 的地址\n\n```Bash\n$KAFKA_HOME/bin/kafka-topics.sh --list --zookeeper  zk1:2181\n```\n\n## 删除 topic\n\n```bash\nsh $KAFKA_HOME/bin/kafka-topics.sh --delete --zookeeper zk1:2181 --topic test\n```","source":"_posts/kafka启动脚本及命令.md","raw":"---\ntitle:  kafka的启动及常用命令\ndate: 2018年06月21日 22时15分52秒\ntags:  [Kafka]\ncategories: 大数据\ntoc: true\n---\n# kafka的启动脚本\n\n \tkafka-startall.sh\n\n```bash\n#!/bin/bash\nsed -e '1c borker.id=0' $KAFKA_HOME/config/server.properties\n$KAFKA_HOME/bin/kafka-server-start.sh -daemon $KAFKA_HOME/config/server.properties\nssh root@slave01 \"sed -i '1c borker.id=1 ' $KAFKA_HOME/config/server.properties\"\nssh root@slave01 \"sed -i '5c host.name=slave01 ' $KAFKA_HOME/config/server.properties\"\nssh root@slave01 \"sed -i '6c advertised.host.name=slave01 ' $KAFKA_HOME/config/server.properties\"\nssh root@slave01 \"$KAFKA_HOME/bin/kafka-server-start.sh -daemon $KAFKA_HOME/config/server.properties\"\nssh root@slave02 \"sed -i '1c borker.id=2 ' $KAFKA_HOME/config/server.properties\"\nssh root@slave02 \"sed -i '5c host.name=slave02 ' $KAFKA_HOME/config/server.properties\"\nssh root@slave02 \"sed -i '6c advertised.host.name=slave02 ' $KAFKA_HOME/config/server.properties\"\nssh root@slave02 \"$KAFKA_HOME/bin/kafka-server-start.sh -daemon $KAFKA_HOME/config/server.properties\"\n```\n<!--more -->\n\n# kafka的shell命令\n\njps -ml 查看kafka的运行情况\n\n## 启动\n\n```bash\nnohup  $KAFKA_HOME/bin/kafka-server-start.sh  $KAFKA_HOME/config/server.properties > /dev/null 2>&1 &\n/usr/kafka/bin/kafka-server-start.sh -daemon /usr/kafka/config/server.properties\n```\n\n## 创建 topic\n\n```bash\n$KAFKA_HOME/bin/kafka-topics.sh --create --zookeeper zk1:2181 --replication-factor 2 --partitions 3 --topic shuaige\n```\n\n## 查看消费位置\n\n```bash\nsh  $KAFKA_HOME/bin/kafka-run-class.sh kafka.tools.ConsumerOffsetChecker --zookeeper zk1:2181 --group testGroup\n\n```\n\n## 查看某个 Topic 的详情\n\n```bash\nsh  $KAFKA_HOME/bin/kafka-topics.sh --topic test --describe --zookeeper zk1:2181\n\n```\n\n## 创建生产者\n\n```bash\n$KAFKA_HOME/bin/kafka-console-producer.sh --broker-list kafka1:9092 --topic shuaige\n```\n\n## 创建消费者\n\n```bash\n$KAFKA_HOME/bin/kafka-console-consumer.sh --zookeeper zk1:2181 --topic shuaige --from-beginning\n\n```\n\n## 查看所有 topic\n\nzk 表示 zk 的地址 地址表示 zookeeper 的地址\n\n```Bash\n$KAFKA_HOME/bin/kafka-topics.sh --list --zookeeper  zk1:2181\n```\n\n## 删除 topic\n\n```bash\nsh $KAFKA_HOME/bin/kafka-topics.sh --delete --zookeeper zk1:2181 --topic test\n```","slug":"kafka启动脚本及命令","published":1,"updated":"2018-08-14T11:36:16.094Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloj0ln00051ykpb2io7zp9f"},{"title":"spring集成权限校验","date":"2018-05-08T10:34:55.000Z","toc":true,"_content":"# shiro简介  \nshiro是权限控制的一个框架\t\t\n是一个强大易用的Java安全框架，提供了认证、授权、加密和会话管理功能，可为任何应用提供安全保障 - 从命令行应用、移动应用到大型网络及企业应用。\n<!-- more -->\n\n### **权限控制的方式**   \n权限有四种实现方式   \n注解(基于代理),url拦截(基于过滤器),shiro标签库(基于标签),编写代码(及其不推荐)   \n**不论哪种方式:都需要引入spring用于整合shiro的过滤器  **   \nweb.xml中:DelegatingFilterProxy=>spring整合shiro\n配置spring提供的用于整合shiro框架的过滤器\n```xml\n  <filter>\n    <filter-name>shiroFilter</filter-name>\n    <filter-class>org.springframework.web.filter.DelegatingFilterProxy\n   </fileter>\n```  \nfilet-name需要和**spring配置文件**中的一个BEAN对象的id保持一致**非常重要**  \n\n###  配置   \nI. 注解方式,注解是利用生成的代理对象来完成权限校验:   \nspring框架会为当前action对象(加注解的action)创建一个代理对象,如果有权限,就执行这个方法,不然就会报**异常**\n(将spring,Strust配置文件丰富:添加权限的注解,struts添加捕获异常,跳转页面)  \n 1. 需要在spring配置文件中进行配置开启注解**DefaultAdvisorAutoProxyCreator**,\n  并配置成cjlib方式的注解   \n```xml\n<property name=\"proxyTargetClass\" value=\"true\">\\</property>\n```\n注解实现权限当为jdk模式的时候    \n方法注解实现权限过滤  \n抛异常的原因:因为如果是jdk方式的话,实现的接口modelDriven只有一个getModel方法      \n所以不能进行对除该方法外其他方法进行注解\n\n 2.  定义切面类**AuthorizationAttributeSourceAdvisor**\n ```xml\n <bean id=\"authorizationAttributeSourceAdvisor\" class=\"org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor\"></bean>\n ```\n\n 3. 在需要权限才能访问的方法上添加注解\n   ```java\n  @RequiresPermissions(\"relo_delete这是权限名称\")   \n  ```  \n\nII.  url拦截(springxml)\n  基于过滤器或者拦截器实现   \n```xml\n<bean id=\"shiroFilter\" class=\"org.apache.shiro.spring.web.ShiroFilterFactoryBean\">\n\t\t<property name=\"securityManager\" ref=\"securityManager\"/>\n\t\t<property name=\"loginUrl\" value=\"/login.jsp\"/>\n\t\t<property name=\"unauthorizedUrl\" value=\"/unauthorized.jsp\"/>\n\t\t<property name=\"filterChainDefinitions\">\n\t\t\t<value>\n\t\t\t\t/css/** = anon\n\t\t\t\t/js/** = anon\n\t\t\t\t/images/** = anon\n\t\t\t\t/validatecode.jsp* = anon\n\t\t\t\t/login.jsp* = anon\n\t\t\t\t/userAction_login.action = anon\n\t\t\t\t/page_base_staff.action = perms[\"staff\"]\n\t\t\t\t/** = authc\n\t\t\t\t<!--/** = authc-->\n\t\t\t</value>\n\t\t</property>\n\t</bean>\n\t<!--开启自动代理,并且将代理代理模式设置为cjlib-->\n\t<bean id=\"defaultAdvisorAutoProxyCreator\" class=\"org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator\">\n\t\t<!--设置成cglib方式-->\n\t\t<property name=\"proxyTargetClass\" value=\"true\"></property>\n\t</bean>\n```\n![shiro各种过滤器简写](http://img.blog.csdn.net/20170109205450918?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzQ1MTM0Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n\n\n#  shiro的使用 \t\t\n\n1. 在web.xml中引入用于创建shiro框架的过滤器\nweb.xml中:DelegatingFilterProxy=>spring整合shiro   \n`注意引入的位置:要在struts核心过滤器的前面,StrutsPrepareAndExcutFilter,不然,所有请求会通过struts过滤器获直接访问得到,shiro的过滤器将不会起到作用`    \n\n2. 在Spring中整合shiro   \n  2.1).  shiro框架过滤器:**ShiroFilterFactoryBean** 需要声明那些过滤器,那些资源需要匹配那些过滤器,采用url拦截方式进行的路径对应的拦截器    \n  2.2).  配置安全管理器:**DefaultWebSecurityManager** 需要注入 自定义的Realm bean对象     \n\n  ```xml\n  <!--配置一个shiro框架的过滤器工厂bean,用于创建shiro框架的过滤器-->\n\t<bean id=\"shiroFilter\" class=\"org.apache.shiro.spring.web.ShiroFilterFactoryBean\">\n\t\t<property name=\"securityManager\" ref=\"securityManager\"/>\n\t\t<property name=\"loginUrl\" value=\"/login.jsp\"/>\n\t\t<property name=\"unauthorizedUrl\" value=\"/unauthorized.jsp\"/>\n\t\t<property name=\"filterChainDefinitions\">\n\t\t\t<value>\n\t\t\t\t/css/** = anon\n\t\t\t\t/js/** = anon\n\t\t\t\t/images/** = anon\n\t\t\t\t/validatecode.jsp* = anon\n\t\t\t\t/login.jsp* = anon\n\t\t\t\t/userAction_login.action = anon\n\t\t\t\t/page_base_staff.action = perms[\"staff\"]\n\t\t\t\t/** = authc\n\t\t\t\t<!--/** 表示所有/下所有路径,包括下面的所有路径-->\n        <!--/validatecode.jsp*\n         表示所有除了validatecode.jsp,还包括jsp后追加其他内容的.如validatecode.jsp?'+Math.random();防止验证码读取缓存\n\t\t\t</value>\n\t\t</property>\n\t</bean>\n\t<!--开启自动代理,并且将代理代理模式设置为cjlib\n  动态代理分为两类\n  基于jdk 创建的类必须要实现一个接口,这是面向接口的动态代理   \n  基于cjlib 创建的类不能用final修饰\n-->\n\t<bean id=\"defaultAdvisorAutoProxyCreator\" class=\"org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator\">\n\t\t<!--设置成cglib方式-->\n\t\t<property name=\"proxyTargetClass\" value=\"true\"></property>\n\t</bean>\n\t<!--定义aop通知+切入点-->\n\t<bean id=\"authorizationAttributeSourceAdvisor\" class=\"org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor\"></bean>\n\n\t<!--注入安全管理器-->\n\t<bean id=\"securityManager\" class=\"org.apache.shiro.web.mgt.DefaultWebSecurityManager\">\n\t\t<property name=\"realm\" ref=\"bosRealm\"></property>\n\t\t<property name=\"cacheManager\" ref=\"ehCacheManager\"></property>\n\t</bean>\n  ```\n\n3. 在登陆认证的方法中加入subject `controller中的login方法`\n```java\npublic String login(){\nSubject subject = SecurityUtils.getSubject();\n  //创建一个用户名密码令牌\n  AuthenticationToken token = new UsernamePasswordToken(getModel().getUsername(), MD5Utils.md5(\n          getModel().getPassword()));\n  try {\n    //认证\n      subject.login(token);\n  } catch (Exception e) {\n      this.addActionError(\"用户名或者密码错误\");\n      return LOGIN;\n  }\n  /*当通过认证,跳入主页*/\n  User user = (User) subject.getPrincipal();\n  /*将用户信息存入session*/\n  ServletActionContext.getRequest().getSession().setAttribute(\"currentUser\", user);\n  /*返回主页*/\n  return \"\";\n}\n```  \n\n4. 自定义Realm(用于权限的具体实施,即认证和授权)一般实现Realm接口的 **AuthorizingRealm** 实例    \n4.1实现认证 重写doGetAuthenticationInfo方法\n必须继承*AuthorizingRealm*    \n在需要交付给spring生成,并需要在安全注册管理器中注入属性Realm\n\n\n```java\nprotected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n\nUsernamePasswordToken mytoken = (UsernamePasswordToken) token;\n       String username = mytoken.getUsername();\n       DetachedCriteria dc = DetachedCriteria.forClass(User.class);\n       dc.add(Restrictions.eq(\"username\",username));\n       List<User> list = userDao.findByCriteria(dc);\n       if(list != null && list.size() >0){\n           User user = list.get(0);\n           String dbPassword = user.getPassword();\n           AuthenticationInfo info = new SimpleAuthenticationInfo(user,dbPassword,this.getName());\n           return info;\n       }else{\n           return null;\n       }\n   }\n```\n4.2实现授权 重写doGetAuthorizationInfo方法\n\n\n\n```java\nprotected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {\n/*获的简单授权对象,用于授权的*/\n  SimpleAuthorizationInfo info = new SimpleAuthorizationInfo();\n    /*授权staff权限*/\n    //info.addStringPermission(\"staff\");\n    //步骤获得授权对象,获得当前用户,获得当前用户的权限(若为admin即授予所有权限),当前用户授权\n    //获得对象\n    User user = (User)principals.getPrimaryPrincipal();\n    List<Function> fList = null;\n    //获得权限\n    if(user.getUsername().equals(\"admin\")){\n        fList = functionDao.findAll();\n    }else{\n        fList = functionDao.findFunctionByUserId(user.getId());\n    }\n    //授予权限\n    for(Function f : fList){\n        info.addStringPermission(f.getCode());\n}\n```\t\t\t\n\n## 关于Shiro中使用 **encache**     \n1.引入包   \n`在spring配置文件中配置以下`  \n2.配置文件ehcache.xml   \n```xml\n<ehcache xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation=\"../config/ehcache.xsd\">\n    <defaultCache\n            maxElementsInMemory=\"10000\"\n            eternal=\"false\"\n            timeToIdleSeconds=\"120\"\n            timeToLiveSeconds=\"120\"\n            overflowToDisk=\"true\"\n            maxElementsOnDisk=\"10000000\"\n            diskPersistent=\"false\"\n            diskExpiryThreadIntervalSeconds=\"120\"\n            memoryStoreEvictionPolicy=\"LRU\"\n            />\n</ehcache>\n <!--eternal是否永久有效-->\n```\n3.引入缓存管理器**EhCacheManager**(shiro包中的),并设置配置文件;     \n4.将缓存管理器注入安全管理器**DefaultWebSecurityManager**\n```xml\n<!--注册安全管理器-->\n<bean id=\"securityManager\" class=\"org.apache.shiro.web.mgt.DefaultWebSecurityManager\">\n\t\t<property name=\"realm\" ref=\"bosRealm\"></property>\n\t\t<property name=\"cacheManager\" ref=\"ehCacheManager\"></property>\n\t</bean>\n\t<bean id=\"bosRealm\" class=\"org.yao.bos.web.action.realm.BOSRealm\"></bean>\n\t<!--注入缓存管理器-->\n\t<bean id=\"ehCacheManager\" class=\"org.apache.shiro.cache.ehcache.EhCacheManager\">\n\t\t<property name=\"cacheManagerConfigFile\" value=\"classpath:ehcache.xml\"></property>\n\t</bean>\n```\n\n","source":"_posts/spring集成权限校验.md","raw":"---\ntitle: spring集成权限校验\ndate: 2018-05-08 18:34:55\ntags: [技术,开发,Java]\ncategories: [Spring]\ntoc: true\n---\n# shiro简介  \nshiro是权限控制的一个框架\t\t\n是一个强大易用的Java安全框架，提供了认证、授权、加密和会话管理功能，可为任何应用提供安全保障 - 从命令行应用、移动应用到大型网络及企业应用。\n<!-- more -->\n\n### **权限控制的方式**   \n权限有四种实现方式   \n注解(基于代理),url拦截(基于过滤器),shiro标签库(基于标签),编写代码(及其不推荐)   \n**不论哪种方式:都需要引入spring用于整合shiro的过滤器  **   \nweb.xml中:DelegatingFilterProxy=>spring整合shiro\n配置spring提供的用于整合shiro框架的过滤器\n```xml\n  <filter>\n    <filter-name>shiroFilter</filter-name>\n    <filter-class>org.springframework.web.filter.DelegatingFilterProxy\n   </fileter>\n```  \nfilet-name需要和**spring配置文件**中的一个BEAN对象的id保持一致**非常重要**  \n\n###  配置   \nI. 注解方式,注解是利用生成的代理对象来完成权限校验:   \nspring框架会为当前action对象(加注解的action)创建一个代理对象,如果有权限,就执行这个方法,不然就会报**异常**\n(将spring,Strust配置文件丰富:添加权限的注解,struts添加捕获异常,跳转页面)  \n 1. 需要在spring配置文件中进行配置开启注解**DefaultAdvisorAutoProxyCreator**,\n  并配置成cjlib方式的注解   \n```xml\n<property name=\"proxyTargetClass\" value=\"true\">\\</property>\n```\n注解实现权限当为jdk模式的时候    \n方法注解实现权限过滤  \n抛异常的原因:因为如果是jdk方式的话,实现的接口modelDriven只有一个getModel方法      \n所以不能进行对除该方法外其他方法进行注解\n\n 2.  定义切面类**AuthorizationAttributeSourceAdvisor**\n ```xml\n <bean id=\"authorizationAttributeSourceAdvisor\" class=\"org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor\"></bean>\n ```\n\n 3. 在需要权限才能访问的方法上添加注解\n   ```java\n  @RequiresPermissions(\"relo_delete这是权限名称\")   \n  ```  \n\nII.  url拦截(springxml)\n  基于过滤器或者拦截器实现   \n```xml\n<bean id=\"shiroFilter\" class=\"org.apache.shiro.spring.web.ShiroFilterFactoryBean\">\n\t\t<property name=\"securityManager\" ref=\"securityManager\"/>\n\t\t<property name=\"loginUrl\" value=\"/login.jsp\"/>\n\t\t<property name=\"unauthorizedUrl\" value=\"/unauthorized.jsp\"/>\n\t\t<property name=\"filterChainDefinitions\">\n\t\t\t<value>\n\t\t\t\t/css/** = anon\n\t\t\t\t/js/** = anon\n\t\t\t\t/images/** = anon\n\t\t\t\t/validatecode.jsp* = anon\n\t\t\t\t/login.jsp* = anon\n\t\t\t\t/userAction_login.action = anon\n\t\t\t\t/page_base_staff.action = perms[\"staff\"]\n\t\t\t\t/** = authc\n\t\t\t\t<!--/** = authc-->\n\t\t\t</value>\n\t\t</property>\n\t</bean>\n\t<!--开启自动代理,并且将代理代理模式设置为cjlib-->\n\t<bean id=\"defaultAdvisorAutoProxyCreator\" class=\"org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator\">\n\t\t<!--设置成cglib方式-->\n\t\t<property name=\"proxyTargetClass\" value=\"true\"></property>\n\t</bean>\n```\n![shiro各种过滤器简写](http://img.blog.csdn.net/20170109205450918?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzQ1MTM0Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n\n\n#  shiro的使用 \t\t\n\n1. 在web.xml中引入用于创建shiro框架的过滤器\nweb.xml中:DelegatingFilterProxy=>spring整合shiro   \n`注意引入的位置:要在struts核心过滤器的前面,StrutsPrepareAndExcutFilter,不然,所有请求会通过struts过滤器获直接访问得到,shiro的过滤器将不会起到作用`    \n\n2. 在Spring中整合shiro   \n  2.1).  shiro框架过滤器:**ShiroFilterFactoryBean** 需要声明那些过滤器,那些资源需要匹配那些过滤器,采用url拦截方式进行的路径对应的拦截器    \n  2.2).  配置安全管理器:**DefaultWebSecurityManager** 需要注入 自定义的Realm bean对象     \n\n  ```xml\n  <!--配置一个shiro框架的过滤器工厂bean,用于创建shiro框架的过滤器-->\n\t<bean id=\"shiroFilter\" class=\"org.apache.shiro.spring.web.ShiroFilterFactoryBean\">\n\t\t<property name=\"securityManager\" ref=\"securityManager\"/>\n\t\t<property name=\"loginUrl\" value=\"/login.jsp\"/>\n\t\t<property name=\"unauthorizedUrl\" value=\"/unauthorized.jsp\"/>\n\t\t<property name=\"filterChainDefinitions\">\n\t\t\t<value>\n\t\t\t\t/css/** = anon\n\t\t\t\t/js/** = anon\n\t\t\t\t/images/** = anon\n\t\t\t\t/validatecode.jsp* = anon\n\t\t\t\t/login.jsp* = anon\n\t\t\t\t/userAction_login.action = anon\n\t\t\t\t/page_base_staff.action = perms[\"staff\"]\n\t\t\t\t/** = authc\n\t\t\t\t<!--/** 表示所有/下所有路径,包括下面的所有路径-->\n        <!--/validatecode.jsp*\n         表示所有除了validatecode.jsp,还包括jsp后追加其他内容的.如validatecode.jsp?'+Math.random();防止验证码读取缓存\n\t\t\t</value>\n\t\t</property>\n\t</bean>\n\t<!--开启自动代理,并且将代理代理模式设置为cjlib\n  动态代理分为两类\n  基于jdk 创建的类必须要实现一个接口,这是面向接口的动态代理   \n  基于cjlib 创建的类不能用final修饰\n-->\n\t<bean id=\"defaultAdvisorAutoProxyCreator\" class=\"org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator\">\n\t\t<!--设置成cglib方式-->\n\t\t<property name=\"proxyTargetClass\" value=\"true\"></property>\n\t</bean>\n\t<!--定义aop通知+切入点-->\n\t<bean id=\"authorizationAttributeSourceAdvisor\" class=\"org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor\"></bean>\n\n\t<!--注入安全管理器-->\n\t<bean id=\"securityManager\" class=\"org.apache.shiro.web.mgt.DefaultWebSecurityManager\">\n\t\t<property name=\"realm\" ref=\"bosRealm\"></property>\n\t\t<property name=\"cacheManager\" ref=\"ehCacheManager\"></property>\n\t</bean>\n  ```\n\n3. 在登陆认证的方法中加入subject `controller中的login方法`\n```java\npublic String login(){\nSubject subject = SecurityUtils.getSubject();\n  //创建一个用户名密码令牌\n  AuthenticationToken token = new UsernamePasswordToken(getModel().getUsername(), MD5Utils.md5(\n          getModel().getPassword()));\n  try {\n    //认证\n      subject.login(token);\n  } catch (Exception e) {\n      this.addActionError(\"用户名或者密码错误\");\n      return LOGIN;\n  }\n  /*当通过认证,跳入主页*/\n  User user = (User) subject.getPrincipal();\n  /*将用户信息存入session*/\n  ServletActionContext.getRequest().getSession().setAttribute(\"currentUser\", user);\n  /*返回主页*/\n  return \"\";\n}\n```  \n\n4. 自定义Realm(用于权限的具体实施,即认证和授权)一般实现Realm接口的 **AuthorizingRealm** 实例    \n4.1实现认证 重写doGetAuthenticationInfo方法\n必须继承*AuthorizingRealm*    \n在需要交付给spring生成,并需要在安全注册管理器中注入属性Realm\n\n\n```java\nprotected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n\nUsernamePasswordToken mytoken = (UsernamePasswordToken) token;\n       String username = mytoken.getUsername();\n       DetachedCriteria dc = DetachedCriteria.forClass(User.class);\n       dc.add(Restrictions.eq(\"username\",username));\n       List<User> list = userDao.findByCriteria(dc);\n       if(list != null && list.size() >0){\n           User user = list.get(0);\n           String dbPassword = user.getPassword();\n           AuthenticationInfo info = new SimpleAuthenticationInfo(user,dbPassword,this.getName());\n           return info;\n       }else{\n           return null;\n       }\n   }\n```\n4.2实现授权 重写doGetAuthorizationInfo方法\n\n\n\n```java\nprotected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {\n/*获的简单授权对象,用于授权的*/\n  SimpleAuthorizationInfo info = new SimpleAuthorizationInfo();\n    /*授权staff权限*/\n    //info.addStringPermission(\"staff\");\n    //步骤获得授权对象,获得当前用户,获得当前用户的权限(若为admin即授予所有权限),当前用户授权\n    //获得对象\n    User user = (User)principals.getPrimaryPrincipal();\n    List<Function> fList = null;\n    //获得权限\n    if(user.getUsername().equals(\"admin\")){\n        fList = functionDao.findAll();\n    }else{\n        fList = functionDao.findFunctionByUserId(user.getId());\n    }\n    //授予权限\n    for(Function f : fList){\n        info.addStringPermission(f.getCode());\n}\n```\t\t\t\n\n## 关于Shiro中使用 **encache**     \n1.引入包   \n`在spring配置文件中配置以下`  \n2.配置文件ehcache.xml   \n```xml\n<ehcache xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation=\"../config/ehcache.xsd\">\n    <defaultCache\n            maxElementsInMemory=\"10000\"\n            eternal=\"false\"\n            timeToIdleSeconds=\"120\"\n            timeToLiveSeconds=\"120\"\n            overflowToDisk=\"true\"\n            maxElementsOnDisk=\"10000000\"\n            diskPersistent=\"false\"\n            diskExpiryThreadIntervalSeconds=\"120\"\n            memoryStoreEvictionPolicy=\"LRU\"\n            />\n</ehcache>\n <!--eternal是否永久有效-->\n```\n3.引入缓存管理器**EhCacheManager**(shiro包中的),并设置配置文件;     \n4.将缓存管理器注入安全管理器**DefaultWebSecurityManager**\n```xml\n<!--注册安全管理器-->\n<bean id=\"securityManager\" class=\"org.apache.shiro.web.mgt.DefaultWebSecurityManager\">\n\t\t<property name=\"realm\" ref=\"bosRealm\"></property>\n\t\t<property name=\"cacheManager\" ref=\"ehCacheManager\"></property>\n\t</bean>\n\t<bean id=\"bosRealm\" class=\"org.yao.bos.web.action.realm.BOSRealm\"></bean>\n\t<!--注入缓存管理器-->\n\t<bean id=\"ehCacheManager\" class=\"org.apache.shiro.cache.ehcache.EhCacheManager\">\n\t\t<property name=\"cacheManagerConfigFile\" value=\"classpath:ehcache.xml\"></property>\n\t</bean>\n```\n\n","slug":"spring集成权限校验","published":1,"updated":"2018-05-17T12:21:22.941Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloj0ln20055ykpbm95jzsrj"},{"title":"Zookeeper的配置容器的搭建","date":"2018-08-06T19:06:03.170Z","toc":true,"typora-copy-images-to":"ipic","_content":"\n[TOC]\n![](https://ws2.sinaimg.cn/large/006tNbRwgy1fu554uqh0pj31660fwta8.jpg)\n\n在usr目录下下载zk包，并且解压到/usr/目录，改名为zk，所以$ZK_HOME为/usr/zk\n\n# 创建目录\n\n```\nmkdir -p /usr/zk/data\nmkdir -p /usr/zk/logs\ntouch /usr/zk/data/myid\n```\n\n<!--more -->\n\n# 更改配置文件\n\n`vim  $ZK_HOME/conf/zoo.cfg`\n\n```\ndataDir=/usr/zk/data\ndataLogDir=/usr/zk/logs\nserver.1=zk1:2888:3888\nserver.2=zk2:2888:3888\nserver.3=zk3:2888:3888\n```\n\nzookeeper需要全部左右节点都启动才会选举leader，follower\n\n所有节点启动的脚本\n\n```bash\n# !/bin/bash\necho 1 > $ZK_HOME/data/myid\n$ZK_HOME/bin/zkServer.sh start\nssh root@zk2 \"echo 2 > /usr/zk/data/myid\"\nssh root@zk2 \"/usr/zk/bin/zkServer.sh start\"\nssh root@zk3 \"echo 3 > /usr/zk/data/myid\"\nssh root@zk3 \"/usr/zk/bin/zkServer.sh start\"\n```\n\n\n\n\n\n# zk问题\n\n1、由于 zk 运行一段时间后，会产生大量的日志文件，把磁盘空间占满，导致整个机器进程都不能活动了，所以需要定期清理这些日志文件，方法如下：\n\n1）、写一个脚本文件 cleanup.sh 内容如下：\n\n```\n java -cp zookeeper.jar:lib/slf4j-api-1.6.1.jar:lib/slf4j-log4j12-1.6.1.jar:lib/log4j-1.2.15.jar:conf org.apache.zookeeper.server.PurgeTxnLog <dataDir> <snapDir> -n <count>\n 其中：\n\n　　dataDir：即上面配置的 dataDir 的目录\n　　\n　　snapDir：即上面配置的 dataLogDir 的目录\n\n　　count：保留前几个日志文件，默认为 3\n\n\n```\n\n2）、通过 crontab 写定时任务，来完成定时清理日志的需求\n\n```\ncrontab -e 0 0 * *  /opt/zookeeper-3.4.10/bin/cleanup.sh\nHBase Master 高可用（HA）（http://www.cnblogs.com/captainlucky/p/4710642.html）\nHMaster 没有单点问题，HBase 中可以启动多个 HMaster，通过 Zookeeper 的 Master Election 机制保证总有一个 Master 运行。\n```\n\n所以这里要配置 HBase 高可用的话，只需要启动两个 HMaster，让 Zookeeper 自己去选择一个 Master Acitve。","source":"_posts/zookeeper配置.md","raw":"---\ntitle:  Zookeeper的配置容器的搭建\ndate: 2018年08月06日 22时15分52秒\ntags:  [zk,Docker]\ncategories: 安装部署\ntoc: true\ntypora-copy-images-to: ipic\n---\n\n[TOC]\n![](https://ws2.sinaimg.cn/large/006tNbRwgy1fu554uqh0pj31660fwta8.jpg)\n\n在usr目录下下载zk包，并且解压到/usr/目录，改名为zk，所以$ZK_HOME为/usr/zk\n\n# 创建目录\n\n```\nmkdir -p /usr/zk/data\nmkdir -p /usr/zk/logs\ntouch /usr/zk/data/myid\n```\n\n<!--more -->\n\n# 更改配置文件\n\n`vim  $ZK_HOME/conf/zoo.cfg`\n\n```\ndataDir=/usr/zk/data\ndataLogDir=/usr/zk/logs\nserver.1=zk1:2888:3888\nserver.2=zk2:2888:3888\nserver.3=zk3:2888:3888\n```\n\nzookeeper需要全部左右节点都启动才会选举leader，follower\n\n所有节点启动的脚本\n\n```bash\n# !/bin/bash\necho 1 > $ZK_HOME/data/myid\n$ZK_HOME/bin/zkServer.sh start\nssh root@zk2 \"echo 2 > /usr/zk/data/myid\"\nssh root@zk2 \"/usr/zk/bin/zkServer.sh start\"\nssh root@zk3 \"echo 3 > /usr/zk/data/myid\"\nssh root@zk3 \"/usr/zk/bin/zkServer.sh start\"\n```\n\n\n\n\n\n# zk问题\n\n1、由于 zk 运行一段时间后，会产生大量的日志文件，把磁盘空间占满，导致整个机器进程都不能活动了，所以需要定期清理这些日志文件，方法如下：\n\n1）、写一个脚本文件 cleanup.sh 内容如下：\n\n```\n java -cp zookeeper.jar:lib/slf4j-api-1.6.1.jar:lib/slf4j-log4j12-1.6.1.jar:lib/log4j-1.2.15.jar:conf org.apache.zookeeper.server.PurgeTxnLog <dataDir> <snapDir> -n <count>\n 其中：\n\n　　dataDir：即上面配置的 dataDir 的目录\n　　\n　　snapDir：即上面配置的 dataLogDir 的目录\n\n　　count：保留前几个日志文件，默认为 3\n\n\n```\n\n2）、通过 crontab 写定时任务，来完成定时清理日志的需求\n\n```\ncrontab -e 0 0 * *  /opt/zookeeper-3.4.10/bin/cleanup.sh\nHBase Master 高可用（HA）（http://www.cnblogs.com/captainlucky/p/4710642.html）\nHMaster 没有单点问题，HBase 中可以启动多个 HMaster，通过 Zookeeper 的 Master Election 机制保证总有一个 Master 运行。\n```\n\n所以这里要配置 HBase 高可用的话，只需要启动两个 HMaster，让 Zookeeper 自己去选择一个 Master Acitve。","slug":"zookeeper配置","published":1,"updated":"2018-08-10T17:58:15.529Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloj0ln40059ykpbs62pnu8z"},{"title":"博客备份.md","date":"2018-05-08T10:34:55.000Z","toc":true,"_content":"\n```\n<% if (!is_post()) { %>\n    <% if (site.tags.length){ %>\n        <div class=\"widget tag\">\n          <h3 class=\"title\"><%= __('标签 :') %></h3>\n            <%- list_categories(site.tags) %>\n            </div>\n        <% } %>\n        <% } %>\n\n    <% if (!is_post()) { %>\n    <% if (site.categories.length){ %>\n        <div class=\"widget tag\">\n          <h2 class=\"title\"><%= __('分类 :') %></h2>\n           <h4> <%- list_categories(site.categories) %></h4>\n            </div>\n        <% } %>\n        <% } %>\n\t```\n\t\n---\n\n```\n\t<% if (!index && post.toc) { %>\n                <div id=\"toc\" class=\"toc-article\">\n                <strong class=\"toc-title\"><%= __('') %></strong>\n                    <%- toc(post.content) %>\n                </div>\n            <% } %>\n\n```","source":"_posts/博客修改备份.md","raw":"---\ntitle: 博客备份.md\ndate: 2018-05-08 18:34:55\ntags: [Hexo,Other]\ncategories: [Hexo]\ntoc: true\n---\n\n```\n<% if (!is_post()) { %>\n    <% if (site.tags.length){ %>\n        <div class=\"widget tag\">\n          <h3 class=\"title\"><%= __('标签 :') %></h3>\n            <%- list_categories(site.tags) %>\n            </div>\n        <% } %>\n        <% } %>\n\n    <% if (!is_post()) { %>\n    <% if (site.categories.length){ %>\n        <div class=\"widget tag\">\n          <h2 class=\"title\"><%= __('分类 :') %></h2>\n           <h4> <%- list_categories(site.categories) %></h4>\n            </div>\n        <% } %>\n        <% } %>\n\t```\n\t\n---\n\n```\n\t<% if (!index && post.toc) { %>\n                <div id=\"toc\" class=\"toc-article\">\n                <strong class=\"toc-title\"><%= __('') %></strong>\n                    <%- toc(post.content) %>\n                </div>\n            <% } %>\n\n```","slug":"博客修改备份","published":1,"updated":"2018-05-17T16:18:46.428Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloj0ln5005cykpbea1gkz7s"},{"title":"源文件提交到仓库","date":"2018-05-21T17:43:07.025Z","toc":true,"_content":"将博客源文件加入到仓库\n>git add .\ngit commit -m \" \"\ngit push origin master\ngit push origin master -f\n\n<!-- more -->","source":"_posts/博客源文件提交到仓库.md","raw":"---\ntitle:  源文件提交到仓库\ndate: \ntags:  [Hexo,git]\ncategories: 博客\ntoc: true\n---\n将博客源文件加入到仓库\n>git add .\ngit commit -m \" \"\ngit push origin master\ngit push origin master -f\n\n<!-- more -->","slug":"博客源文件提交到仓库","published":1,"updated":"2018-05-21T17:44:03.947Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloj0ln7005hykpbyc06t2vx"},{"title":"各种快捷键","date":"2018-06-21T15:40:13.306Z","toc":true,"_content":"\n\n![](https://ws2.sinaimg.cn/large/006tNbRwgy1fu565l9on8j30ps0iewev.jpg)\n\n一些常用快捷键让人事半功倍\n\n<!-- more -->\n​\t\n\n-----------\n|iterm|\n----------\n\n\tCommand + Shift + h \titerms2复制历史\n\n\t分屏\n\tcommand + option + 方向键 command + [ 或 command + ]   分屏切换屏幕\n\tControl + a        到行首\n\tControl + u        清除当前行\n\tControl + e\t   到行尾\n\tControl + p        / !! 上一条命令\n\tControl + k        从光标处删至命令行尾 (本来 Control + u 是删至命令行首，但iterm中是删掉整行)\n\tControl + w        A + d 从光标处删至字首/尾\n\tControl + k\t删除到文本末尾\n\tControl + h         删掉光标前的自负\n\tControl + d\t    删掉光标后的自负\n\tControl + r        搜索命令历史，这个较常用\n\n-------\n|Alfred|\n-------\n\tCommand + Option + C \tafrend剪切板历史 \n\tCommand + Option + / \tafrend路径历史 \n\tCommand + Option + \\\tafrend对搜索的路径进行操作 如复制等等\n\n\n​\t\n​\t\n​\t\n---------\n|sublime|\n---------\n\tCommand + Shift + d \t复制一行\n\tCommand + Option + f\t查找并替换\n\tCTRL + - 上个打开的文件\n\n------\n|idea|\n------\n\n\n\tCommand + Shift + F12   编栏全屏\t其实就是 Hide All Tool Windows (隐藏所有工具窗口) 这个操作的快捷键。\n\tCommand + Option + Space\t类名或接口名提示\n\tControl + ; \t\t是什么 代替鼠标\n\tCommand + l \t\t跳到指定行\n\tCommand + w \t\t关闭标签页 \n\tOption + 上 \t\t和windows的ctrl+w相同 递进选中代码块\n\tAlt + Insert Command + N \t\t\t\t代码自动生成，如生成对象的 set / get 方法，构造函数，toString() 等\n\tAlt + 前方向键 \tControl + 前方向键 \t\t\t当前光标跳转到当前文件的前一个方法名位置\n\tCtrl + Alt + Enter \tCommand + Option + Enter \t光标所在行上空出一行，光标定位到新行\n\tCtrl + Alt + 左方向键 \tCommand + Option + 左方向键 \t退回到上一个操作的地方\n\tCtrl + Alt + 右方向键 \tCommand + Option + 右方向键 \t前进到上一个操作的地方\n\tCommand + Option + T \t\t包围代码\n\tCommand + Shift +v \t\t历史 \n\tFind usage \t\t查看变量方法的类的直接使用情况\n\tShift + Enter \t\t开始新的一行\n\tCommand + P \t\t方法参数提示\n\tCommand + U \t\t前往父类\n\tCommand + +/- \t\t展开/折叠代码\n\tAlt + 1,2,3...9 \tCommand + 1,2,3...9 \t\t显示对应数值的选项卡，其中 1 是 Project 用得最多\n\tControl + Option + O \t优化导入的类，可以对当前文件和整个包目录使用\n\tCtrl + Alt + T \t对选中的代码弹出环绕选项弹出层\n\t\n\tControl + Option + H\t继承关系\n\tControl + H\t\t接口到实现类\n\n\n\tControl + Shift + J \t智能的将代码拼接成一行\n\tCommand+Alt+V \t引入变量，自动导入变量\n\tOption + F7 \t\t查询所选对象/变量被引用 \n\t\n\t4、类、方法、文件定位\n\t查找类 ctr + N\n \t查找文件 Ctrl + Shift + N\n \t符号定位 Ctrl + Alt + Shift + N\n \t查看文件结构 ctrl + F12\n \t最近打开的文件 ctr + E\n \t定位下一个方法 alt + down\n \t定位上一个方法 alt + up\n \t查看方法参数信息 ctr + p\n \t查看方法、类的 doc ctr + Q\n \t行数 Command + l\n\t5、类、方法的结构查看、定位\n \t跳到类或方法的声明 ctr + B\n \t定位到类的父类、接口 ctr + U 画图 ommand+Option+u\n \t查看类的继承结构 ctr + H\n \t查看方法的继承结构 ctr + Shift + H\n \t查看类或方法被调用情况 ctr + alt +H \n \t原地参看类、方法的声明 Ctrl + Shift + I\n​\t\n\tControl + H \t\t显示当前类的层次结构 继承\n\tCommand + Shift + H \t显示方法层次结构\n\tControl + Option + H \t显示调用层次结构\n\tCommand + L \t\t在当前文件跳转到某一行的指定处\n\t\n\tCommand + B / Command + 鼠标点击 进入光标所在的方法/变量的接口或是定义处\n\tCommand + Option + B \t跳转到实现处\n\tCommand + G \t\t查找模式下，向下查找\n\tCommand + Shift + U \t大小写切换\n\n-----\n|Mac|\n-----\n\n\n​\t\n\tShift+Command+G \t\t跳转打开文件夹 \n\tCommand + Shift + . \t\t显示隐藏文件 \n\tCommand + Control + 空格\t\temoji表情 \n\tShift + Option）+ K \t\tApple logo 「 」\n\tCommand+i \t\t\t简介 \n\tShift+Control+d \t\t搜狗表情包\n\n\n\tShift + Command + 空格 历史文件\n\tControl + Command +F 全屏模式\n\t\n\tCommand + z \t\t\t打开safari下最近关闭tab页面\n\t \t\t\n\tCommand + Option + Shift + Esc \t\t强制退出活跃的\n\tCommand + Option + Esc \t\t\t强制退出\n\tCommand + ` \t\t\t\t切换同一应用的窗口\n\n\n\tShift + Command + d alt + cmd + space \t快速打开finder\n\tcmd + Option + Shift + v \t\t去格式粘贴（亲测大部分软件都可以）\n\tCommand + Tab \t\t\t\t切换应用的时候，可以松开Tab，然后按Q退出选中的应用。\n\t\n\t三指点击网页链接，可以预览链接网页。\n\t按住右上角的新建选项卡按钮能快速浏览并选择最近关闭的窗口 \n\n--------\n|finder|\n--------\n\tCommand +  1，2，3\t\t图标，列表，分栏显示文件夹\n\tCommand + Control + P\t\t复制路径 自己配置\n\tCommand + Option + B\t\t快捷键标记 自己配置\n\tCommand + O\t\t\t打开文件夹\n\tCommand + 下 \t\t\t进入文件夹 \n\tCommand + 上\t \t\t返回文件夹\n\tCommand ＋［ \t\t\t返回\n\tCommand ＋ ］ \t\t\t前进\n\n--------\n| mac命令|\n--------\n\n\n\t根据 asker 提示 作补充：\n\tcommand + fn + 左/右，可以调整到文件开头 / 结尾。\n\t\n\tfn + 左/右相当于home/end在      网页和多数文档中适用。\n\n\n​\t\n\tdefaults write com.apple.finder QuitMenuItem -bool YES  设置finder可以关闭\n\n\topen -n /Applications/WizNote.app   多次打开一个应用\n\n\tmac 没有声音\n \tsudo kill -9 `ps ax|grep 'coreaudio[a-z]' |awk '{print $1}'`\n​\t\n \tsudo killall coreaudiod\n​\t\n​\t\n\t使用后的效果，可以说是非常明显了，再也不会有在「挤牙膏」的感觉。让它回到最开始的状态：\n\t\tdefaults delete com.apple.dock; killall Dock\n \t\tdefaults write com.apple.Dock autohide-delay -float 0 && killall Dock \n\t打开开机声音\n \t\tsudo nvram -d SystemAudioVolume\n\t双屏分任务工作！只要按住窗口左上角的绿色＋即可\n\n\t去掉资源库文件夹的隐藏属性\n \t\tchflags nohidden ~/Library/\n\t打开隐藏属性\n \t\tchflags hidden ~/Library/\n\t调节音量的同时按住\n \t\tOption + Shift键\n\t显示“隐藏文件” Command + Shift + .\n\t\tdefaults write com.apple.finder AppleShowAllFiles -bool true;killall Finder\n\t隐藏\n\t\tdefaults write com.apple.finder AppleShowAllFiles -bool true;killall Finder\n\t关闭开机声音\n\t\tsudo nvram SystemAudioVolume=%80，\n\t省略号 1、依次按 ⌃ ⌘ 空格\n \t2、⇧ 数字6\n\tOption 点击 Dock 图标，按住 Option 点击 Dock 中的图标，则会在桌面显示该应用所有窗口 \n\tOption + 左：向左移动一个单词\n\tOption + 右：向右移动一个单词\n\tOption + Delete：删除左边一个单词\n\tOption + Fn + Delete：删除右边一个单词\n\n\n\t设置 dock 显示时间命令\n\t打开终端输入以下命令\n\t#先修改停留时间（后面数字为停留时间）如：\n\tdefaults write com.apple.dock autohide-delay -int 0      ##（时间设为最短）\n\tdefaults write com.apple.dock autohide-delay -int 0.5    ##（时间设为 0.5s）\n\tdefaults write com.apple.dock autohide-delay -int 10     ##（时间设为 10s）\n\t#使设置生效\n\tkillall Dock\n\n\n​\t\n-----\n|推荐|\n-----\n\t再推荐个人 池健强 《人生元编程》作者 他的博客和微信上有很多干货\n\n​\t\n​\t\n","source":"_posts/各种快捷键.md","raw":"---\ntitle:  各种快捷键\ndate: 2018年06月21日 23时40分28秒\ntags:  [快捷键,Mac,Idea,Finder]\ncategories: 快捷键\ntoc: true\n---\n\n\n![](https://ws2.sinaimg.cn/large/006tNbRwgy1fu565l9on8j30ps0iewev.jpg)\n\n一些常用快捷键让人事半功倍\n\n<!-- more -->\n​\t\n\n-----------\n|iterm|\n----------\n\n\tCommand + Shift + h \titerms2复制历史\n\n\t分屏\n\tcommand + option + 方向键 command + [ 或 command + ]   分屏切换屏幕\n\tControl + a        到行首\n\tControl + u        清除当前行\n\tControl + e\t   到行尾\n\tControl + p        / !! 上一条命令\n\tControl + k        从光标处删至命令行尾 (本来 Control + u 是删至命令行首，但iterm中是删掉整行)\n\tControl + w        A + d 从光标处删至字首/尾\n\tControl + k\t删除到文本末尾\n\tControl + h         删掉光标前的自负\n\tControl + d\t    删掉光标后的自负\n\tControl + r        搜索命令历史，这个较常用\n\n-------\n|Alfred|\n-------\n\tCommand + Option + C \tafrend剪切板历史 \n\tCommand + Option + / \tafrend路径历史 \n\tCommand + Option + \\\tafrend对搜索的路径进行操作 如复制等等\n\n\n​\t\n​\t\n​\t\n---------\n|sublime|\n---------\n\tCommand + Shift + d \t复制一行\n\tCommand + Option + f\t查找并替换\n\tCTRL + - 上个打开的文件\n\n------\n|idea|\n------\n\n\n\tCommand + Shift + F12   编栏全屏\t其实就是 Hide All Tool Windows (隐藏所有工具窗口) 这个操作的快捷键。\n\tCommand + Option + Space\t类名或接口名提示\n\tControl + ; \t\t是什么 代替鼠标\n\tCommand + l \t\t跳到指定行\n\tCommand + w \t\t关闭标签页 \n\tOption + 上 \t\t和windows的ctrl+w相同 递进选中代码块\n\tAlt + Insert Command + N \t\t\t\t代码自动生成，如生成对象的 set / get 方法，构造函数，toString() 等\n\tAlt + 前方向键 \tControl + 前方向键 \t\t\t当前光标跳转到当前文件的前一个方法名位置\n\tCtrl + Alt + Enter \tCommand + Option + Enter \t光标所在行上空出一行，光标定位到新行\n\tCtrl + Alt + 左方向键 \tCommand + Option + 左方向键 \t退回到上一个操作的地方\n\tCtrl + Alt + 右方向键 \tCommand + Option + 右方向键 \t前进到上一个操作的地方\n\tCommand + Option + T \t\t包围代码\n\tCommand + Shift +v \t\t历史 \n\tFind usage \t\t查看变量方法的类的直接使用情况\n\tShift + Enter \t\t开始新的一行\n\tCommand + P \t\t方法参数提示\n\tCommand + U \t\t前往父类\n\tCommand + +/- \t\t展开/折叠代码\n\tAlt + 1,2,3...9 \tCommand + 1,2,3...9 \t\t显示对应数值的选项卡，其中 1 是 Project 用得最多\n\tControl + Option + O \t优化导入的类，可以对当前文件和整个包目录使用\n\tCtrl + Alt + T \t对选中的代码弹出环绕选项弹出层\n\t\n\tControl + Option + H\t继承关系\n\tControl + H\t\t接口到实现类\n\n\n\tControl + Shift + J \t智能的将代码拼接成一行\n\tCommand+Alt+V \t引入变量，自动导入变量\n\tOption + F7 \t\t查询所选对象/变量被引用 \n\t\n\t4、类、方法、文件定位\n\t查找类 ctr + N\n \t查找文件 Ctrl + Shift + N\n \t符号定位 Ctrl + Alt + Shift + N\n \t查看文件结构 ctrl + F12\n \t最近打开的文件 ctr + E\n \t定位下一个方法 alt + down\n \t定位上一个方法 alt + up\n \t查看方法参数信息 ctr + p\n \t查看方法、类的 doc ctr + Q\n \t行数 Command + l\n\t5、类、方法的结构查看、定位\n \t跳到类或方法的声明 ctr + B\n \t定位到类的父类、接口 ctr + U 画图 ommand+Option+u\n \t查看类的继承结构 ctr + H\n \t查看方法的继承结构 ctr + Shift + H\n \t查看类或方法被调用情况 ctr + alt +H \n \t原地参看类、方法的声明 Ctrl + Shift + I\n​\t\n\tControl + H \t\t显示当前类的层次结构 继承\n\tCommand + Shift + H \t显示方法层次结构\n\tControl + Option + H \t显示调用层次结构\n\tCommand + L \t\t在当前文件跳转到某一行的指定处\n\t\n\tCommand + B / Command + 鼠标点击 进入光标所在的方法/变量的接口或是定义处\n\tCommand + Option + B \t跳转到实现处\n\tCommand + G \t\t查找模式下，向下查找\n\tCommand + Shift + U \t大小写切换\n\n-----\n|Mac|\n-----\n\n\n​\t\n\tShift+Command+G \t\t跳转打开文件夹 \n\tCommand + Shift + . \t\t显示隐藏文件 \n\tCommand + Control + 空格\t\temoji表情 \n\tShift + Option）+ K \t\tApple logo 「 」\n\tCommand+i \t\t\t简介 \n\tShift+Control+d \t\t搜狗表情包\n\n\n\tShift + Command + 空格 历史文件\n\tControl + Command +F 全屏模式\n\t\n\tCommand + z \t\t\t打开safari下最近关闭tab页面\n\t \t\t\n\tCommand + Option + Shift + Esc \t\t强制退出活跃的\n\tCommand + Option + Esc \t\t\t强制退出\n\tCommand + ` \t\t\t\t切换同一应用的窗口\n\n\n\tShift + Command + d alt + cmd + space \t快速打开finder\n\tcmd + Option + Shift + v \t\t去格式粘贴（亲测大部分软件都可以）\n\tCommand + Tab \t\t\t\t切换应用的时候，可以松开Tab，然后按Q退出选中的应用。\n\t\n\t三指点击网页链接，可以预览链接网页。\n\t按住右上角的新建选项卡按钮能快速浏览并选择最近关闭的窗口 \n\n--------\n|finder|\n--------\n\tCommand +  1，2，3\t\t图标，列表，分栏显示文件夹\n\tCommand + Control + P\t\t复制路径 自己配置\n\tCommand + Option + B\t\t快捷键标记 自己配置\n\tCommand + O\t\t\t打开文件夹\n\tCommand + 下 \t\t\t进入文件夹 \n\tCommand + 上\t \t\t返回文件夹\n\tCommand ＋［ \t\t\t返回\n\tCommand ＋ ］ \t\t\t前进\n\n--------\n| mac命令|\n--------\n\n\n\t根据 asker 提示 作补充：\n\tcommand + fn + 左/右，可以调整到文件开头 / 结尾。\n\t\n\tfn + 左/右相当于home/end在      网页和多数文档中适用。\n\n\n​\t\n\tdefaults write com.apple.finder QuitMenuItem -bool YES  设置finder可以关闭\n\n\topen -n /Applications/WizNote.app   多次打开一个应用\n\n\tmac 没有声音\n \tsudo kill -9 `ps ax|grep 'coreaudio[a-z]' |awk '{print $1}'`\n​\t\n \tsudo killall coreaudiod\n​\t\n​\t\n\t使用后的效果，可以说是非常明显了，再也不会有在「挤牙膏」的感觉。让它回到最开始的状态：\n\t\tdefaults delete com.apple.dock; killall Dock\n \t\tdefaults write com.apple.Dock autohide-delay -float 0 && killall Dock \n\t打开开机声音\n \t\tsudo nvram -d SystemAudioVolume\n\t双屏分任务工作！只要按住窗口左上角的绿色＋即可\n\n\t去掉资源库文件夹的隐藏属性\n \t\tchflags nohidden ~/Library/\n\t打开隐藏属性\n \t\tchflags hidden ~/Library/\n\t调节音量的同时按住\n \t\tOption + Shift键\n\t显示“隐藏文件” Command + Shift + .\n\t\tdefaults write com.apple.finder AppleShowAllFiles -bool true;killall Finder\n\t隐藏\n\t\tdefaults write com.apple.finder AppleShowAllFiles -bool true;killall Finder\n\t关闭开机声音\n\t\tsudo nvram SystemAudioVolume=%80，\n\t省略号 1、依次按 ⌃ ⌘ 空格\n \t2、⇧ 数字6\n\tOption 点击 Dock 图标，按住 Option 点击 Dock 中的图标，则会在桌面显示该应用所有窗口 \n\tOption + 左：向左移动一个单词\n\tOption + 右：向右移动一个单词\n\tOption + Delete：删除左边一个单词\n\tOption + Fn + Delete：删除右边一个单词\n\n\n\t设置 dock 显示时间命令\n\t打开终端输入以下命令\n\t#先修改停留时间（后面数字为停留时间）如：\n\tdefaults write com.apple.dock autohide-delay -int 0      ##（时间设为最短）\n\tdefaults write com.apple.dock autohide-delay -int 0.5    ##（时间设为 0.5s）\n\tdefaults write com.apple.dock autohide-delay -int 10     ##（时间设为 10s）\n\t#使设置生效\n\tkillall Dock\n\n\n​\t\n-----\n|推荐|\n-----\n\t再推荐个人 池健强 《人生元编程》作者 他的博客和微信上有很多干货\n\n​\t\n​\t\n","slug":"各种快捷键","published":1,"updated":"2018-08-10T18:40:41.685Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloj0ln8005kykpbyt8h622e"},{"title":"命令积累","date":"2018-05-31T06:10:40.710Z","toc":true,"_content":"\n\n>bin /h dfs oev -i edits -o edits.xml 查看元数据\n>![示例](https://www.github.com/yaosong5/tuchuang/raw/master/mdtc/2018/5/31/1527747042953.jpg)\n\n<!-- more -->","source":"_posts/大数据命令积累.md","raw":"---\ntitle:  命令积累\ndate: \ntags:  [大数据,命令]\ncategories: 碎片知识\ntoc: true\n---\n\n\n>bin /h dfs oev -i edits -o edits.xml 查看元数据\n>![示例](https://www.github.com/yaosong5/tuchuang/raw/master/mdtc/2018/5/31/1527747042953.jpg)\n\n<!-- more -->","slug":"大数据命令积累","published":1,"updated":"2018-08-06T18:20:09.751Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloj0lna005pykpbj404mtln"},{"title":"部署博客到云服务器","date":"2018-05-20T16:56:17.069Z","toc":true,"_content":"\n\n\n![](https://ws2.sinaimg.cn/large/006tNbRwgy1fu566e9ybjj30kg05q0t0.jpg)\n\n简单记录转移到博客到云服务器\n<!-- more -->\n\n#  原理及准备\n>我们在自己的电脑上写好博客, 使用 git 发布到代码仓库进行备份, git 仓库接收到 push 请求后, 使用 webhook 配合 nodejs 自动进行服务器端页面的更新.\n## 准备\n安装Git和NodeJS (CentOS 环境)\n\n``` \nyum install git\n```\n安装NodeJS\n\n``` vim\ncurl --silent --location https://rpm.nodesource.com/setup_5.x | bash -\n```\n\n# 服务器构建\n## webhook方式\n服务器端的” 钩子”\n我们借助一个 node 插件 github-webhook-handler 来快速完成配合 github webhook 的操作, 其他 git 平台也有相应的插件, 如配合 coding 的 coding-webhook-handler.\n\n### 监听脚本\n>我们借助一个 node 插件 *github webhook-handler*来快速完成配合 github webhook 的操作, 其他 git 平台也有相应的插件, 如配合 coding 的 coding-webhook-handler.\n\n使用 `npm install -g github-webhook-handler` 命令来安装到服务器端.\nconding则为`npm install -g coding-webhook-handler` \n\n\n>切换到服务器站点目录，如我的是 /root/blog,新建一个public目录，将你的github仓库中的master分支pull到该目录中，这个目录作为这个博客的根目录了\n\n```bash\ncd /root/blog\nmkdir public \ncd public \ngit init\ngit remote add origin https://github.com/yaosong5/yaosong5.github.io\ngit pull origin master\n```\n\n\n然后我们创建一个webhooks.js文件，将以下的内容粘贴，这相当于Node.js **服务器**的代码构建\n\n\n\n``` javascript\nvar http = require('http')\nvar createHandler = require('github-webhook-handler')\nvar handler = createHandler({ path: '/', secret: 'yao' })\n\nfunction run_cmd(cmd, args, callback) {\n  var spawn = require('child_process').spawn;\n  var child = spawn(cmd, args);\n  var resp = \"\";\n\n  child.stdout.on('data', function(buffer) { resp += buffer.toString(); });\n  child.stdout.on('end', function() { callback (resp) });\n}\n\nhttp.createServer(function (req, res) {\n  handler(req, res, function (err) {\n    res.statusCode = 404\n    res.end('no such location')\n  })\n}).listen(7777)\n\nhandler.on('error', function (err) {\n  console.error('Error:', err.message)\n})\n\nhandler.on('push', function (event) {\n  console.log('Received a push event for %s to %s',\n    event.payload.repository.name,\n    event.payload.ref);\n    run_cmd('sh', ['./deploy.sh',event.payload.repository.name], function(text){ console.log(text) });\n})\n```\n\n注意上段代码中第 3 行 { path: '/', secret: '改为你的secret' } 中 secret 可以改为你喜欢的口令, 这口令将在下面的步骤中起到作用 ,配置github webhooks的时候填入的口令, 请留意. 第 19 行 listen(7777) 中 7777 为监听程序需要使用的端口.\n\n### 执行脚本\n上面的 javascript 代码是用来捕捉 github 发来的信号并发起一个执行 ./deploy.sh 的脚本, 接下来我们还需要写 deploy.sh 的内容.\n\n``` bash\n#!/bin/bash\n\nWEB_PATH='/root/blog/public'\n\necho \"Start deployment\"\ncd $WEB_PATH\necho \"pulling source code...\"\ngit reset --hard origin/master\ngit clean -f\ngit pull\ngit checkout master\necho \"Finished.\"\n```\n\n将以上代码的第 3 行改为你服务器中的实际目录. 接下来只需要开启监听就可以了.\n\n\ntips: 在此之前你可以使用 node webhook.js 来测试一下监听程序是否能够正常运行.\n我在这里碰到了一个 node 环境变量的问题, 读取不到 github-webhook-handler 这个模块, 找了很多办法也没有解决, 后来我直接在项目根目录的上级目录安装了这个模块, 问题就解决了.\n\n>cd /root/blog\n>npm install github-webhook-handler\n>npm 会从当前目录依次向上寻找含有 node_modules 目录并访问该模块.\n\n### 普通方式运行 webhook.js\n利用 Linux 提供的 nohup 命令，让 webhooks.js 运行在后台\n\n```\nnohup node webhook.js > deploy.log &\n```\n###  Forever方式运行webhook.js\n>我在实际使用的时候发现，我的 Node 服务器时不时会自动停掉，具体原因我暂时还没有弄清楚。不过似乎很多人都遇到了这样的困扰，要解决这个问题，forever 是个不错的选择。借助 forever 这个库，它可以保证 Node 持续运行下去，一旦服务器挂了，它都会重启服务器。\n\n安装 forever：\n` npm install -g forever`\n运行：\n``` \ncd { 部署服务器的根目录 }\n nohup forever start webhook.js > deploy.log &\n```\n Ubuntu 中原本就有一个叫 node 的包。为了避免冲突，在 Ubuntu 上安装或使用 Node 得用 nodejs 这个名字。而 forever 默认是使用 node 作为执行脚本的程序名。所以为了处理 Ubuntu 存在的这种特殊情况，在启动 forever 时得另外添加一个参数：(其它则忽略)\n\n`forever start webhook.js -c nodejs`\n### Github配置webhooks\n配置好 Webhook 后，Github 会发送一个 ping 来测试这个地址。如果成功了，那么这个 Webhook 前就会加上一个绿色的勾；如果你得到的是一个红色的叉，那就好好检查一下哪儿出问题了吧！\n## git-hook方式\n可采用一种更为简单的部署方式\n>这种方式和webhook可二选一\n\n### 服务器上建立git裸库\n\n创建一个裸仓库，裸仓库就是只保存git信息的Repository, 首先切换到git用户确保git用户拥有仓库所有权\n一定要加 --bare，这样才是一个裸库。\n\n```\ncd \ngit init --bare blog.git\n```\n### 使用 git-hooks 同步网站根目录\n\n\n在这里我们使用的是 post-receive这个钩子，当git有收发的时候就会调用这个钩子。 在 ~/blog.git 裸库的 hooks文件夹中，\n新建post-receive文件。\n>vim ~/blog.git/hooks/post-receive\n\n填入以下内容\n\n``` bash\n#!/bin/sh\ngit --work-tree=/root/blog/public --git-dir=/root/blog.git checkout -f\n```\n\n*work-tree=/root/blog/public这个目录是网站的网页文件目录，--git-dir=/root/blog.git目录为裸库地址，裸库监听git提交会将文件提交到网页目录*\n保存后，要赋予这个文件可执行权限`chmod +x post-receive`\n### 配置博客根目录_config.yml\n完成自动化部署\n打开 _config.yml, 找到 deploy\n```\ndeploy:\n    type: git\n    repo: 用户名@SERVER名:/home/git/blog.git（裸库地址）    //<repository url>\n    branch: master            //这里填写分支   [branch]\n    message: 提交的信息         //自定义提交信息 (默认为 Site updated: {{ now('YYYY-MM-DD HH:mm:ss') }})\n```\n\n# Nginx服务\nnpm 安装nginx\n启动nginx \n\n``` bash\nservice nginx start\n```\n`nginx -t` 查看nginx配置文件\n若nginx服务启动，访问报403错误\n 则将首行 user nginx 改为user root\n\n``` \nvim /etc/nginx/nginx.conf\nserver {\n    listen          80;  # 监听端口\n    server_name     47.98.141.252:80 gangtieguo.cn wwww.gangtieguo.cn;  # 你的域名\n    location / {\n        root        /root/blog/public;\n        index       index.html;\n    }\n}\n```\n**重载 nginx，使配置生效**\n\n```nginx -s reload```\n\n参考\n[Hexo 静态博客搭建并实现自动部署到远程 vps](https://www.jianshu.com/p/b29a2e40501f)\n[将 Hexo 博客发布到自己的服务器上](https://blog.mutoe.com/2017/deploy-hexo-website-to-self-server/)\n[利用 Github 的 Webhook 功能和 Node.js 完成项目的自动部署](https://www.jianshu.com/p/e4cacd775e5b)\n[Webhook 实践 —— 自动部署](https://segmentfault.com/a/1190000003908244)\n[Hexo 快速搭建静态博客并实现远程 VPS 自动部署](http://imlianer.com/a/deploy-hexo-on-vps)\n[阿里云 VPS 搭建自己的的 Hexo 博客](https://segmentfault.com/a/1190000005723321)","source":"_posts/转移Github博客到云服务器.md","raw":"---\ntitle:  部署博客到云服务器\ndate: 2018年05月21日 00时54分48秒\ntags:  [Hexo]\ncategories: 博客\ntoc: true\n---\n\n\n\n![](https://ws2.sinaimg.cn/large/006tNbRwgy1fu566e9ybjj30kg05q0t0.jpg)\n\n简单记录转移到博客到云服务器\n<!-- more -->\n\n#  原理及准备\n>我们在自己的电脑上写好博客, 使用 git 发布到代码仓库进行备份, git 仓库接收到 push 请求后, 使用 webhook 配合 nodejs 自动进行服务器端页面的更新.\n## 准备\n安装Git和NodeJS (CentOS 环境)\n\n``` \nyum install git\n```\n安装NodeJS\n\n``` vim\ncurl --silent --location https://rpm.nodesource.com/setup_5.x | bash -\n```\n\n# 服务器构建\n## webhook方式\n服务器端的” 钩子”\n我们借助一个 node 插件 github-webhook-handler 来快速完成配合 github webhook 的操作, 其他 git 平台也有相应的插件, 如配合 coding 的 coding-webhook-handler.\n\n### 监听脚本\n>我们借助一个 node 插件 *github webhook-handler*来快速完成配合 github webhook 的操作, 其他 git 平台也有相应的插件, 如配合 coding 的 coding-webhook-handler.\n\n使用 `npm install -g github-webhook-handler` 命令来安装到服务器端.\nconding则为`npm install -g coding-webhook-handler` \n\n\n>切换到服务器站点目录，如我的是 /root/blog,新建一个public目录，将你的github仓库中的master分支pull到该目录中，这个目录作为这个博客的根目录了\n\n```bash\ncd /root/blog\nmkdir public \ncd public \ngit init\ngit remote add origin https://github.com/yaosong5/yaosong5.github.io\ngit pull origin master\n```\n\n\n然后我们创建一个webhooks.js文件，将以下的内容粘贴，这相当于Node.js **服务器**的代码构建\n\n\n\n``` javascript\nvar http = require('http')\nvar createHandler = require('github-webhook-handler')\nvar handler = createHandler({ path: '/', secret: 'yao' })\n\nfunction run_cmd(cmd, args, callback) {\n  var spawn = require('child_process').spawn;\n  var child = spawn(cmd, args);\n  var resp = \"\";\n\n  child.stdout.on('data', function(buffer) { resp += buffer.toString(); });\n  child.stdout.on('end', function() { callback (resp) });\n}\n\nhttp.createServer(function (req, res) {\n  handler(req, res, function (err) {\n    res.statusCode = 404\n    res.end('no such location')\n  })\n}).listen(7777)\n\nhandler.on('error', function (err) {\n  console.error('Error:', err.message)\n})\n\nhandler.on('push', function (event) {\n  console.log('Received a push event for %s to %s',\n    event.payload.repository.name,\n    event.payload.ref);\n    run_cmd('sh', ['./deploy.sh',event.payload.repository.name], function(text){ console.log(text) });\n})\n```\n\n注意上段代码中第 3 行 { path: '/', secret: '改为你的secret' } 中 secret 可以改为你喜欢的口令, 这口令将在下面的步骤中起到作用 ,配置github webhooks的时候填入的口令, 请留意. 第 19 行 listen(7777) 中 7777 为监听程序需要使用的端口.\n\n### 执行脚本\n上面的 javascript 代码是用来捕捉 github 发来的信号并发起一个执行 ./deploy.sh 的脚本, 接下来我们还需要写 deploy.sh 的内容.\n\n``` bash\n#!/bin/bash\n\nWEB_PATH='/root/blog/public'\n\necho \"Start deployment\"\ncd $WEB_PATH\necho \"pulling source code...\"\ngit reset --hard origin/master\ngit clean -f\ngit pull\ngit checkout master\necho \"Finished.\"\n```\n\n将以上代码的第 3 行改为你服务器中的实际目录. 接下来只需要开启监听就可以了.\n\n\ntips: 在此之前你可以使用 node webhook.js 来测试一下监听程序是否能够正常运行.\n我在这里碰到了一个 node 环境变量的问题, 读取不到 github-webhook-handler 这个模块, 找了很多办法也没有解决, 后来我直接在项目根目录的上级目录安装了这个模块, 问题就解决了.\n\n>cd /root/blog\n>npm install github-webhook-handler\n>npm 会从当前目录依次向上寻找含有 node_modules 目录并访问该模块.\n\n### 普通方式运行 webhook.js\n利用 Linux 提供的 nohup 命令，让 webhooks.js 运行在后台\n\n```\nnohup node webhook.js > deploy.log &\n```\n###  Forever方式运行webhook.js\n>我在实际使用的时候发现，我的 Node 服务器时不时会自动停掉，具体原因我暂时还没有弄清楚。不过似乎很多人都遇到了这样的困扰，要解决这个问题，forever 是个不错的选择。借助 forever 这个库，它可以保证 Node 持续运行下去，一旦服务器挂了，它都会重启服务器。\n\n安装 forever：\n` npm install -g forever`\n运行：\n``` \ncd { 部署服务器的根目录 }\n nohup forever start webhook.js > deploy.log &\n```\n Ubuntu 中原本就有一个叫 node 的包。为了避免冲突，在 Ubuntu 上安装或使用 Node 得用 nodejs 这个名字。而 forever 默认是使用 node 作为执行脚本的程序名。所以为了处理 Ubuntu 存在的这种特殊情况，在启动 forever 时得另外添加一个参数：(其它则忽略)\n\n`forever start webhook.js -c nodejs`\n### Github配置webhooks\n配置好 Webhook 后，Github 会发送一个 ping 来测试这个地址。如果成功了，那么这个 Webhook 前就会加上一个绿色的勾；如果你得到的是一个红色的叉，那就好好检查一下哪儿出问题了吧！\n## git-hook方式\n可采用一种更为简单的部署方式\n>这种方式和webhook可二选一\n\n### 服务器上建立git裸库\n\n创建一个裸仓库，裸仓库就是只保存git信息的Repository, 首先切换到git用户确保git用户拥有仓库所有权\n一定要加 --bare，这样才是一个裸库。\n\n```\ncd \ngit init --bare blog.git\n```\n### 使用 git-hooks 同步网站根目录\n\n\n在这里我们使用的是 post-receive这个钩子，当git有收发的时候就会调用这个钩子。 在 ~/blog.git 裸库的 hooks文件夹中，\n新建post-receive文件。\n>vim ~/blog.git/hooks/post-receive\n\n填入以下内容\n\n``` bash\n#!/bin/sh\ngit --work-tree=/root/blog/public --git-dir=/root/blog.git checkout -f\n```\n\n*work-tree=/root/blog/public这个目录是网站的网页文件目录，--git-dir=/root/blog.git目录为裸库地址，裸库监听git提交会将文件提交到网页目录*\n保存后，要赋予这个文件可执行权限`chmod +x post-receive`\n### 配置博客根目录_config.yml\n完成自动化部署\n打开 _config.yml, 找到 deploy\n```\ndeploy:\n    type: git\n    repo: 用户名@SERVER名:/home/git/blog.git（裸库地址）    //<repository url>\n    branch: master            //这里填写分支   [branch]\n    message: 提交的信息         //自定义提交信息 (默认为 Site updated: {{ now('YYYY-MM-DD HH:mm:ss') }})\n```\n\n# Nginx服务\nnpm 安装nginx\n启动nginx \n\n``` bash\nservice nginx start\n```\n`nginx -t` 查看nginx配置文件\n若nginx服务启动，访问报403错误\n 则将首行 user nginx 改为user root\n\n``` \nvim /etc/nginx/nginx.conf\nserver {\n    listen          80;  # 监听端口\n    server_name     47.98.141.252:80 gangtieguo.cn wwww.gangtieguo.cn;  # 你的域名\n    location / {\n        root        /root/blog/public;\n        index       index.html;\n    }\n}\n```\n**重载 nginx，使配置生效**\n\n```nginx -s reload```\n\n参考\n[Hexo 静态博客搭建并实现自动部署到远程 vps](https://www.jianshu.com/p/b29a2e40501f)\n[将 Hexo 博客发布到自己的服务器上](https://blog.mutoe.com/2017/deploy-hexo-website-to-self-server/)\n[利用 Github 的 Webhook 功能和 Node.js 完成项目的自动部署](https://www.jianshu.com/p/e4cacd775e5b)\n[Webhook 实践 —— 自动部署](https://segmentfault.com/a/1190000003908244)\n[Hexo 快速搭建静态博客并实现远程 VPS 自动部署](http://imlianer.com/a/deploy-hexo-on-vps)\n[阿里云 VPS 搭建自己的的 Hexo 博客](https://segmentfault.com/a/1190000005723321)","slug":"转移Github博客到云服务器","published":1,"updated":"2018-08-10T18:32:14.487Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjloj0lnb005sykpbi7n5gred"}],"PostAsset":[],"PostCategory":[{"post_id":"cjloj0lkn0003ykpbliui7vle","category_id":"cjloj0lku0006ykpbnknh43bb","_id":"cjloj0ll4000gykpbvyzj7yq7"},{"post_id":"cjloj0lks0005ykpbazt8qz2y","category_id":"cjloj0lku0006ykpbnknh43bb","_id":"cjloj0ll8000nykpbqxgc9uri"},{"post_id":"cjloj0lkw0008ykpb5avrv6t3","category_id":"cjloj0lku0006ykpbnknh43bb","_id":"cjloj0llb000tykpbft7kbhpv"},{"post_id":"cjloj0ll9000qykpb5yhcvqab","category_id":"cjloj0ll8000mykpbz1ncrhz7","_id":"cjloj0lld000zykpbtajdbvld"},{"post_id":"cjloj0lky0009ykpbhomts40h","category_id":"cjloj0ll8000mykpbz1ncrhz7","_id":"cjloj0lle0013ykpbwhhaxnjz"},{"post_id":"cjloj0lla000sykpbhafm48qd","category_id":"cjloj0ll8000mykpbz1ncrhz7","_id":"cjloj0llg0016ykpb6huqwulx"},{"post_id":"cjloj0llc000xykpbr76wxx2c","category_id":"cjloj0ll8000mykpbz1ncrhz7","_id":"cjloj0llh001aykpbidop6mxf"},{"post_id":"cjloj0lkz000aykpbb3ixkpn4","category_id":"cjloj0llb000uykpblque9q6n","_id":"cjloj0lli001eykpb6p02lfkx"},{"post_id":"cjloj0llc000yykpbuqo65hwa","category_id":"cjloj0ll8000mykpbz1ncrhz7","_id":"cjloj0llj001hykpbpr42zkyv"},{"post_id":"cjloj0lle0012ykpbhgvw700x","category_id":"cjloj0ll8000mykpbz1ncrhz7","_id":"cjloj0llk001kykpbtn4lp3os"},{"post_id":"cjloj0ll2000dykpbb2gr2qdq","category_id":"cjloj0llb000uykpblque9q6n","_id":"cjloj0llm001nykpb9tfpiyda"},{"post_id":"cjloj0llf0015ykpbxzgr3v4u","category_id":"cjloj0ll8000mykpbz1ncrhz7","_id":"cjloj0llo001qykpbpkah7q69"},{"post_id":"cjloj0llg0019ykpb5c4es12n","category_id":"cjloj0ll8000mykpbz1ncrhz7","_id":"cjloj0llp001tykpbuqc5z5o9"},{"post_id":"cjloj0ll3000eykpbd6sckh8u","category_id":"cjloj0llg0017ykpboykk81w1","_id":"cjloj0llr001xykpba24gpdnq"},{"post_id":"cjloj0llh001dykpbriihxwra","category_id":"cjloj0ll8000mykpbz1ncrhz7","_id":"cjloj0lls0021ykpbf67qontq"},{"post_id":"cjloj0llj001gykpb8h5czhiu","category_id":"cjloj0lku0006ykpbnknh43bb","_id":"cjloj0llt0024ykpb1h2q0ev3"},{"post_id":"cjloj0ll5000jykpbpv7o6771","category_id":"cjloj0llb000uykpblque9q6n","_id":"cjloj0llu0029ykpbq36le30h"},{"post_id":"cjloj0llk001jykpbpblb368u","category_id":"cjloj0ll8000mykpbz1ncrhz7","_id":"cjloj0llv002bykpbe8qmqv39"},{"post_id":"cjloj0lll001mykpbgj0uwm5h","category_id":"cjloj0ll8000mykpbz1ncrhz7","_id":"cjloj0llx002eykpbsnkgalvj"},{"post_id":"cjloj0ll7000lykpbsrjgnpq1","category_id":"cjloj0ll8000mykpbz1ncrhz7","_id":"cjloj0lly002iykpb0mpamzkz"},{"post_id":"cjloj0lln001pykpb3pl3jqux","category_id":"cjloj0ll8000mykpbz1ncrhz7","_id":"cjloj0lm0002mykpbpw0c0g6l"},{"post_id":"cjloj0lls0023ykpby6ypiqxr","category_id":"cjloj0lku0006ykpbnknh43bb","_id":"cjloj0lm2002qykpb7n39aesh"},{"post_id":"cjloj0llp001sykpb2l9tgd2j","category_id":"cjloj0llr001zykpbvxbp1nfg","_id":"cjloj0lm3002uykpbcn4mptwd"},{"post_id":"cjloj0llu002aykpb69h6jg13","category_id":"cjloj0lku0006ykpbnknh43bb","_id":"cjloj0lm4002yykpb858fhx8c"},{"post_id":"cjloj0llq001wykpbumswwezx","category_id":"cjloj0llu0028ykpb8krs5csd","_id":"cjloj0lm60032ykpbc4z94uoj"},{"post_id":"cjloj0llw002dykpbzwg3lzuf","category_id":"cjloj0ll8000mykpbz1ncrhz7","_id":"cjloj0lm70036ykpbxee6mwkk"},{"post_id":"cjloj0llr0020ykpbdxy460wh","category_id":"cjloj0llu0028ykpb8krs5csd","_id":"cjloj0lm8003aykpbp5wsr8mx"},{"post_id":"cjloj0lm1002pykpbnmn5vwe8","category_id":"cjloj0ll8000mykpbz1ncrhz7","_id":"cjloj0lma003eykpb75207uu0"},{"post_id":"cjloj0llt0027ykpbiyqr5rra","category_id":"cjloj0lm0002oykpblp2ugp3u","_id":"cjloj0lmb003iykpbd7311zea"},{"post_id":"cjloj0lly002hykpb28n299vd","category_id":"cjloj0lm3002wykpbtiyfyzfu","_id":"cjloj0lmd003lykpbkecje5qk"},{"post_id":"cjloj0lm80039ykpburkj5bss","category_id":"cjloj0ll8000mykpbz1ncrhz7","_id":"cjloj0lmf003qykpberotfpxb"},{"post_id":"cjloj0llz002lykpblkrgfwsr","category_id":"cjloj0lm60034ykpb77er2dcs","_id":"cjloj0lmh003tykpbx5yyeei2"},{"post_id":"cjloj0lm9003cykpbcuv7s64k","category_id":"cjloj0ll8000mykpbz1ncrhz7","_id":"cjloj0lmj003yykpbp45amr5v"},{"post_id":"cjloj0lmb003hykpbl29fvuxu","category_id":"cjloj0ll8000mykpbz1ncrhz7","_id":"cjloj0lmk0041ykpb9pu5uf1e"},{"post_id":"cjloj0lm2002tykpb18srbtw5","category_id":"cjloj0lma003dykpb6afh0fjf","_id":"cjloj0lmn0046ykpbu15cid8t"},{"post_id":"cjloj0lme003pykpbvuxngkmp","category_id":"cjloj0ll8000mykpbz1ncrhz7","_id":"cjloj0lmp0049ykpbye2ij45e"},{"post_id":"cjloj0lm3002xykpbgp6zoc86","category_id":"cjloj0lma003dykpb6afh0fjf","_id":"cjloj0lmq004dykpbf53cno68"},{"post_id":"cjloj0lmg003sykpb0a4821m7","category_id":"cjloj0ll8000mykpbz1ncrhz7","_id":"cjloj0lms004gykpbeyt56tkx"},{"post_id":"cjloj0lmi003xykpbcxxcv4l3","category_id":"cjloj0ll8000mykpbz1ncrhz7","_id":"cjloj0lmt004kykpb6q8bmjkn"},{"post_id":"cjloj0lm50031ykpbixeqhdpc","category_id":"cjloj0lma003dykpb6afh0fjf","_id":"cjloj0lmu004nykpbyzp0hdr3"},{"post_id":"cjloj0lmj0040ykpbp5td5xiy","category_id":"cjloj0ll8000mykpbz1ncrhz7","_id":"cjloj0lmw004rykpbnl31r6ta"},{"post_id":"cjloj0lml0045ykpbjo7jgagw","category_id":"cjloj0ll8000mykpbz1ncrhz7","_id":"cjloj0lmx004vykpb0r0vibct"},{"post_id":"cjloj0lm60035ykpbeg9vge1b","category_id":"cjloj0lma003dykpb6afh0fjf","_id":"cjloj0lmz004yykpbry79dfpi"},{"post_id":"cjloj0lmo0048ykpb26y9dnd6","category_id":"cjloj0lku0006ykpbnknh43bb","_id":"cjloj0ln00052ykpb2lbbsxjz"},{"post_id":"cjloj0lmq004cykpboq4t2xna","category_id":"cjloj0lku0006ykpbnknh43bb","_id":"cjloj0ln30056ykpb8z2uw0pz"},{"post_id":"cjloj0lmr004fykpbncq6dtnc","category_id":"cjloj0lku0006ykpbnknh43bb","_id":"cjloj0ln5005aykpblt28ni4i"},{"post_id":"cjloj0lmu004mykpbgguz7qb4","category_id":"cjloj0lku0006ykpbnknh43bb","_id":"cjloj0ln7005eykpbobt9aa43"},{"post_id":"cjloj0lmv004qykpbcmuge83p","category_id":"cjloj0lku0006ykpbnknh43bb","_id":"cjloj0ln8005iykpbkdthcygu"},{"post_id":"cjloj0lmw004uykpby2cpmzx4","category_id":"cjloj0lku0006ykpbnknh43bb","_id":"cjloj0ln9005lykpbidrxsjrg"},{"post_id":"cjloj0lmt004jykpbhiq1ifth","category_id":"cjloj0lmv004oykpbj3og8pzy","_id":"cjloj0lnb005qykpb9pfjip6h"},{"post_id":"cjloj0ln00051ykpb2io7zp9f","category_id":"cjloj0ll8000mykpbz1ncrhz7","_id":"cjloj0lnc005tykpbrvwzr8y1"},{"post_id":"cjloj0ln40059ykpbs62pnu8z","category_id":"cjloj0lku0006ykpbnknh43bb","_id":"cjloj0lnd005xykpb0p0opkgo"},{"post_id":"cjloj0lmy004xykpb9lj8xkwx","category_id":"cjloj0ln10053ykpbzcpooyj7","_id":"cjloj0lnd005zykpbwbx54kak"},{"post_id":"cjloj0ln20055ykpbm95jzsrj","category_id":"cjloj0ln6005dykpb0v025wio","_id":"cjloj0lne0063ykpbhpjveq3n"},{"post_id":"cjloj0ln5005cykpbea1gkz7s","category_id":"cjloj0lna005mykpbtuu8tfya","_id":"cjloj0lnf0065ykpb4mhbbemq"},{"post_id":"cjloj0ln7005hykpbyc06t2vx","category_id":"cjloj0lnc005uykpbncvxh9gn","_id":"cjloj0lnf0069ykpbaryntwq9"},{"post_id":"cjloj0ln8005kykpbyt8h622e","category_id":"cjloj0lne0061ykpb5ins0d50","_id":"cjloj0lng006dykpbbvumqle7"},{"post_id":"cjloj0lna005pykpbj404mtln","category_id":"cjloj0lnf0068ykpbcwuvx1fq","_id":"cjloj0lnh006hykpbbvwzoc2r"},{"post_id":"cjloj0lnb005sykpbi7n5gred","category_id":"cjloj0lnc005uykpbncvxh9gn","_id":"cjloj0lni006lykpbqj5j7zan"}],"PostTag":[{"post_id":"cjloj0ll2000dykpbb2gr2qdq","tag_id":"cjloj0lkw0007ykpbfsq2874z","_id":"cjloj0ll5000iykpb4bgu2dlv"},{"post_id":"cjloj0lkn0003ykpbliui7vle","tag_id":"cjloj0lkw0007ykpbfsq2874z","_id":"cjloj0ll7000kykpbwqnejp7e"},{"post_id":"cjloj0lkn0003ykpbliui7vle","tag_id":"cjloj0ll1000cykpbmhqt2xv7","_id":"cjloj0ll8000pykpbk9iu4a62"},{"post_id":"cjloj0ll5000jykpbpv7o6771","tag_id":"cjloj0lkw0007ykpbfsq2874z","_id":"cjloj0lla000rykpbilt9obze"},{"post_id":"cjloj0lks0005ykpbazt8qz2y","tag_id":"cjloj0ll5000hykpb20lkt6lr","_id":"cjloj0llb000wykpbchuo6ag5"},{"post_id":"cjloj0lkw0008ykpb5avrv6t3","tag_id":"cjloj0lkw0007ykpbfsq2874z","_id":"cjloj0llf0014ykpb20i1z07h"},{"post_id":"cjloj0lkw0008ykpb5avrv6t3","tag_id":"cjloj0llb000vykpbl0afku54","_id":"cjloj0llg0018ykpbolh3a43c"},{"post_id":"cjloj0lky0009ykpbhomts40h","tag_id":"cjloj0lle0011ykpbam3ai8su","_id":"cjloj0llh001cykpbbtn11ozv"},{"post_id":"cjloj0lkz000aykpbb3ixkpn4","tag_id":"cjloj0lkw0007ykpbfsq2874z","_id":"cjloj0llo001rykpb058juygs"},{"post_id":"cjloj0lkz000aykpbb3ixkpn4","tag_id":"cjloj0llh001bykpbjply43s2","_id":"cjloj0llq001uykpbzbhwdgnn"},{"post_id":"cjloj0lkz000aykpbb3ixkpn4","tag_id":"cjloj0llk001iykpbng7kqfgo","_id":"cjloj0llr001yykpb7awyiuo8"},{"post_id":"cjloj0ll3000eykpbd6sckh8u","tag_id":"cjloj0lkw0007ykpbfsq2874z","_id":"cjloj0lls0022ykpb5xql7owu"},{"post_id":"cjloj0ll3000eykpbd6sckh8u","tag_id":"cjloj0llm001oykpb2uoer3hb","_id":"cjloj0llt0026ykpblrss9p8a"},{"post_id":"cjloj0ll7000lykpbsrjgnpq1","tag_id":"cjloj0llq001vykpb0tapwavs","_id":"cjloj0llx002fykpbmmmy7ew3"},{"post_id":"cjloj0ll7000lykpbsrjgnpq1","tag_id":"cjloj0llt0025ykpbmj2193ss","_id":"cjloj0lly002jykpb8s7tf11p"},{"post_id":"cjloj0llw002dykpbzwg3lzuf","tag_id":"cjloj0llm001oykpb2uoer3hb","_id":"cjloj0lm0002nykpbkffkj9xw"},{"post_id":"cjloj0llw002dykpbzwg3lzuf","tag_id":"cjloj0llt0025ykpbmj2193ss","_id":"cjloj0lm2002rykpb9f7j686j"},{"post_id":"cjloj0ll9000qykpb5yhcvqab","tag_id":"cjloj0llq001vykpb0tapwavs","_id":"cjloj0lm3002vykpbf9649i5l"},{"post_id":"cjloj0ll9000qykpb5yhcvqab","tag_id":"cjloj0llz002kykpbutsr3yf5","_id":"cjloj0lm4002zykpbtja4hnxx"},{"post_id":"cjloj0lm3002xykpbgp6zoc86","tag_id":"cjloj0lle0011ykpbam3ai8su","_id":"cjloj0lm60033ykpbjxiyfz83"},{"post_id":"cjloj0lm3002xykpbgp6zoc86","tag_id":"cjloj0llt0025ykpbmj2193ss","_id":"cjloj0lm70037ykpbh60zzvl5"},{"post_id":"cjloj0lm50031ykpbixeqhdpc","tag_id":"cjloj0lle0011ykpbam3ai8su","_id":"cjloj0lm9003bykpbpxnt8i1a"},{"post_id":"cjloj0lm50031ykpbixeqhdpc","tag_id":"cjloj0llt0025ykpbmj2193ss","_id":"cjloj0lma003fykpbvcyzqs7g"},{"post_id":"cjloj0lm60035ykpbeg9vge1b","tag_id":"cjloj0lle0011ykpbam3ai8su","_id":"cjloj0lmc003jykpbvwkn9ygt"},{"post_id":"cjloj0lm60035ykpbeg9vge1b","tag_id":"cjloj0llt0025ykpbmj2193ss","_id":"cjloj0lme003nykpbytu8qwla"},{"post_id":"cjloj0lla000sykpbhafm48qd","tag_id":"cjloj0lm2002sykpb6mxbdz3n","_id":"cjloj0lmg003rykpb99k4zmim"},{"post_id":"cjloj0lla000sykpbhafm48qd","tag_id":"cjloj0llt0025ykpbmj2193ss","_id":"cjloj0lmh003vykpbavw95nhx"},{"post_id":"cjloj0lla000sykpbhafm48qd","tag_id":"cjloj0llm001oykpb2uoer3hb","_id":"cjloj0lmj003zykpbvoaggc5a"},{"post_id":"cjloj0llc000xykpbr76wxx2c","tag_id":"cjloj0llm001oykpb2uoer3hb","_id":"cjloj0lml0043ykpb3ppaa8e4"},{"post_id":"cjloj0lme003pykpbvuxngkmp","tag_id":"cjloj0lle0011ykpbam3ai8su","_id":"cjloj0lmo0047ykpbwfpipfk7"},{"post_id":"cjloj0lme003pykpbvuxngkmp","tag_id":"cjloj0llt0025ykpbmj2193ss","_id":"cjloj0lmp004aykpbyslukllm"},{"post_id":"cjloj0lmg003sykpb0a4821m7","tag_id":"cjloj0lle0011ykpbam3ai8su","_id":"cjloj0lmr004eykpbsym9xidf"},{"post_id":"cjloj0lmi003xykpbcxxcv4l3","tag_id":"cjloj0lle0011ykpbam3ai8su","_id":"cjloj0lms004hykpbgc5fhg5a"},{"post_id":"cjloj0lml0045ykpbjo7jgagw","tag_id":"cjloj0lle0011ykpbam3ai8su","_id":"cjloj0lmu004lykpb00v9cybr"},{"post_id":"cjloj0lml0045ykpbjo7jgagw","tag_id":"cjloj0llq001vykpb0tapwavs","_id":"cjloj0lmv004pykpb8zq9e1bp"},{"post_id":"cjloj0llc000yykpbuqo65hwa","tag_id":"cjloj0lm2002sykpb6mxbdz3n","_id":"cjloj0lmw004tykpbre2ct1sy"},{"post_id":"cjloj0llc000yykpbuqo65hwa","tag_id":"cjloj0llt0025ykpbmj2193ss","_id":"cjloj0lmy004wykpbz5kfoy6u"},{"post_id":"cjloj0llc000yykpbuqo65hwa","tag_id":"cjloj0llm001oykpb2uoer3hb","_id":"cjloj0lmz0050ykpb0x84ct0t"},{"post_id":"cjloj0lmu004mykpbgguz7qb4","tag_id":"cjloj0lkw0007ykpbfsq2874z","_id":"cjloj0ln20054ykpbbulbgx1l"},{"post_id":"cjloj0lmu004mykpbgguz7qb4","tag_id":"cjloj0lle0011ykpbam3ai8su","_id":"cjloj0ln40058ykpbugu25378"},{"post_id":"cjloj0lmu004mykpbgguz7qb4","tag_id":"cjloj0llm001oykpb2uoer3hb","_id":"cjloj0ln5005bykpbhf5u5vvj"},{"post_id":"cjloj0lle0012ykpbhgvw700x","tag_id":"cjloj0llq001vykpb0tapwavs","_id":"cjloj0ln7005gykpbwdfwy61w"},{"post_id":"cjloj0lle0012ykpbhgvw700x","tag_id":"cjloj0lms004iykpbfq9nvlak","_id":"cjloj0ln8005jykpb9bp3dmn1"},{"post_id":"cjloj0lmv004qykpbcmuge83p","tag_id":"cjloj0llq001vykpb0tapwavs","_id":"cjloj0lna005oykpbnlkgicl2"},{"post_id":"cjloj0lmv004qykpbcmuge83p","tag_id":"cjloj0lkw0007ykpbfsq2874z","_id":"cjloj0lnb005rykpbh7ga8tmo"},{"post_id":"cjloj0llf0015ykpbxzgr3v4u","tag_id":"cjloj0lm2002sykpb6mxbdz3n","_id":"cjloj0lnd005wykpbf8zvo470"},{"post_id":"cjloj0llf0015ykpbxzgr3v4u","tag_id":"cjloj0llt0025ykpbmj2193ss","_id":"cjloj0lnd005yykpboh484lc4"},{"post_id":"cjloj0llf0015ykpbxzgr3v4u","tag_id":"cjloj0llm001oykpb2uoer3hb","_id":"cjloj0lne0062ykpbppv7bw9u"},{"post_id":"cjloj0llg0019ykpb5c4es12n","tag_id":"cjloj0ln7005fykpbo5yqjdvf","_id":"cjloj0lne0064ykpbv7meo4ux"},{"post_id":"cjloj0llg0019ykpb5c4es12n","tag_id":"cjloj0lna005nykpbswt6kimb","_id":"cjloj0lnf0067ykpby6ix90jd"},{"post_id":"cjloj0llh001dykpbriihxwra","tag_id":"cjloj0ln7005fykpbo5yqjdvf","_id":"cjloj0lnf006aykpblxm8os1p"},{"post_id":"cjloj0llj001gykpb8h5czhiu","tag_id":"cjloj0ln7005fykpbo5yqjdvf","_id":"cjloj0lng006cykpbujqf2rpx"},{"post_id":"cjloj0llj001gykpb8h5czhiu","tag_id":"cjloj0lkw0007ykpbfsq2874z","_id":"cjloj0lng006fykpb6spd5bzl"},{"post_id":"cjloj0llk001jykpbpblb368u","tag_id":"cjloj0ln7005fykpbo5yqjdvf","_id":"cjloj0lnh006iykpbfhraailf"},{"post_id":"cjloj0llk001jykpbpblb368u","tag_id":"cjloj0lng006bykpbdbgsywhm","_id":"cjloj0lnh006jykpb554kczpo"},{"post_id":"cjloj0lll001mykpbgj0uwm5h","tag_id":"cjloj0ln7005fykpbo5yqjdvf","_id":"cjloj0lni006mykpb7dytd6jn"},{"post_id":"cjloj0lln001pykpb3pl3jqux","tag_id":"cjloj0lni006kykpb3p2ydnqj","_id":"cjloj0lnj006pykpbxlk204sx"},{"post_id":"cjloj0lln001pykpb3pl3jqux","tag_id":"cjloj0lni006nykpbpc7djmlq","_id":"cjloj0lnj006qykpba665mt5w"},{"post_id":"cjloj0llp001sykpb2l9tgd2j","tag_id":"cjloj0lni006oykpbbmjti1a7","_id":"cjloj0lnj006sykpb3ijfko91"},{"post_id":"cjloj0llq001wykpbumswwezx","tag_id":"cjloj0lni006oykpbbmjti1a7","_id":"cjloj0lnk006vykpbfso0wh67"},{"post_id":"cjloj0llq001wykpbumswwezx","tag_id":"cjloj0llt0025ykpbmj2193ss","_id":"cjloj0lnk006wykpbk6rawp8e"},{"post_id":"cjloj0llr0020ykpbdxy460wh","tag_id":"cjloj0lni006oykpbbmjti1a7","_id":"cjloj0lnl006zykpbzm4tfr6v"},{"post_id":"cjloj0llr0020ykpbdxy460wh","tag_id":"cjloj0llt0025ykpbmj2193ss","_id":"cjloj0lnl0070ykpbo6h50k7g"},{"post_id":"cjloj0lls0023ykpby6ypiqxr","tag_id":"cjloj0lni006oykpbbmjti1a7","_id":"cjloj0lnm0073ykpbbj2j62cg"},{"post_id":"cjloj0lls0023ykpby6ypiqxr","tag_id":"cjloj0lnl0071ykpbb0ihhpzq","_id":"cjloj0lnm0074ykpbum14x6hg"},{"post_id":"cjloj0llt0027ykpbiyqr5rra","tag_id":"cjloj0lnm0072ykpbzgwumabp","_id":"cjloj0lnm0077ykpbrp1ruo46"},{"post_id":"cjloj0llt0027ykpbiyqr5rra","tag_id":"cjloj0lnm0075ykpbcoqgyo6x","_id":"cjloj0lnn0078ykpbbcsc4cua"},{"post_id":"cjloj0llu002aykpb69h6jg13","tag_id":"cjloj0lnm0076ykpb9a311ecd","_id":"cjloj0lnn007bykpb9x1rk6zn"},{"post_id":"cjloj0llu002aykpb69h6jg13","tag_id":"cjloj0lnn0079ykpbklfrj656","_id":"cjloj0lnn007cykpb4h59r5z1"},{"post_id":"cjloj0lly002hykpb28n299vd","tag_id":"cjloj0lnn007aykpb5gwu95q1","_id":"cjloj0lno007fykpbwm579jgv"},{"post_id":"cjloj0lly002hykpb28n299vd","tag_id":"cjloj0lnn007dykpbslqhqzkc","_id":"cjloj0lno007gykpbcrttdjdu"},{"post_id":"cjloj0llz002lykpblkrgfwsr","tag_id":"cjloj0lni006nykpbpc7djmlq","_id":"cjloj0lno007iykpb8361knbj"},{"post_id":"cjloj0lm1002pykpbnmn5vwe8","tag_id":"cjloj0lle0011ykpbam3ai8su","_id":"cjloj0lnp007kykpb93gpvmgg"},{"post_id":"cjloj0lm1002pykpbnmn5vwe8","tag_id":"cjloj0lna005nykpbswt6kimb","_id":"cjloj0lnp007lykpb9kym35i7"},{"post_id":"cjloj0lm2002tykpb18srbtw5","tag_id":"cjloj0lle0011ykpbam3ai8su","_id":"cjloj0lnq007nykpb9fv1d6rv"},{"post_id":"cjloj0lm2002tykpb18srbtw5","tag_id":"cjloj0llt0025ykpbmj2193ss","_id":"cjloj0lnr007oykpbej02u5kk"},{"post_id":"cjloj0lm2002tykpb18srbtw5","tag_id":"cjloj0lnp007jykpbyz9bl125","_id":"cjloj0lnr007qykpbf6mtqlkh"},{"post_id":"cjloj0lm80039ykpburkj5bss","tag_id":"cjloj0lle0011ykpbam3ai8su","_id":"cjloj0lnr007rykpbm8yf36rq"},{"post_id":"cjloj0lm80039ykpburkj5bss","tag_id":"cjloj0lnp007mykpbf76k0wyj","_id":"cjloj0lnr007tykpbywasb867"},{"post_id":"cjloj0lm9003cykpbcuv7s64k","tag_id":"cjloj0lle0011ykpbam3ai8su","_id":"cjloj0lns007uykpb78l93iq2"},{"post_id":"cjloj0lm9003cykpbcuv7s64k","tag_id":"cjloj0llt0025ykpbmj2193ss","_id":"cjloj0lns007wykpbnwqwtqfd"},{"post_id":"cjloj0lm9003cykpbcuv7s64k","tag_id":"cjloj0lnr007pykpb071ijsin","_id":"cjloj0lns007xykpbvg7rco2l"},{"post_id":"cjloj0lmb003hykpbl29fvuxu","tag_id":"cjloj0lle0011ykpbam3ai8su","_id":"cjloj0lns007zykpbjh76z5ri"},{"post_id":"cjloj0lmb003hykpbl29fvuxu","tag_id":"cjloj0lnr007sykpb895ccq8y","_id":"cjloj0lnt0080ykpbf0gvydpr"},{"post_id":"cjloj0lmb003hykpbl29fvuxu","tag_id":"cjloj0llt0025ykpbmj2193ss","_id":"cjloj0lnt0082ykpbt4gxp39s"},{"post_id":"cjloj0lmc003kykpbj2o9z4ie","tag_id":"cjloj0lle0011ykpbam3ai8su","_id":"cjloj0lnt0083ykpbcuugmnrp"},{"post_id":"cjloj0lmc003kykpbj2o9z4ie","tag_id":"cjloj0lnr007sykpb895ccq8y","_id":"cjloj0lnt0084ykpbydnnph0h"},{"post_id":"cjloj0lmj0040ykpbp5td5xiy","tag_id":"cjloj0lle0011ykpbam3ai8su","_id":"cjloj0lnu0086ykpbjq0suym1"},{"post_id":"cjloj0lmj0040ykpbp5td5xiy","tag_id":"cjloj0lnp007mykpbf76k0wyj","_id":"cjloj0lnu0087ykpbgj8698f1"},{"post_id":"cjloj0lmo0048ykpb26y9dnd6","tag_id":"cjloj0lnt0081ykpbz8j313fj","_id":"cjloj0lnu0089ykpbw6n1ghtp"},{"post_id":"cjloj0lmo0048ykpb26y9dnd6","tag_id":"cjloj0lkw0007ykpbfsq2874z","_id":"cjloj0lnv008aykpbi92y44pm"},{"post_id":"cjloj0lmq004cykpboq4t2xna","tag_id":"cjloj0lkw0007ykpbfsq2874z","_id":"cjloj0lnv008cykpbbfpxoowc"},{"post_id":"cjloj0lmq004cykpboq4t2xna","tag_id":"cjloj0lnu0085ykpb0vtjzvic","_id":"cjloj0lnv008dykpbvpyx1ezu"},{"post_id":"cjloj0lmr004fykpbncq6dtnc","tag_id":"cjloj0lnt0081ykpbz8j313fj","_id":"cjloj0lnv008fykpbdvs6b7wx"},{"post_id":"cjloj0lmr004fykpbncq6dtnc","tag_id":"cjloj0lkw0007ykpbfsq2874z","_id":"cjloj0lnw008gykpbcaj28gs1"},{"post_id":"cjloj0lmr004fykpbncq6dtnc","tag_id":"cjloj0lnv008bykpb0fbixje6","_id":"cjloj0lnw008iykpbu9twicg3"},{"post_id":"cjloj0lmt004jykpbhiq1ifth","tag_id":"cjloj0lnv008eykpbqec41o5m","_id":"cjloj0lnw008jykpbbsbe4y2p"},{"post_id":"cjloj0lmw004uykpby2cpmzx4","tag_id":"cjloj0lkw0007ykpbfsq2874z","_id":"cjloj0lnw008lykpbc2whas6c"},{"post_id":"cjloj0lmw004uykpby2cpmzx4","tag_id":"cjloj0lnw008hykpbzz085iyl","_id":"cjloj0lnx008mykpbgy2ef838"},{"post_id":"cjloj0lmy004xykpb9lj8xkwx","tag_id":"cjloj0lnw008kykpbds84akyf","_id":"cjloj0lnx008oykpbrf3kmr73"},{"post_id":"cjloj0ln00051ykpb2io7zp9f","tag_id":"cjloj0lni006oykpbbmjti1a7","_id":"cjloj0lnx008qykpb42kb79lm"},{"post_id":"cjloj0ln20055ykpbm95jzsrj","tag_id":"cjloj0lnx008pykpbs64hjzhf","_id":"cjloj0lnz008uykpbh6bqqx49"},{"post_id":"cjloj0ln20055ykpbm95jzsrj","tag_id":"cjloj0lnm0075ykpbcoqgyo6x","_id":"cjloj0lnz008vykpb5iuai69l"},{"post_id":"cjloj0ln20055ykpbm95jzsrj","tag_id":"cjloj0lnn007aykpb5gwu95q1","_id":"cjloj0lnz008xykpbjlvfx93d"},{"post_id":"cjloj0ln40059ykpbs62pnu8z","tag_id":"cjloj0lny008tykpbo80r5zdt","_id":"cjloj0lo0008yykpbygjuoqvn"},{"post_id":"cjloj0ln40059ykpbs62pnu8z","tag_id":"cjloj0lkw0007ykpbfsq2874z","_id":"cjloj0lo00090ykpbgqe0kk4y"},{"post_id":"cjloj0ln5005cykpbea1gkz7s","tag_id":"cjloj0lnz008wykpbgi3gkvf5","_id":"cjloj0lo10092ykpb7sq91ppb"},{"post_id":"cjloj0ln5005cykpbea1gkz7s","tag_id":"cjloj0lo0008zykpb2zr610cf","_id":"cjloj0lo10093ykpbe61pgkvb"},{"post_id":"cjloj0ln7005hykpbyc06t2vx","tag_id":"cjloj0lnz008wykpbgi3gkvf5","_id":"cjloj0lo20096ykpbr6wfr0ww"},{"post_id":"cjloj0ln7005hykpbyc06t2vx","tag_id":"cjloj0lnv008eykpbqec41o5m","_id":"cjloj0lo20097ykpbg3x16ud3"},{"post_id":"cjloj0ln8005kykpbyt8h622e","tag_id":"cjloj0lo10095ykpbjhy1ebvv","_id":"cjloj0lo3009cykpbwiqwbayt"},{"post_id":"cjloj0ln8005kykpbyt8h622e","tag_id":"cjloj0lo20098ykpb8wc5a1bl","_id":"cjloj0lo3009dykpb0cjm6v7q"},{"post_id":"cjloj0ln8005kykpbyt8h622e","tag_id":"cjloj0lo20099ykpb67ow75jx","_id":"cjloj0lo4009fykpbcrn9g602"},{"post_id":"cjloj0ln8005kykpbyt8h622e","tag_id":"cjloj0lo2009aykpb2w78sfqv","_id":"cjloj0lo4009gykpbn0wikcjs"},{"post_id":"cjloj0lna005pykpbj404mtln","tag_id":"cjloj0lnl0071ykpbb0ihhpzq","_id":"cjloj0lo4009iykpbk6zej29c"},{"post_id":"cjloj0lna005pykpbj404mtln","tag_id":"cjloj0lnw008kykpbds84akyf","_id":"cjloj0lo4009jykpbrwxoaqy1"},{"post_id":"cjloj0lnb005sykpbi7n5gred","tag_id":"cjloj0lnz008wykpbgi3gkvf5","_id":"cjloj0lo4009kykpbm1rdm313"}],"Tag":[{"name":"Docker","_id":"cjloj0lkw0007ykpbfsq2874z"},{"name":"Ambari","_id":"cjloj0ll1000cykpbmhqt2xv7"},{"name":"Jenkins","_id":"cjloj0ll5000hykpb20lkt6lr"},{"name":"CDH","_id":"cjloj0llb000vykpbl0afku54"},{"name":"Spark","_id":"cjloj0lle0011ykpbam3ai8su"},{"name":"Docker-machine","_id":"cjloj0llh001bykpbjply43s2"},{"name":"安装部署","_id":"cjloj0llk001iykpbng7kqfgo"},{"name":"Hadoop","_id":"cjloj0llm001oykpb2uoer3hb"},{"name":"HBase","_id":"cjloj0llq001vykpb0tapwavs"},{"name":"原理","_id":"cjloj0llt0025ykpbmj2193ss"},{"name":"操作","_id":"cjloj0llz002kykpbutsr3yf5"},{"name":"HDFS","_id":"cjloj0lm2002sykpb6mxbdz3n"},{"name":"Shell","_id":"cjloj0lms004iykpbfq9nvlak"},{"name":"Hive","_id":"cjloj0ln7005fykpbo5yqjdvf"},{"name":"使用","_id":"cjloj0lna005nykpbswt6kimb"},{"name":"报表","_id":"cjloj0lng006bykpbdbgsywhm"},{"name":"Json","_id":"cjloj0lni006kykpb3p2ydnqj"},{"name":"Scala","_id":"cjloj0lni006nykpbpc7djmlq"},{"name":"Kafka","_id":"cjloj0lni006oykpbbmjti1a7"},{"name":"大数据","_id":"cjloj0lnl0071ykpbb0ihhpzq"},{"name":"linux","_id":"cjloj0lnm0072ykpbzgwumabp"},{"name":"开发","_id":"cjloj0lnm0075ykpbcoqgyo6x"},{"name":"Linux","_id":"cjloj0lnm0076ykpb9a311ecd"},{"name":"Mysql","_id":"cjloj0lnn0079ykpbklfrj656"},{"name":"Java","_id":"cjloj0lnn007aykpb5gwu95q1"},{"name":"SSH","_id":"cjloj0lnn007dykpbslqhqzkc"},{"name":"Yarn","_id":"cjloj0lnp007jykpbyz9bl125"},{"name":"SparkSQL","_id":"cjloj0lnp007mykpbf76k0wyj"},{"name":"RDD","_id":"cjloj0lnr007pykpb071ijsin"},{"name":"SparkStreaming","_id":"cjloj0lnr007sykpb895ccq8y"},{"name":"ELK","_id":"cjloj0lnt0081ykpbz8j313fj"},{"name":"FLINK","_id":"cjloj0lnu0085ykpb0vtjzvic"},{"name":"es","_id":"cjloj0lnv008bykpb0fbixje6"},{"name":"git","_id":"cjloj0lnv008eykpbqec41o5m"},{"name":"Hue","_id":"cjloj0lnw008hykpbzz085iyl"},{"name":"命令","_id":"cjloj0lnw008kykpbds84akyf"},{"name":"技术","_id":"cjloj0lnx008pykpbs64hjzhf"},{"name":"zk","_id":"cjloj0lny008tykpbo80r5zdt"},{"name":"Hexo","_id":"cjloj0lnz008wykpbgi3gkvf5"},{"name":"Other","_id":"cjloj0lo0008zykpb2zr610cf"},{"name":"快捷键","_id":"cjloj0lo10095ykpbjhy1ebvv"},{"name":"Mac","_id":"cjloj0lo20098ykpb8wc5a1bl"},{"name":"Idea","_id":"cjloj0lo20099ykpb67ow75jx"},{"name":"Finder","_id":"cjloj0lo2009aykpb2w78sfqv"}]}}